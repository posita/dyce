{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to dyce dyce is a pure-Python library for exploring dice probabilities designed to be immediately and broadly useful with minimal additional investment beyond basic knowledge of Python. Inspired by AnyDice , dyce leverages Pythonic syntax and operators for rolling dice and computing weighted outcomes. While Python is not as terse as a dedicated grammar, it is quite sufficient. Those familiar with various game notations should be able to adapt quickly. dyce is fairly low level by design, prioritizing ergonomics and composability. In an intentional departure from RFC 1925, \u00a7 2.2 , it provides some basic inspection conveniences which make it useful for tinkering on its own. However, it really shines when used in larger contexts such as Matplotlib or Jupyter . If you have suggested improvements for use with other tools and, please consider contributing . Examples dyce provides two key primitives. H represent histograms (individual dice or outcomes) and D represent collections of histograms (dice sets): 1 >>> from dyce import D , H Both support arithmetic operations. Histograms are used to express individual dice and results. A six-sided die can be expressed as: 1 2 >>> H ( 6 ) H ( 6 ) H(n) is shorthand for explicitly enumerating faces \\([{{1} .. {n}}]\\) , each with a frequency of 1: 1 2 >>> H ( 6 ) == H ({ 1 : 1 , 2 : 1 , 3 : 1 , 4 : 1 , 5 : 1 , 6 : 1 }) True Tuples with repeating faces are accumulated. A six-sided \u201c2, 3, 3, 4, 4, 5\u201d die can be expressed as: 1 2 >>> H (( 2 , 3 , 3 , 4 , 4 , 5 )) H ({ 2 : 1 , 3 : 2 , 4 : 2 , 5 : 1 }) A fudge die can be expressed as: 1 2 >>> H (( - 1 , 0 , 1 )) H ({ - 1 : 1 , 0 : 1 , 1 : 1 }) Python\u2019s matrix multiplication operator ( @ ) is used to express the number of a particular die (roughly equivalent to the \u201c d \u201d operator in common notations). A set of two six-sided dice ( 2d6 ) is: 1 2 >>> 2 @D ( H ( 6 )) D ( 6 , 6 ) Where n is an integer, D(n, ...) is shorthand for D(H(n), ...) . The above can be expressed more succinctly: 1 2 >>> 2 @D ( 6 ) D ( 6 , 6 ) Dice sets (in this case Sicherman dice ) can be compared to histograms: 1 2 3 >>> sicherman_d = D ( H (( 1 , 2 , 2 , 3 , 3 , 4 )), H (( 1 , 3 , 4 , 5 , 6 , 8 ))) >>> sicherman_d == 2 @H ( 6 ) True Arithmetic operations implicitly flatten dice sets into histograms. 3\u00d7(2d6+4) is: 1 2 >>> 3 * ( 2 @D ( 6 ) + 4 ) H ({ 18 : 1 , 21 : 2 , 24 : 3 , 27 : 4 , 30 : 5 , 33 : 6 , 36 : 5 , 39 : 4 , 42 : 3 , 45 : 2 , 48 : 1 }) In interpreting the results, we see there is one way to make 18 , two ways to make 21 , three ways to make 24 , etc. Histograms are sufficient for most calculations. However, dice sets are useful for taking only some of the set\u2019s faces. This is done using Python\u2019s indexing operator ( [\u2026] ). Indexes can be integers, slices, or iterables thereof. Faces are ordered from least (at index 0 ) to greatest (at index -1 ). Summing the least two faces when rolling three six-sided dice would be: 1 2 3 4 5 >>> 3 @D ( 6 ) D ( 6 , 6 , 6 ) >>> ( 3 @D ( 6 ))[: 2 ] # see warning below about parentheses H ({ 2 : 16 , 3 : 27 , 4 : 34 , 5 : 36 , 6 : 34 , 7 : 27 , 8 : 19 , 9 : 12 , 10 : 7 , 11 : 3 , 12 : 1 }) Mind your parentheses Parentheses are needed in the above example because @ has a lower precedence than [\u2026] . 1 2 3 4 5 6 >>> 2 @D ( 6 )[ 1 ] # equivalent to 2@(D(6)[1]) Traceback ( most recent call last ): ... IndexError : tuple index out of range >>> ( 2 @D ( 6 ))[ 1 ] H ({ 1 : 1 , 2 : 3 , 3 : 5 , 4 : 7 , 5 : 9 , 6 : 11 }) Histograms provide rudimentary formatting for convenience: 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> print (( 2 @H ( 6 )) . format ( width = 65 )) avg | 7.00 2 | 2.78 % | # 3 | 5.56 % | ## 4 | 8.33 % | #### 5 | 11.11 % | ##### 6 | 13.89 % | ###### 7 | 16.67 % | ######## 8 | 13.89 % | ###### 9 | 11.11 % | ##### 10 | 8.33 % | #### 11 | 5.56 % | ## 12 | 2.78 % | # Selecting the least, middle, or greatest face when rolling three six-sided dice would be: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 >>> ( 3 @D ( 6 ))[ 0 ] H ({ 1 : 91 , 2 : 61 , 3 : 37 , 4 : 19 , 5 : 7 , 6 : 1 }) >>> print ( _ . format ( width = 65 )) avg | 2.04 1 | 42.13 % | ##################### 2 | 28.24 % | ############## 3 | 17.13 % | ######## 4 | 8.80 % | #### 5 | 3.24 % | # 6 | 0.46 % | >>> ( 3 @D ( 6 ))[ 1 ] H ({ 1 : 16 , 2 : 40 , 3 : 52 , 4 : 52 , 5 : 40 , 6 : 16 }) >>> print ( _ . format ( width = 65 )) avg | 3.50 1 | 7.41 % | ### 2 | 18.52 % | ######### 3 | 24.07 % | ############ 4 | 24.07 % | ############ 5 | 18.52 % | ######### 6 | 7.41 % | ### >>> ( 3 @D ( 6 ))[ - 1 ] H ({ 1 : 1 , 2 : 7 , 3 : 19 , 4 : 37 , 5 : 61 , 6 : 91 }) >>> print ( _ . format ( width = 65 )) avg | 4.96 1 | 0.46 % | 2 | 3.24 % | # 3 | 8.80 % | #### 4 | 17.13 % | ######## 5 | 28.24 % | ############## 6 | 42.13 % | ##################### Summing the greatest and the least faces when rolling an entire standard six-die polygonal set would be: 1 2 3 4 >>> H ( 10 ) - 1 # a common \u201cd10\u201d with faces [0 .. 9] H ({ 0 : 1 , 1 : 1 , 2 : 1 , 3 : 1 , 4 : 1 , 5 : 1 , 6 : 1 , 7 : 1 , 8 : 1 , 9 : 1 }) >>> D ( 4 , 6 , 8 , _ , 12 , 20 )[ 0 , - 1 ] H ({ 1 : 1 , 2 : 32 , 3 : 273 , 4 : 1384 , ... , 21 : 20736 , 22 : 9240 , 23 : 3360 , 24 : 810 }) If matplotlib is installed (e.g., via Jupyter ), dyce.plt provides some experimental, rudimentary conveniences: 1 2 >>> from dyce.plt import plot_burst >>> fig , ax = plot_burst ( 2 @H ( 6 )) # doctest: +SKIP Calling matplotlib.pyplot.show presents: The outer ring and corresponding labels can be overridden for interesting, at-a-glance displays. Overrides apply counter-clockwise, starting from the 12 o\u2018clock position: 1 2 3 4 5 6 7 >>> d20 = D ( 20 ) ... fig , ax = plot_burst ( d20 . h (), outer = ( ... ( \"crit. fail.\" , d20 . le ( 1 )[ 1 ]), ... ( \"fail.\" , d20 . within ( 2 , 14 )[ 0 ]), ... ( \"succ.\" , d20 . within ( 15 , 19 )[ 0 ]), ... ( \"crit. succ.\" , d20 . ge ( 20 )[ 1 ]), ... ), graph_color = \"RdYlBu_r\" ) # doctest: +SKIP Calling matplotlib.pyplot.show presents: License dyce is licensed under the MIT License . See the LICENSE file for details. Source code is available on GitHub . Installation Installation can be performed via pip (which will download and install the latest release ): 1 2 % pip install dycelib ... Alternately, you can download the sources (e.g., from GitHub ) and run setup.py : 1 2 3 4 5 % git clone https://github.com/posita/dyce ... % cd dyce % python setup.py install ... Requirements A modern version of Python is required: cPython (3.6+) PyPy (Python 3.6+ compatible) dyce has the following dependencies (which will be installed automatically): typing typing-extensions","title":"Introduction"},{"location":"#introduction-to-dyce","text":"dyce is a pure-Python library for exploring dice probabilities designed to be immediately and broadly useful with minimal additional investment beyond basic knowledge of Python. Inspired by AnyDice , dyce leverages Pythonic syntax and operators for rolling dice and computing weighted outcomes. While Python is not as terse as a dedicated grammar, it is quite sufficient. Those familiar with various game notations should be able to adapt quickly. dyce is fairly low level by design, prioritizing ergonomics and composability. In an intentional departure from RFC 1925, \u00a7 2.2 , it provides some basic inspection conveniences which make it useful for tinkering on its own. However, it really shines when used in larger contexts such as Matplotlib or Jupyter . If you have suggested improvements for use with other tools and, please consider contributing .","title":"Introduction to dyce"},{"location":"#examples","text":"dyce provides two key primitives. H represent histograms (individual dice or outcomes) and D represent collections of histograms (dice sets): 1 >>> from dyce import D , H Both support arithmetic operations. Histograms are used to express individual dice and results. A six-sided die can be expressed as: 1 2 >>> H ( 6 ) H ( 6 ) H(n) is shorthand for explicitly enumerating faces \\([{{1} .. {n}}]\\) , each with a frequency of 1: 1 2 >>> H ( 6 ) == H ({ 1 : 1 , 2 : 1 , 3 : 1 , 4 : 1 , 5 : 1 , 6 : 1 }) True Tuples with repeating faces are accumulated. A six-sided \u201c2, 3, 3, 4, 4, 5\u201d die can be expressed as: 1 2 >>> H (( 2 , 3 , 3 , 4 , 4 , 5 )) H ({ 2 : 1 , 3 : 2 , 4 : 2 , 5 : 1 }) A fudge die can be expressed as: 1 2 >>> H (( - 1 , 0 , 1 )) H ({ - 1 : 1 , 0 : 1 , 1 : 1 }) Python\u2019s matrix multiplication operator ( @ ) is used to express the number of a particular die (roughly equivalent to the \u201c d \u201d operator in common notations). A set of two six-sided dice ( 2d6 ) is: 1 2 >>> 2 @D ( H ( 6 )) D ( 6 , 6 ) Where n is an integer, D(n, ...) is shorthand for D(H(n), ...) . The above can be expressed more succinctly: 1 2 >>> 2 @D ( 6 ) D ( 6 , 6 ) Dice sets (in this case Sicherman dice ) can be compared to histograms: 1 2 3 >>> sicherman_d = D ( H (( 1 , 2 , 2 , 3 , 3 , 4 )), H (( 1 , 3 , 4 , 5 , 6 , 8 ))) >>> sicherman_d == 2 @H ( 6 ) True Arithmetic operations implicitly flatten dice sets into histograms. 3\u00d7(2d6+4) is: 1 2 >>> 3 * ( 2 @D ( 6 ) + 4 ) H ({ 18 : 1 , 21 : 2 , 24 : 3 , 27 : 4 , 30 : 5 , 33 : 6 , 36 : 5 , 39 : 4 , 42 : 3 , 45 : 2 , 48 : 1 }) In interpreting the results, we see there is one way to make 18 , two ways to make 21 , three ways to make 24 , etc. Histograms are sufficient for most calculations. However, dice sets are useful for taking only some of the set\u2019s faces. This is done using Python\u2019s indexing operator ( [\u2026] ). Indexes can be integers, slices, or iterables thereof. Faces are ordered from least (at index 0 ) to greatest (at index -1 ). Summing the least two faces when rolling three six-sided dice would be: 1 2 3 4 5 >>> 3 @D ( 6 ) D ( 6 , 6 , 6 ) >>> ( 3 @D ( 6 ))[: 2 ] # see warning below about parentheses H ({ 2 : 16 , 3 : 27 , 4 : 34 , 5 : 36 , 6 : 34 , 7 : 27 , 8 : 19 , 9 : 12 , 10 : 7 , 11 : 3 , 12 : 1 }) Mind your parentheses Parentheses are needed in the above example because @ has a lower precedence than [\u2026] . 1 2 3 4 5 6 >>> 2 @D ( 6 )[ 1 ] # equivalent to 2@(D(6)[1]) Traceback ( most recent call last ): ... IndexError : tuple index out of range >>> ( 2 @D ( 6 ))[ 1 ] H ({ 1 : 1 , 2 : 3 , 3 : 5 , 4 : 7 , 5 : 9 , 6 : 11 }) Histograms provide rudimentary formatting for convenience: 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> print (( 2 @H ( 6 )) . format ( width = 65 )) avg | 7.00 2 | 2.78 % | # 3 | 5.56 % | ## 4 | 8.33 % | #### 5 | 11.11 % | ##### 6 | 13.89 % | ###### 7 | 16.67 % | ######## 8 | 13.89 % | ###### 9 | 11.11 % | ##### 10 | 8.33 % | #### 11 | 5.56 % | ## 12 | 2.78 % | # Selecting the least, middle, or greatest face when rolling three six-sided dice would be: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 >>> ( 3 @D ( 6 ))[ 0 ] H ({ 1 : 91 , 2 : 61 , 3 : 37 , 4 : 19 , 5 : 7 , 6 : 1 }) >>> print ( _ . format ( width = 65 )) avg | 2.04 1 | 42.13 % | ##################### 2 | 28.24 % | ############## 3 | 17.13 % | ######## 4 | 8.80 % | #### 5 | 3.24 % | # 6 | 0.46 % | >>> ( 3 @D ( 6 ))[ 1 ] H ({ 1 : 16 , 2 : 40 , 3 : 52 , 4 : 52 , 5 : 40 , 6 : 16 }) >>> print ( _ . format ( width = 65 )) avg | 3.50 1 | 7.41 % | ### 2 | 18.52 % | ######### 3 | 24.07 % | ############ 4 | 24.07 % | ############ 5 | 18.52 % | ######### 6 | 7.41 % | ### >>> ( 3 @D ( 6 ))[ - 1 ] H ({ 1 : 1 , 2 : 7 , 3 : 19 , 4 : 37 , 5 : 61 , 6 : 91 }) >>> print ( _ . format ( width = 65 )) avg | 4.96 1 | 0.46 % | 2 | 3.24 % | # 3 | 8.80 % | #### 4 | 17.13 % | ######## 5 | 28.24 % | ############## 6 | 42.13 % | ##################### Summing the greatest and the least faces when rolling an entire standard six-die polygonal set would be: 1 2 3 4 >>> H ( 10 ) - 1 # a common \u201cd10\u201d with faces [0 .. 9] H ({ 0 : 1 , 1 : 1 , 2 : 1 , 3 : 1 , 4 : 1 , 5 : 1 , 6 : 1 , 7 : 1 , 8 : 1 , 9 : 1 }) >>> D ( 4 , 6 , 8 , _ , 12 , 20 )[ 0 , - 1 ] H ({ 1 : 1 , 2 : 32 , 3 : 273 , 4 : 1384 , ... , 21 : 20736 , 22 : 9240 , 23 : 3360 , 24 : 810 }) If matplotlib is installed (e.g., via Jupyter ), dyce.plt provides some experimental, rudimentary conveniences: 1 2 >>> from dyce.plt import plot_burst >>> fig , ax = plot_burst ( 2 @H ( 6 )) # doctest: +SKIP Calling matplotlib.pyplot.show presents: The outer ring and corresponding labels can be overridden for interesting, at-a-glance displays. Overrides apply counter-clockwise, starting from the 12 o\u2018clock position: 1 2 3 4 5 6 7 >>> d20 = D ( 20 ) ... fig , ax = plot_burst ( d20 . h (), outer = ( ... ( \"crit. fail.\" , d20 . le ( 1 )[ 1 ]), ... ( \"fail.\" , d20 . within ( 2 , 14 )[ 0 ]), ... ( \"succ.\" , d20 . within ( 15 , 19 )[ 0 ]), ... ( \"crit. succ.\" , d20 . ge ( 20 )[ 1 ]), ... ), graph_color = \"RdYlBu_r\" ) # doctest: +SKIP Calling matplotlib.pyplot.show presents:","title":"Examples"},{"location":"#license","text":"dyce is licensed under the MIT License . See the LICENSE file for details. Source code is available on GitHub .","title":"License"},{"location":"#installation","text":"Installation can be performed via pip (which will download and install the latest release ): 1 2 % pip install dycelib ... Alternately, you can download the sources (e.g., from GitHub ) and run setup.py : 1 2 3 4 5 % git clone https://github.com/posita/dyce ... % cd dyce % python setup.py install ...","title":"Installation"},{"location":"#requirements","text":"A modern version of Python is required: cPython (3.6+) PyPy (Python 3.6+ compatible) dyce has the following dependencies (which will be installed automatically): typing typing-extensions","title":"Requirements"},{"location":"contrib/","text":"Contributing to dyce There are several ways you can contribute. Filing Issues You can file new issues as you find them. Please avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful. Submission Guidelines If you are willing and able, consider submitting a pull request (PR) with a fix. There are only a few guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file: 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=dyce ); GitHub - [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Try to follow the source conventions as you observe them. (Note: I have purposely avoided aspects of PEP8 , in part because I have adopted conventions developed from my experiences with other languages, but mostly because I am growing older and more stubborn.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in ./tests and can be run with Tox or pytest . A helper script is provided for setting up an isolated development environment. For example: 1 2 3 [ PYTHON = /path/to/python ] ./helpers/venvsetup.sh tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] pytest [ PYTEST_ARGS... ] If you need me, mention me ( @posita ) in your comment, and describe specifically how I can help. If you want feedback on a work-in-progress (WIP), create a PR and prefix its title with something like, \u201c NEED FEEDBACK - \u201d. If your PR is still in progress, but you are not blocked on anything, prefix the title with something like, \u201c WIP - \u201d. Once you are ready for a merge, resolve any merge conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) Then prefix the PR\u2019s title to something like, \u201c READY FOR MERGE - \u201d. I will try to get to it as soon as I can.","title":"Contributing"},{"location":"contrib/#contributing-to-dyce","text":"There are several ways you can contribute.","title":"Contributing to dyce"},{"location":"contrib/#filing-issues","text":"You can file new issues as you find them. Please avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful.","title":"Filing Issues"},{"location":"contrib/#submission-guidelines","text":"If you are willing and able, consider submitting a pull request (PR) with a fix. There are only a few guidelines: If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the LICENSE file: 1 2 3 ... * [ Matt Bogosian ]( mailto:matt@bogosian.net?Subject=dyce ); GitHub - [ **@posita** ](https://github.com/posita) ... Use Black to format your changes. Try to follow the source conventions as you observe them. (Note: I have purposely avoided aspects of PEP8 , in part because I have adopted conventions developed from my experiences with other languages, but mostly because I am growing older and more stubborn.) Provide tests where feasible and appropriate. At the very least, existing tests should not fail. (There are exceptions, but if there is any doubt, they probably do not apply.) Unit tests live in ./tests and can be run with Tox or pytest . A helper script is provided for setting up an isolated development environment. For example: 1 2 3 [ PYTHON = /path/to/python ] ./helpers/venvsetup.sh tox [ TOX_ARGS... [ -- PYTEST_ARGS... ]] pytest [ PYTEST_ARGS... ] If you need me, mention me ( @posita ) in your comment, and describe specifically how I can help. If you want feedback on a work-in-progress (WIP), create a PR and prefix its title with something like, \u201c NEED FEEDBACK - \u201d. If your PR is still in progress, but you are not blocked on anything, prefix the title with something like, \u201c WIP - \u201d. Once you are ready for a merge, resolve any merge conflicts, squash your commits, and provide a useful commit message. ( This and this may be helpful.) Then prefix the PR\u2019s title to something like, \u201c READY FOR MERGE - \u201d. I will try to get to it as soon as I can.","title":"Submission Guidelines"},{"location":"dyce/","text":"dyce package reference dyce provides two key primitives: [ H ][dyce.lib.H] for histograms (individual dice or outcomes) [ D ][dyce.lib.D] for collections of histograms (dice sets) H An immutable mapping for use as a histogram that supports arithmetic operations. The initializer takes a single parameter, items . In its most explicit form, items maps faces to counts. Modeling a single six-sided die ( 1d6 ) can be expressed as: >>> h6 = H ({ 1 : 1 , 2 : 1 , 3 : 1 , 4 : 1 , 5 : 1 , 6 : 1 }) An iterable of pairs can also be used (similar to dict ): >>> h6 == H ((( 1 , 1 ), ( 2 , 1 ), ( 3 , 1 ), ( 4 , 1 ), ( 5 , 1 ), ( 6 , 1 ))) True Two shorthands are provided. If items an iterable of int s, counts of one will be assumed: >>> h6 == H (( 1 , 2 , 3 , 4 , 5 , 6 )) True Repeated items do what one would expect: >>> H (( 2 , 3 , 3 , 4 , 4 , 5 )) H ({ 2 : 1 , 3 : 2 , 4 : 2 , 5 : 1 }) If items is an int , it is shorthand for creating a sequential range [{1} .. {items}] [{1} .. {items}] (or [{items} .. {-1}] [{items} .. {-1}] if items is negative): >>> h6 == H ( 6 ) True Simple indexes can be used to look up a face\u2019s count: >>> h6 [ 5 ] 1 Most arithmetic operators are supported and do what one would expect. If the operand is an int , the operator applies to the faces: >>> h6 + 4 H ({ 5 : 1 , 6 : 1 , 7 : 1 , 8 : 1 , 9 : 1 , 10 : 1 }) >>> h6 * - 1 H ({ - 6 : 1 , - 5 : 1 , - 4 : 1 , - 3 : 1 , - 2 : 1 , - 1 : 1 }) >>> h6 * - 1 == - h6 True >>> h6 * - 1 == H ( - 6 ) True If the operand is another histogram, combinations are computed. Modeling the sum of two six-sided dice ( 2d6 ) can be expressed as: >>> h6 + h6 H ({ 2 : 1 , 3 : 2 , 4 : 3 , 5 : 4 , 6 : 5 , 7 : 6 , 8 : 5 , 9 : 4 , 10 : 3 , 11 : 2 , 12 : 1 }) >>> print ( _ . format ( width = 65 )) avg | 7.00 2 | 2.78 % | # 3 | 5.56 % | ## 4 | 8.33 % | #### 5 | 11.11 % | ##### 6 | 13.89 % | ###### 7 | 16.67 % | ######## 8 | 13.89 % | ###### 9 | 11.11 % | ##### 10 | 8.33 % | #### 11 | 5.56 % | ## 12 | 2.78 % | # To sum {n} {n} identical histograms, the matrix multiplication operator ( @ ) provides a shorthand: >>> 3 @h6 == h6 + h6 + h6 True The len built-in function can be used to show the number of distinct sums: >>> len ( 2 @h6 ) 11 The [ counts method][dyce.lib.H.counts] can be used to show the total number of combinations: >>> sum (( 2 @h6 ) . counts ()) 36 Counts are generally accumulated without reduction: >>> h6 . concat ( h6 ) . concat ( h6 ) H ({ 1 : 3 , 2 : 3 , 3 : 3 , 4 : 3 , 5 : 3 , 6 : 3 }) To reduce, call the [ lowest_terms method][dyce.lib.H.lowest_terms]: >>> _ . lowest_terms () H ({ 1 : 1 , 2 : 1 , 3 : 1 , 4 : 1 , 5 : 1 , 6 : 1 }) Testing equivalence implicitly performs reductions of operands: >>> h6 . concat ( h6 ) == h6 . concat ( h6 ) . concat ( h6 ) True Histograms provide common comparators (e.g., [ eq ][dyce.lib.H.eq] [ ne ][dyce.lib.H.ne], etc.). One way to count how often a first six-sided die shows a different face than a second is: >>> h6 . ne ( h6 ) H ({ 0 : 6 , 1 : 30 }) >>> print ( _ . format ( width = 65 )) avg | 0.83 0 | 16.67 % | ######## 1 | 83.33 % | ######################################### Or, how often a first six-sided die shows a face less than a second is: >>> h6 . lt ( h6 ) H ({ 0 : 21 , 1 : 15 }) >>> print ( _ . format ( width = 65 )) avg | 0.42 0 | 58.33 % | ############################# 1 | 41.67 % | #################### Or how often at least one 2 will show when rolling four six-sided dice: >>> h6 . eq ( 2 ) # how often a 2 shows on a single six-sided die H ({ 0 : 5 , 1 : 1 }) >>> 4 @ ( _ ) # counts of how many 2s show on 4d6 H ({ 0 : 625 , 1 : 500 , 2 : 150 , 3 : 20 , 4 : 1 }) >>> _ . ge ( 1 ) # how often the count is at least one H ({ 0 : 625 , 1 : 671 }) >>> print ( _ . format ( width = 65 )) avg | 0.52 0 | 48.23 % | ######################## 1 | 51.77 % | ######################### Mind your parentheses Parentheses are often necessary to enforce the desired order of operations: >>> 2 @h6 . le ( 7 ) # probably not what was intended H ({ 2 : 36 }) >>> 2 @h6 . le ( 7 ) == 2 @ ( h6 . le ( 7 )) True >>> ( 2 @h6 ) . le ( 7 ) H ({ 0 : 15 , 1 : 21 }) >>> 2 @h6 . le ( 7 ) == ( 2 @h6 ) . le ( 7 ) False __init__ ( self , items ) special Initializer. Source code in dyce/lib.py def __init__ ( self , items : SourceT ) -> None : r \"Initializer.\" super () . __init__ () self . _simple_init = None if isinstance ( items , int ): if items < 0 : self . _simple_init = items items = range ( - 1 , items - 1 , - 1 ) elif items > 0 : self . _simple_init = items items = range ( 1 , items + 1 ) else : items = {} elif isinstance ( items , H . AbleT ): items = items . h () if not isinstance ( items , collections . abc . Mapping ): h = collections . defaultdict ( int ) # type: DefaultDict[int, int] for item in items : if isinstance ( item , tuple ): face , count = item h [ face ] += count else : h [ item ] += 1 items = h self . _h = collections . OrderedDict (( face , items [ face ]) for face in sorted ( items )) concat ( self , other ) Accumulates counts: >>> H ( 4 ) . concat ( H ( 6 )) H ({ 1 : 2 , 2 : 2 , 3 : 2 , 4 : 2 , 5 : 1 , 6 : 1 }) Source code in dyce/lib.py def concat ( self , other : SourceT ) -> \"H\" : r \"\"\" Accumulates counts: ```python >>> H(4).concat(H(6)) H({1: 2, 2: 2, 3: 2, 4: 2, 5: 1, 6: 1}) ``` \"\"\" if isinstance ( other , int ): other = ( other ,) elif isinstance ( other , collections . abc . Mapping ): other = other . items () return H ( itertools . chain ( self . items (), cast ( Iterable , other ))) counts ( self ) More descriptive synonym for the [ values method][dyce.lib.H.values]. Source code in dyce/lib.py def counts ( self ) -> Iterator [ int ]: r \"\"\" More descriptive synonym for the [``values`` method][dyce.lib.H.values]. \"\"\" return self . values () data ( self , relative = False , fill_items = None ) Presentation helper function that returns an iterator for each face/frequency pair: >>> h6 = H ( 6 ) >>> list ( h6 . gt ( 3 ) . data ()) [( 0 , 3.0 ), ( 1 , 3.0 )] >>> list ( h6 . gt ( 3 ) . data ( relative = True )) [( 0 , 0.5 ), ( 1 , 0.5 )] If provided, fill_items supplies defaults for any missing faces: >>> list ( h6 . gt ( 7 ) . data ()) [( 0 , 6.0 )] >>> list ( h6 . gt ( 7 ) . data ( fill_items = { 1 : 0 , 0 : 0 })) [( 0 , 6.0 ), ( 1 , 0.0 )] Source code in dyce/lib.py def data ( self , relative : bool = False , fill_items : Optional [ Mapping [ int , int ]] = None , ) -> Iterator [ Tuple [ int , float ]]: r \"\"\" Presentation helper function that returns an iterator for each face/frequency pair: ```python >>> h6 = H(6) >>> list(h6.gt(3).data()) [(0, 3.0), (1, 3.0)] >>> list(h6.gt(3).data(relative=True)) [(0, 0.5), (1, 0.5)] ``` If provided, *fill_items* supplies defaults for any missing faces: ```python >>> list(h6.gt(7).data()) [(0, 6.0)] >>> list(h6.gt(7).data(fill_items={1: 0, 0: 0})) [(0, 6.0), (1, 0.0)] ``` \"\"\" if fill_items is None : fill_items = {} if relative : total = sum ( self . counts ()) or 1 else : total = 1 combined = dict ( itertools . chain ( fill_items . items (), self . items ())) return (( face , count / total ) for face , count in sorted ( combined . items ())) data_xy ( self , relative = False , fill_items = None ) Presentation helper function that returns an iterator for a \u201czipped\u201d arrangement of the output from the [ data method][dyce.lib.H.data]: >>> h6 = H ( 6 ) >>> list ( h6 . data ()) [( 1 , 1.0 ), ( 2 , 1.0 ), ( 3 , 1.0 ), ( 4 , 1.0 ), ( 5 , 1.0 ), ( 6 , 1.0 )] >>> h6 . data_xy () (( 1 , 2 , 3 , 4 , 5 , 6 ), ( 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 )) Source code in dyce/lib.py def data_xy ( self , relative : bool = False , fill_items : Optional [ Mapping [ int , int ]] = None , ) -> Tuple [ Tuple [ int , ... ], Tuple [ float , ... ]]: r \"\"\" Presentation helper function that returns an iterator for a \u201czipped\u201d arrangement of the output from the [``data`` method][dyce.lib.H.data]: ```python >>> h6 = H(6) >>> list(h6.data()) [(1, 1.0), (2, 1.0), (3, 1.0), (4, 1.0), (5, 1.0), (6, 1.0)] >>> h6.data_xy() ((1, 2, 3, 4, 5, 6), (1.0, 1.0, 1.0, 1.0, 1.0, 1.0)) ``` \"\"\" return cast ( Tuple [ Tuple [ int , ... ], Tuple [ float , ... ]], tuple ( zip ( * self . data ( relative , fill_items ))), ) eq ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.filter(operator.eq, other, t_val, f_val) . >>> H ( 6 ) . eq ( 3 ) H ({ 0 : 5 , 1 : 1 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def eq ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.eq, other, t_val, f_val)``. ```python >>> H(6).eq(3) H({0: 5, 1: 1}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . eq , other , t_val , f_val ) even ( self , t_val = 1 , f_val = 0 ) >>> H (( - 4 , - 2 , 0 , 1 , 2 , 3 )) . even () H ({ 0 : 2 , 1 : 4 }) Source code in dyce/lib.py def even ( self , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 ) -> \"H\" : r \"\"\" ```python >>> H((-4, -2, 0, 1, 2, 3)).even() H({0: 2, 1: 4}) ``` \"\"\" def is_even ( a , _ ): return a % 2 == 0 return self . filter ( is_even , 0 , t_val , f_val ) faces ( self ) More descriptive synonym for the [ keys method][dyce.lib.H.keys]. Source code in dyce/lib.py def faces ( self ) -> Iterator [ int ]: r \"\"\" More descriptive synonym for the [``keys`` method][dyce.lib.H.keys]. \"\"\" return self . keys () filter ( self , predicate , other , t_val = None , f_val = None ) Applies predicate to each face of the histogram paired with other . If the result is True , t_val is returned, if set. Otherwise the face is returned. If the result is False , f_val is returned, if set. Otherwise, the other face is returned. >>> h6 = H ( 6 ) >>> h6 . filter ( operator . gt , 3 ) H ({ 3 : 3 , 4 : 1 , 5 : 1 , 6 : 1 }) >>> h6 . filter ( operator . gt , 3 , f_val = 0 ) H ({ 0 : 3 , 4 : 1 , 5 : 1 , 6 : 1 }) >>> h6 . filter ( operator . gt , 3 , t_val = 1 , f_val = 0 ) H ({ 0 : 3 , 1 : 3 }) Note that shorthands exist for many comparison operators: >>> h6 . gt ( h6 ) == h6 . filter ( operator . gt , h6 , t_val = 1 , f_val = 0 ) True >>> h6 . le ( h6 , t_val = 1 , f_val =- 1 ) == h6 . filter ( operator . le , h6 , t_val = 1 , f_val =- 1 ) True Source code in dyce/lib.py def filter ( self , predicate : _BinaryPredicateT , other : OperandT , t_val : Optional [ int ] = None , f_val : Optional [ int ] = None , ) -> \"H\" : r \"\"\" Applies *predicate* to each face of the histogram paired with *other*. If the result is ``True``, *t_val* is returned, if set. Otherwise the face is returned. If the result is ``False``, *f_val* is returned, if set. Otherwise, the other face is returned. ```python >>> h6 = H(6) >>> h6.filter(operator.gt, 3) H({3: 3, 4: 1, 5: 1, 6: 1}) >>> h6.filter(operator.gt, 3, f_val=0) H({0: 3, 4: 1, 5: 1, 6: 1}) >>> h6.filter(operator.gt, 3, t_val=1, f_val=0) H({0: 3, 1: 3}) ``` Note that shorthands exist for many comparison operators: ```python >>> h6.gt(h6) == h6.filter(operator.gt, h6, t_val=1, f_val=0) True >>> h6.le(h6, t_val=1, f_val=-1) == h6.filter(operator.le, h6, t_val=1, f_val=-1) True ``` \"\"\" def _resolve ( a : int , b : int ): if predicate ( a , b ): return a if t_val is None else t_val else : return b if f_val is None else f_val return self . map ( _resolve , other ) format ( self , fill_items = None , width = 88 , tick = '#' , sep = ' \\n ' ) Returns a formatted string representation of the histogram. If provided, fill_items supplies defaults for any missing faces. If width is greater than zero, a horizontal bar ASCII graph is printed using tick and sep (which are otherwise ignored if width is zero or less). >>> print ( H ( 6 ) . format ( width = 0 )) { avg : 3.50 , 1 : 16.67 % , 2 : 16.67 % , 3 : 16.67 % , 4 : 16.67 % , 5 : 16.67 % , 6 : 16.67 % } >>> print (( 2 @H ( 6 )) . format ( fill_items = { i : 0 for i in range ( 1 , 21 )}, width = 65 , tick = \"@\" )) avg | 7.00 1 | 0.00 % | 2 | 2.78 % |@ 3 | 5.56 % |@@ 4 | 8.33 % |@@@@ 5 | 11.11 % |@@@@@ 6 | 13.89 % |@@@@@@ 7 | 16.67 % |@@@@@@@@ 8 | 13.89 % |@@@@@@ 9 | 11.11 % |@@@@@ 10 | 8.33 % |@@@@ 11 | 5.56 % |@@ 12 | 2.78 % |@ 13 | 0.00 % | 14 | 0.00 % | 15 | 0.00 % | 16 | 0.00 % | 17 | 0.00 % | 18 | 0.00 % | 19 | 0.00 % | 20 | 0.00 % | Source code in dyce/lib.py def format ( self , fill_items : Optional [ Mapping [ int , int ]] = None , width : int = _ROW_WIDTH , tick : str = \"#\" , sep : str = os . linesep , ) -> str : r \"\"\" Returns a formatted string representation of the histogram. If provided, *fill_items* supplies defaults for any missing faces. If *width* is greater than zero, a horizontal bar ASCII graph is printed using *tick* and *sep* (which are otherwise ignored if *width* is zero or less). ```python >>> print(H(6).format(width=0)) {avg: 3.50, 1: 16.67%, 2: 16.67%, 3: 16.67%, 4: 16.67%, 5: 16.67%, 6: 16.67%} >>> print((2@H(6)).format(fill_items={i: 0 for i in range(1, 21)}, width=65, tick=\"@\")) avg | 7.00 1 | 0.00% | 2 | 2.78% |@ 3 | 5.56% |@@ 4 | 8.33% |@@@@ 5 | 11.11% |@@@@@ 6 | 13.89% |@@@@@@ 7 | 16.67% |@@@@@@@@ 8 | 13.89% |@@@@@@ 9 | 11.11% |@@@@@ 10 | 8.33% |@@@@ 11 | 5.56% |@@ 12 | 2.78% |@ 13 | 0.00% | 14 | 0.00% | 15 | 0.00% | 16 | 0.00% | 17 | 0.00% | 18 | 0.00% | 19 | 0.00% | 20 | 0.00% | ``` \"\"\" if width <= 0 : def parts (): yield \"avg: {:.2f} \" . format ( self . avg ()) for face , percentage in self . data ( relative = True , fill_items = fill_items ): yield \" {} : {:7.2%} \" . format ( face , percentage ) return \"{\" + \", \" . join ( parts ()) + \"}\" else : w = width - 15 def lines (): yield \"avg | {:7.2f} \" . format ( self . avg ()) for face , percentage in self . data ( relative = True , fill_items = fill_items ): ticks = int ( w * percentage ) yield \" {: 3} | {:7.2%} | {} \" . format ( face , percentage , tick * ticks ) return sep . join ( lines ()) ge ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.filter(operator.ge, other, t_val, f_val) . >>> H ( 6 ) . ge ( 3 ) H ({ 0 : 2 , 1 : 4 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def ge ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.ge, other, t_val, f_val)``. ```python >>> H(6).ge(3) H({0: 2, 1: 4}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . ge , other , t_val , f_val ) gt ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.filter(operator.gt, other, t_val, f_val) . >>> H ( 6 ) . gt ( 3 ) H ({ 0 : 3 , 1 : 3 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def gt ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.gt, other, t_val, f_val)``. ```python >>> H(6).gt(3) H({0: 3, 1: 3}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . gt , other , t_val , f_val ) items ( self ) D.items() -> a set-like object providing a view on D's items Source code in dyce/lib.py def items ( self ): return self . _h . items () keys ( self ) D.keys() -> a set-like object providing a view on D's keys Source code in dyce/lib.py def keys ( self ): return self . _h . keys () le ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.filter(operator.le, other, t_val, f_val) . >>> H ( 6 ) . le ( 3 ) H ({ 0 : 3 , 1 : 3 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def le ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.le, other, t_val, f_val)``. ```python >>> H(6).le(3) H({0: 3, 1: 3}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . le , other , t_val , f_val ) lowest_terms ( self ) Computes and returns a histogram whose counts share a greatest common divisor of 1. >>> H (( - 1 , - 1 , 0 , 0 , 1 , 1 )) H ({ - 1 : 2 , 0 : 2 , 1 : 2 }) >>> _ . lowest_terms () H ({ - 1 : 1 , 0 : 1 , 1 : 1 }) >>> H (( 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 5 , 5 )) H ({ 2 : 2 , 3 : 4 , 4 : 4 , 5 : 2 }) >>> _ . lowest_terms () H ({ 2 : 1 , 3 : 2 , 4 : 2 , 5 : 1 }) Source code in dyce/lib.py def lowest_terms ( self ) -> \"H\" : r \"\"\" Computes and returns a histogram whose counts share a greatest common divisor of 1. ```python >>> H((-1, -1, 0, 0, 1, 1)) H({-1: 2, 0: 2, 1: 2}) >>> _.lowest_terms() H({-1: 1, 0: 1, 1: 1}) >>> H((2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5)) H({2: 2, 3: 4, 4: 4, 5: 2}) >>> _.lowest_terms() H({2: 1, 3: 2, 4: 2, 5: 1}) ``` \"\"\" counts_gcd = functools . reduce ( math . gcd , self . counts (), 0 ) return H ({ k : v // counts_gcd for k , v in self . items ()}) lt ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.filter(operator.lt, other, t_val, f_val) : >>> H ( 6 ) . lt ( 3 ) H ({ 0 : 4 , 1 : 2 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def lt ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.lt, other, t_val, f_val)``: ```python >>> H(6).lt(3) H({0: 4, 1: 2}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . lt , other , t_val , f_val ) map ( self , oper , other ) Applies oper to each face of the histogram paired with other : >>> h6 = H ( 6 ) >>> h6 . map ( operator . add , h6 ) H ({ 2 : 1 , 3 : 2 , 4 : 3 , 5 : 4 , 6 : 5 , 7 : 6 , 8 : 5 , 9 : 4 , 10 : 3 , 11 : 2 , 12 : 1 }) >>> h6 . map ( operator . mul , - 1 ) H ({ - 6 : 1 , - 5 : 1 , - 4 : 1 , - 3 : 1 , - 2 : 1 , - 1 : 1 }) Note that shorthands exist for many arithmetic operators: >>> h6 * - 1 == h6 . map ( operator . mul , - 1 ) True >>> h6 + h6 == h6 . map ( operator . add , h6 ) True Source code in dyce/lib.py def map ( self , oper : _BinaryOperatorT , other : OperandT ) -> \"H\" : r \"\"\" Applies *oper* to each face of the histogram paired with *other*: ```python >>> h6 = H(6) >>> h6.map(operator.add, h6) H({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1}) >>> h6.map(operator.mul, -1) H({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1}) ``` Note that shorthands exist for many arithmetic operators: ```python >>> h6 * -1 == h6.map(operator.mul, -1) True >>> h6 + h6 == h6.map(operator.add, h6) True ``` \"\"\" if isinstance ( other , H . AbleT ): other = other . h () if isinstance ( other , int ): return H (( int ( oper ( face , other )), count ) for face , count in self . items ()) elif isinstance ( other , H ): return H ( ( int ( oper ( a , b )), self [ a ] * other [ b ]) for a , b in itertools . product ( self , other ) ) else : raise NotImplementedError ne ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.filter(operator.ne, other, t_val, f_val) . >>> H ( 6 ) . ne ( 3 ) H ({ 0 : 1 , 1 : 5 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def ne ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.ne, other, t_val, f_val)``. ```python >>> H(6).ne(3) H({0: 1, 1: 5}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . ne , other , t_val , f_val ) odd ( self , t_val = 1 , f_val = 0 ) >>> H (( - 4 , - 2 , 0 , 1 , 2 , 3 )) . odd () H ({ 0 : 4 , 1 : 2 }) Source code in dyce/lib.py def odd ( self , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 ) -> \"H\" : r \"\"\" ```python >>> H((-4, -2, 0, 1, 2, 3)).odd() H({0: 4, 1: 2}) ``` \"\"\" def is_odd ( a , _ ): return a % 2 != 0 return self . filter ( is_odd , 0 , t_val , f_val ) roll ( self ) Returns a (weighted) random face. Source code in dyce/lib.py def roll ( self ) -> int : r \"\"\" Returns a (weighted) random face. \"\"\" val = random . randrange ( 0 , sum ( self . counts ())) total = 0 for face , count in self . items (): total += count if val < total : return face assert False , \"val ( {} ) \u2265 total ( {} )\" . format ( val , total ) substitute ( self , expand , coalesce = None , max_depth = 1 ) Calls expand on each face, recursively up to max_depth times. If expand returns non- None , coalesce is called on the face and the expanded histogram, and the returned histogram is folded into result. The default behavior for coalesce is to replace the face with the expanded histogram. This can be used to model complex rules. The following models re-rolling a face of 1 on the first roll: >>> def reroll_one ( h : H , face : int ) -> Optional [ H ]: ... return h if face == 1 else None >>> H ( 6 ) . substitute ( reroll_one ) H ({ 1 : 1 , 2 : 7 , 3 : 7 , 4 : 7 , 5 : 7 , 6 : 7 }) The following approximates an exploding three-sided die (i.e., if the greatest face comes up, the die is rolled again and its face is added to the total): >>> def reroll_greatest ( h : H , face : int ) -> Optional [ H ]: ... return h if face == max ( h ) else None >>> H ( 3 ) . substitute ( reroll_greatest , operator . add , max_depth = 4 ) H ({ 1 : 81 , 2 : 81 , 4 : 27 , 5 : 27 , 7 : 9 , 8 : 9 , 10 : 3 , 11 : 3 , 13 : 1 , 14 : 1 , 15 : 1 }) Consider the following rules: Start with a total of zero. Roll a six-sided die. Add the face to the total. If the face was a six, go to step 3. Otherwise stop. Roll a four-sided die. Add the face to the total. If the face was a four, go to step 2. Otherwise stop. What is the likelihood of an even final tally? This can be approximated by: >>> h4 , h6 = H ( 4 ), H ( 6 ) >>> def reroll_greatest_on_h4_h6 ( h : H , face : int ) -> Optional [ H ]: ... if face == max ( h ): ... if h == h6 : return h4 ... if h == h4 : return h6 ... return None >>> h = h6 . substitute ( reroll_greatest_on_h4_h6 , operator . add , max_depth = 6 ) >>> h_even = h . even () >>> print ( \" {:.3%} \" . format ( h_even . get ( 1 , 0 ) / sum ( h_even . counts ()))) 39.131 % Source code in dyce/lib.py def substitute ( self , expand : _ExpandT , coalesce : Optional [ _CoalesceT ] = None , max_depth : int = 1 , ) -> \"H\" : r \"\"\" Calls *expand* on each face, recursively up to *max_depth* times. If *expand* returns non-``None``, *coalesce* is called on the face and the expanded histogram, and the returned histogram is folded into result. The default behavior for *coalesce* is to replace the face with the expanded histogram. This can be used to model complex rules. The following models re-rolling a face of 1 on the first roll: ```python >>> def reroll_one(h: H, face: int) -> Optional[H]: ... return h if face == 1 else None >>> H(6).substitute(reroll_one) H({1: 1, 2: 7, 3: 7, 4: 7, 5: 7, 6: 7}) ``` The following approximates an exploding three-sided die (i.e., if the greatest face comes up, the die is rolled again and its face is added to the total): ```python >>> def reroll_greatest(h: H, face: int) -> Optional[H]: ... return h if face == max(h) else None >>> H(3).substitute(reroll_greatest, operator.add, max_depth=4) H({1: 81, 2: 81, 4: 27, 5: 27, 7: 9, 8: 9, 10: 3, 11: 3, 13: 1, 14: 1, 15: 1}) ``` Consider the following rules: 1. Start with a total of zero. 2. Roll a six-sided die. Add the face to the total. If the face was a six, go to step 3. Otherwise stop. 3. Roll a four-sided die. Add the face to the total. If the face was a four, go to step 2. Otherwise stop. What is the likelihood of an even final tally? This can be approximated by: ```python >>> h4, h6 = H(4), H(6) >>> def reroll_greatest_on_h4_h6(h: H, face: int) -> Optional[H]: ... if face == max(h): ... if h == h6: return h4 ... if h == h4: return h6 ... return None >>> h = h6.substitute(reroll_greatest_on_h4_h6, operator.add, max_depth=6) >>> h_even = h.even() >>> print(\"{:.3%}\".format(h_even.get(1, 0) / sum(h_even.counts()))) 39.131% ``` \"\"\" if coalesce is None : coalesce = _coalesce_replace def _substitute ( h : H , depth : int = 0 , ) -> H : assert coalesce is not None if depth == max_depth : return h expanded_items = [] # type: List[Tuple[int, int]] expanded_histograms = [] # type: List[H] for face , count in h . items (): expanded = expand ( h , face ) if expanded : expanded = _substitute ( expanded , depth + 1 ) expanded = H (( f , count * c ) for f , c in expanded . items ()) expanded = coalesce ( expanded , face ) expanded_histograms . append ( expanded ) else : expanded_items . append (( face , count )) count_multiplier = ( sum ( itertools . chain ( * ( ah . counts () for ah in expanded_histograms ))) or 1 ) expanded_counts = (( f , count_multiplier * c ) for f , c in expanded_items ) return H ( itertools . chain ( expanded_counts , * ( ah . items () for ah in expanded_histograms ) ) ) return _substitute ( self ) values ( self ) D.values() -> an object providing a view on D's values Source code in dyce/lib.py def values ( self ): return self . _h . values () within ( self , lo , hi , other = 0 ) Computes the difference between this histogram and other . -1 is represents where that difference is less than lo . 0 represents where that difference between lo and hi (inclusive). 1 represents where that difference is greater than hi . >>> ( 2 @H ( 6 )) . within ( 7 , 9 ) H ({ - 1 : 15 , 0 : 15 , 1 : 6 }) >>> print ( _ . format ( width = 65 )) avg | - 0.25 - 1 | 41.67 % | #################### 0 | 41.67 % | #################### 1 | 16.67 % | ######## >>> ( 3 @H ( 6 )) . within ( - 1 , 1 , 2 @H ( 8 )) # 3d6 w/in 1 of 2d8 H ({ - 1 : 3500 , 0 : 3412 , 1 : 6912 }) >>> print ( _ . format ( width = 65 )) avg | 0.25 - 1 | 25.32 % | ############ 0 | 24.68 % | ############ 1 | 50.00 % | ######################### Source code in dyce/lib.py def within ( self , lo : int , hi : int , other : OperandT = 0 ) -> \"H\" : r \"\"\" Computes the difference between this histogram and *other*. -1 is represents where that difference is less than *lo*. 0 represents where that difference between *lo* and *hi* (inclusive). 1 represents where that difference is greater than *hi*. ```python >>> (2@H(6)).within(7, 9) H({-1: 15, 0: 15, 1: 6}) >>> print(_.format(width=65)) avg | -0.25 -1 | 41.67% |#################### 0 | 41.67% |#################### 1 | 16.67% |######## >>> (3@H(6)).within(-1, 1, 2@H(8)) # 3d6 w/in 1 of 2d8 H({-1: 3500, 0: 3412, 1: 6912}) >>> print(_.format(width=65)) avg | 0.25 -1 | 25.32% |############ 0 | 24.68% |############ 1 | 50.00% |######################### ``` \"\"\" return self . map ( _within ( lo , hi ), other ) D An immutable container of convenience for a vector of zero or more [ H ][dyce.lib.H] objects supporting group operations. The vector can be flattened to a single histogram, either explicitly via the [ h method][dyce.lib.D.h], or by using binary arithmetic operations. Unary operators and the @ operator result in new D objects. If any of the initializer \u2019s args parameter is an int , it is passed to the constructor for H . >>> d6 = D ( 6 ) # shorthand for D(H(6)) >>> d6 D ( 6 ) >>> - d6 D ( - 6 ) >>> D ( d6 , d6 ) # 2d6 D ( 6 , 6 ) >>> 2 @d6 # also 2d6 D ( 6 , 6 ) >>> 2 @ ( 2 @d6 ) == 4 @d6 True >>> D ( 4 , D ( 6 , D ( 8 , D ( 10 , D ( 12 , D ( 20 )))))) D ( 4 , 6 , 8 , 10 , 12 , 20 ) >>> sum ( _ . roll ()) in _ . h () True Arithmetic operators involving an int or another D object produces an [ H object][dyce.lib.H]: >>> d6 + d6 H ({ 2 : 1 , 3 : 2 , 4 : 3 , 5 : 4 , 6 : 5 , 7 : 6 , 8 : 5 , 9 : 4 , 10 : 3 , 11 : 2 , 12 : 1 }) >>> 2 * D ( 8 ) - 1 H ({ 1 : 1 , 3 : 1 , 5 : 1 , 7 : 1 , 9 : 1 , 11 : 1 , 13 : 1 , 15 : 1 }) Comparisons between D and [ H ][dyce.lib.H] objects still work: >>> 3 @d6 == H ( 6 ) + H ( 6 ) + H ( 6 ) True For D objects containing more than one [ H object][dyce.lib.H], slicing grabs a subset of faces from least to greatest. Modeling the sum of the greatest two faces of three six-sided dice ( 3d6 ) can be expressed as: >>> ( 3 @d6 )[ - 2 :] H ({ 2 : 1 , 3 : 3 , 4 : 7 , 5 : 12 , 6 : 19 , 7 : 27 , 8 : 34 , 9 : 36 , 10 : 34 , 11 : 27 , 12 : 16 }) >>> print ( _ . format ( width = 65 )) avg | 8.46 2 | 0.46 % | 3 | 1.39 % | 4 | 3.24 % | # 5 | 5.56 % | ## 6 | 8.80 % | #### 7 | 12.50 % | ###### 8 | 15.74 % | ####### 9 | 16.67 % | ######## 10 | 15.74 % | ####### 11 | 12.50 % | ###### 12 | 7.41 % | ### Arbitrary iterables can be used for more flexible selections: >>> d = 6 @D ( 6 ) >>> every_other_d6 = d [:: - 2 ] >>> every_other_d6 H ({ 3 : 1 , 4 : 21 , 5 : 86 , ... , 16 : 1106 , 17 : 395 , 18 : 31 }) >>> d [ 5 , 3 , 1 ] == every_other_d6 True >>> d [ range ( 1 , 6 , 2 )] == every_other_d6 True >>> d [( i for i in range ( 0 , 6 ) if i % 2 == 1 )] == every_other_d6 True >>> d [{ 1 , 3 , 5 }] == every_other_d6 True Modeling the sum of the greatest two and least two faces of ten four-sided dice ( 10d4 ) can be expressed as: >>> ( 10 @D ( 4 ))[: 2 , - 2 :] H ({ 4 : 1 , 5 : 10 , 6 : 1012 , 7 : 5030 , 8 : 51973 , 9 : 168760 , 10 : 595004 , 11 : 168760 , 12 : 51973 , 13 : 5030 , 14 : 1012 , 15 : 10 , 16 : 1 }) >>> print ( _ . format ( width = 65 )) avg | 10.00 4 | 0.00 % | 5 | 0.00 % | 6 | 0.10 % | 7 | 0.48 % | 8 | 4.96 % | ## 9 | 16.09 % | ######## 10 | 56.74 % | ############################ 11 | 16.09 % | ######## 12 | 4.96 % | ## 13 | 0.48 % | 14 | 0.10 % | 15 | 0.00 % | 16 | 0.00 % | __init__ ( self , * args ) special Initializer. Source code in dyce/lib.py def __init__ ( self , * args : Union [ int , \"D\" , \"H\" ]) -> None : r \"Initializer.\" super () . __init__ () def _gen_hs (): for a in args : if isinstance ( a , int ): yield H ( a ) elif isinstance ( a , H ): yield a elif isinstance ( a , D ): for h in a . _hs : # pylint: disable=protected-access yield h else : raise TypeError ( \"type {} incompatible initializer for {} \" . format ( type ( a ), type ( self ) ) ) hs = list ( h for h in _gen_hs () if h ) hs . sort ( key = lambda h : tuple ( h . items ())) self . _hs = tuple ( hs ) eq ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.h().eq(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.eq ][dyce.lib.H.eq]. Source code in dyce/lib.py def eq ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().eq(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.eq``][dyce.lib.H.eq]. \"\"\" return self . h () . eq ( other , t_val , f_val ) even ( self , t_val = 1 , f_val = 0 ) Shorthand for self.h().even(t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.even ][dyce.lib.H.even]. Source code in dyce/lib.py def even ( self , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 ) -> \"H\" : r \"\"\" Shorthand for ``self.h().even(t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.even``][dyce.lib.H.even]. \"\"\" return self . h () . even ( t_val , f_val ) ge ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.h().ge(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.ge ][dyce.lib.H.ge]. Source code in dyce/lib.py def ge ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().ge(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.ge``][dyce.lib.H.ge]. \"\"\" return self . h () . ge ( other , t_val , f_val ) gt ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.h().gt(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.gt ][dyce.lib.H.gt]. Source code in dyce/lib.py def gt ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().gt(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.gt``][dyce.lib.H.gt]. \"\"\" return self . h () . gt ( other , t_val , f_val ) h ( self , index = None ) Combines contained histograms: >>> ( 2 @D ( 6 )) . h () H ({ 2 : 1 , 3 : 2 , 4 : 3 , 5 : 4 , 6 : 5 , 7 : 6 , 8 : 5 , 9 : 4 , 10 : 3 , 11 : 2 , 12 : 1 }) If the optional index parameter is provided, extract the contained histogram at that index: >>> D ( 4 , 6 , 8 ) . h ( 0 ) H ( 4 ) Note that containers are opinionated about histogram ordering: >>> D ( 8 , 6 , 4 ) . h ( 0 ) == D ( 8 , 4 , 6 ) . h ( 0 ) == H ( 4 ) True Source code in dyce/lib.py def h ( self , index : Optional [ int ] = None ) -> \"H\" : r \"\"\" Combines contained histograms: ```python >>> (2@D(6)).h() H({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1}) ``` If the optional *index* parameter is provided, extract the contained histogram at that index: ```python >>> D(4, 6, 8).h(0) H(4) ``` Note that containers are opinionated about histogram ordering: ```python >>> D(8, 6, 4).h(0) == D(8, 4, 6).h(0) == H(4) True ``` \"\"\" if index is not None : return self . _hs [ index ] if self . _hs : hs_sum = sum ( self . _hs ) else : hs_sum = H (()) return cast ( H , hs_sum ) le ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.h().le(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.le ][dyce.lib.H.le]. Source code in dyce/lib.py def le ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().le(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.le``][dyce.lib.H.le]. \"\"\" return self . h () . le ( other , t_val , f_val ) lt ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.h().lt(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.lt ][dyce.lib.H.lt]. Source code in dyce/lib.py def lt ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().lt(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.lt``][dyce.lib.H.lt]. \"\"\" return self . h () . lt ( other , t_val , f_val ) ne ( self , other , t_val = 1 , f_val = 0 ) Shorthand for self.h().ne(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.ne ][dyce.lib.H.ne]. Source code in dyce/lib.py def ne ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().ne(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.ne``][dyce.lib.H.ne]. \"\"\" return self . h () . ne ( other , t_val , f_val ) odd ( self , t_val = 1 , f_val = 0 ) Shorthand for self.h().odd(t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.odd ][dyce.lib.H.odd]. Source code in dyce/lib.py def odd ( self , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 ) -> \"H\" : r \"\"\" Shorthand for ``self.h().odd(t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.odd``][dyce.lib.H.odd]. \"\"\" return self . h () . odd ( t_val , f_val ) roll ( self ) Returns (weighted) random faces from contained histograms. Source code in dyce/lib.py def roll ( self ) -> Tuple [ int , ... ]: r \"\"\" Returns (weighted) random faces from contained histograms. \"\"\" return tuple ( h . roll () for h in self . _hs ) substitute ( self , expand , coalesce = None , max_depth = 1 ) Shorthand for self.h().substitute(expand, coalesce, max_depth) . See the [ h method][dyce.lib.D.h] and [ H.substitute ][dyce.lib.H.substitute]. Source code in dyce/lib.py def substitute ( self , expand : _ExpandT , coalesce : Optional [ _CoalesceT ] = None , max_depth : int = 1 , ) -> H : r \"\"\" Shorthand for ``self.h().substitute(expand, coalesce, max_depth)``. See the [``h`` method][dyce.lib.D.h] and [``H.substitute``][dyce.lib.H.substitute]. \"\"\" return self . h () . substitute ( expand , coalesce , max_depth ) within ( self , lo , hi , other = 0 ) Shorthand for self.h().within(lo, hi, other) . See the [ h method][dyce.lib.D.h] and [ H.within ][dyce.lib.H.within]. Source code in dyce/lib.py def within ( self , lo : int , hi : int , other : OperandT = 0 ) -> \"H\" : r \"\"\" Shorthand for ``self.h().within(lo, hi, other)``. See the [``h`` method][dyce.lib.D.h] and [``H.within``][dyce.lib.H.within]. \"\"\" return self . h () . within ( lo , hi , other )","title":"<tt>dyce</tt>"},{"location":"dyce/#dyce-package-reference","text":"","title":"dyce package reference"},{"location":"dyce/#dyce","text":"dyce provides two key primitives: [ H ][dyce.lib.H] for histograms (individual dice or outcomes) [ D ][dyce.lib.D] for collections of histograms (dice sets)","title":"dyce"},{"location":"dyce/#dyce.lib.H","text":"An immutable mapping for use as a histogram that supports arithmetic operations. The initializer takes a single parameter, items . In its most explicit form, items maps faces to counts. Modeling a single six-sided die ( 1d6 ) can be expressed as: >>> h6 = H ({ 1 : 1 , 2 : 1 , 3 : 1 , 4 : 1 , 5 : 1 , 6 : 1 }) An iterable of pairs can also be used (similar to dict ): >>> h6 == H ((( 1 , 1 ), ( 2 , 1 ), ( 3 , 1 ), ( 4 , 1 ), ( 5 , 1 ), ( 6 , 1 ))) True Two shorthands are provided. If items an iterable of int s, counts of one will be assumed: >>> h6 == H (( 1 , 2 , 3 , 4 , 5 , 6 )) True Repeated items do what one would expect: >>> H (( 2 , 3 , 3 , 4 , 4 , 5 )) H ({ 2 : 1 , 3 : 2 , 4 : 2 , 5 : 1 }) If items is an int , it is shorthand for creating a sequential range [{1} .. {items}] [{1} .. {items}] (or [{items} .. {-1}] [{items} .. {-1}] if items is negative): >>> h6 == H ( 6 ) True Simple indexes can be used to look up a face\u2019s count: >>> h6 [ 5 ] 1 Most arithmetic operators are supported and do what one would expect. If the operand is an int , the operator applies to the faces: >>> h6 + 4 H ({ 5 : 1 , 6 : 1 , 7 : 1 , 8 : 1 , 9 : 1 , 10 : 1 }) >>> h6 * - 1 H ({ - 6 : 1 , - 5 : 1 , - 4 : 1 , - 3 : 1 , - 2 : 1 , - 1 : 1 }) >>> h6 * - 1 == - h6 True >>> h6 * - 1 == H ( - 6 ) True If the operand is another histogram, combinations are computed. Modeling the sum of two six-sided dice ( 2d6 ) can be expressed as: >>> h6 + h6 H ({ 2 : 1 , 3 : 2 , 4 : 3 , 5 : 4 , 6 : 5 , 7 : 6 , 8 : 5 , 9 : 4 , 10 : 3 , 11 : 2 , 12 : 1 }) >>> print ( _ . format ( width = 65 )) avg | 7.00 2 | 2.78 % | # 3 | 5.56 % | ## 4 | 8.33 % | #### 5 | 11.11 % | ##### 6 | 13.89 % | ###### 7 | 16.67 % | ######## 8 | 13.89 % | ###### 9 | 11.11 % | ##### 10 | 8.33 % | #### 11 | 5.56 % | ## 12 | 2.78 % | # To sum {n} {n} identical histograms, the matrix multiplication operator ( @ ) provides a shorthand: >>> 3 @h6 == h6 + h6 + h6 True The len built-in function can be used to show the number of distinct sums: >>> len ( 2 @h6 ) 11 The [ counts method][dyce.lib.H.counts] can be used to show the total number of combinations: >>> sum (( 2 @h6 ) . counts ()) 36 Counts are generally accumulated without reduction: >>> h6 . concat ( h6 ) . concat ( h6 ) H ({ 1 : 3 , 2 : 3 , 3 : 3 , 4 : 3 , 5 : 3 , 6 : 3 }) To reduce, call the [ lowest_terms method][dyce.lib.H.lowest_terms]: >>> _ . lowest_terms () H ({ 1 : 1 , 2 : 1 , 3 : 1 , 4 : 1 , 5 : 1 , 6 : 1 }) Testing equivalence implicitly performs reductions of operands: >>> h6 . concat ( h6 ) == h6 . concat ( h6 ) . concat ( h6 ) True Histograms provide common comparators (e.g., [ eq ][dyce.lib.H.eq] [ ne ][dyce.lib.H.ne], etc.). One way to count how often a first six-sided die shows a different face than a second is: >>> h6 . ne ( h6 ) H ({ 0 : 6 , 1 : 30 }) >>> print ( _ . format ( width = 65 )) avg | 0.83 0 | 16.67 % | ######## 1 | 83.33 % | ######################################### Or, how often a first six-sided die shows a face less than a second is: >>> h6 . lt ( h6 ) H ({ 0 : 21 , 1 : 15 }) >>> print ( _ . format ( width = 65 )) avg | 0.42 0 | 58.33 % | ############################# 1 | 41.67 % | #################### Or how often at least one 2 will show when rolling four six-sided dice: >>> h6 . eq ( 2 ) # how often a 2 shows on a single six-sided die H ({ 0 : 5 , 1 : 1 }) >>> 4 @ ( _ ) # counts of how many 2s show on 4d6 H ({ 0 : 625 , 1 : 500 , 2 : 150 , 3 : 20 , 4 : 1 }) >>> _ . ge ( 1 ) # how often the count is at least one H ({ 0 : 625 , 1 : 671 }) >>> print ( _ . format ( width = 65 )) avg | 0.52 0 | 48.23 % | ######################## 1 | 51.77 % | ######################### Mind your parentheses Parentheses are often necessary to enforce the desired order of operations: >>> 2 @h6 . le ( 7 ) # probably not what was intended H ({ 2 : 36 }) >>> 2 @h6 . le ( 7 ) == 2 @ ( h6 . le ( 7 )) True >>> ( 2 @h6 ) . le ( 7 ) H ({ 0 : 15 , 1 : 21 }) >>> 2 @h6 . le ( 7 ) == ( 2 @h6 ) . le ( 7 ) False","title":"H"},{"location":"dyce/#dyce.lib.H.__init__","text":"Initializer. Source code in dyce/lib.py def __init__ ( self , items : SourceT ) -> None : r \"Initializer.\" super () . __init__ () self . _simple_init = None if isinstance ( items , int ): if items < 0 : self . _simple_init = items items = range ( - 1 , items - 1 , - 1 ) elif items > 0 : self . _simple_init = items items = range ( 1 , items + 1 ) else : items = {} elif isinstance ( items , H . AbleT ): items = items . h () if not isinstance ( items , collections . abc . Mapping ): h = collections . defaultdict ( int ) # type: DefaultDict[int, int] for item in items : if isinstance ( item , tuple ): face , count = item h [ face ] += count else : h [ item ] += 1 items = h self . _h = collections . OrderedDict (( face , items [ face ]) for face in sorted ( items ))","title":"__init__()"},{"location":"dyce/#dyce.lib.H.concat","text":"Accumulates counts: >>> H ( 4 ) . concat ( H ( 6 )) H ({ 1 : 2 , 2 : 2 , 3 : 2 , 4 : 2 , 5 : 1 , 6 : 1 }) Source code in dyce/lib.py def concat ( self , other : SourceT ) -> \"H\" : r \"\"\" Accumulates counts: ```python >>> H(4).concat(H(6)) H({1: 2, 2: 2, 3: 2, 4: 2, 5: 1, 6: 1}) ``` \"\"\" if isinstance ( other , int ): other = ( other ,) elif isinstance ( other , collections . abc . Mapping ): other = other . items () return H ( itertools . chain ( self . items (), cast ( Iterable , other )))","title":"concat()"},{"location":"dyce/#dyce.lib.H.counts","text":"More descriptive synonym for the [ values method][dyce.lib.H.values]. Source code in dyce/lib.py def counts ( self ) -> Iterator [ int ]: r \"\"\" More descriptive synonym for the [``values`` method][dyce.lib.H.values]. \"\"\" return self . values ()","title":"counts()"},{"location":"dyce/#dyce.lib.H.data","text":"Presentation helper function that returns an iterator for each face/frequency pair: >>> h6 = H ( 6 ) >>> list ( h6 . gt ( 3 ) . data ()) [( 0 , 3.0 ), ( 1 , 3.0 )] >>> list ( h6 . gt ( 3 ) . data ( relative = True )) [( 0 , 0.5 ), ( 1 , 0.5 )] If provided, fill_items supplies defaults for any missing faces: >>> list ( h6 . gt ( 7 ) . data ()) [( 0 , 6.0 )] >>> list ( h6 . gt ( 7 ) . data ( fill_items = { 1 : 0 , 0 : 0 })) [( 0 , 6.0 ), ( 1 , 0.0 )] Source code in dyce/lib.py def data ( self , relative : bool = False , fill_items : Optional [ Mapping [ int , int ]] = None , ) -> Iterator [ Tuple [ int , float ]]: r \"\"\" Presentation helper function that returns an iterator for each face/frequency pair: ```python >>> h6 = H(6) >>> list(h6.gt(3).data()) [(0, 3.0), (1, 3.0)] >>> list(h6.gt(3).data(relative=True)) [(0, 0.5), (1, 0.5)] ``` If provided, *fill_items* supplies defaults for any missing faces: ```python >>> list(h6.gt(7).data()) [(0, 6.0)] >>> list(h6.gt(7).data(fill_items={1: 0, 0: 0})) [(0, 6.0), (1, 0.0)] ``` \"\"\" if fill_items is None : fill_items = {} if relative : total = sum ( self . counts ()) or 1 else : total = 1 combined = dict ( itertools . chain ( fill_items . items (), self . items ())) return (( face , count / total ) for face , count in sorted ( combined . items ()))","title":"data()"},{"location":"dyce/#dyce.lib.H.data_xy","text":"Presentation helper function that returns an iterator for a \u201czipped\u201d arrangement of the output from the [ data method][dyce.lib.H.data]: >>> h6 = H ( 6 ) >>> list ( h6 . data ()) [( 1 , 1.0 ), ( 2 , 1.0 ), ( 3 , 1.0 ), ( 4 , 1.0 ), ( 5 , 1.0 ), ( 6 , 1.0 )] >>> h6 . data_xy () (( 1 , 2 , 3 , 4 , 5 , 6 ), ( 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 )) Source code in dyce/lib.py def data_xy ( self , relative : bool = False , fill_items : Optional [ Mapping [ int , int ]] = None , ) -> Tuple [ Tuple [ int , ... ], Tuple [ float , ... ]]: r \"\"\" Presentation helper function that returns an iterator for a \u201czipped\u201d arrangement of the output from the [``data`` method][dyce.lib.H.data]: ```python >>> h6 = H(6) >>> list(h6.data()) [(1, 1.0), (2, 1.0), (3, 1.0), (4, 1.0), (5, 1.0), (6, 1.0)] >>> h6.data_xy() ((1, 2, 3, 4, 5, 6), (1.0, 1.0, 1.0, 1.0, 1.0, 1.0)) ``` \"\"\" return cast ( Tuple [ Tuple [ int , ... ], Tuple [ float , ... ]], tuple ( zip ( * self . data ( relative , fill_items ))), )","title":"data_xy()"},{"location":"dyce/#dyce.lib.H.eq","text":"Shorthand for self.filter(operator.eq, other, t_val, f_val) . >>> H ( 6 ) . eq ( 3 ) H ({ 0 : 5 , 1 : 1 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def eq ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.eq, other, t_val, f_val)``. ```python >>> H(6).eq(3) H({0: 5, 1: 1}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . eq , other , t_val , f_val )","title":"eq()"},{"location":"dyce/#dyce.lib.H.even","text":">>> H (( - 4 , - 2 , 0 , 1 , 2 , 3 )) . even () H ({ 0 : 2 , 1 : 4 }) Source code in dyce/lib.py def even ( self , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 ) -> \"H\" : r \"\"\" ```python >>> H((-4, -2, 0, 1, 2, 3)).even() H({0: 2, 1: 4}) ``` \"\"\" def is_even ( a , _ ): return a % 2 == 0 return self . filter ( is_even , 0 , t_val , f_val )","title":"even()"},{"location":"dyce/#dyce.lib.H.faces","text":"More descriptive synonym for the [ keys method][dyce.lib.H.keys]. Source code in dyce/lib.py def faces ( self ) -> Iterator [ int ]: r \"\"\" More descriptive synonym for the [``keys`` method][dyce.lib.H.keys]. \"\"\" return self . keys ()","title":"faces()"},{"location":"dyce/#dyce.lib.H.filter","text":"Applies predicate to each face of the histogram paired with other . If the result is True , t_val is returned, if set. Otherwise the face is returned. If the result is False , f_val is returned, if set. Otherwise, the other face is returned. >>> h6 = H ( 6 ) >>> h6 . filter ( operator . gt , 3 ) H ({ 3 : 3 , 4 : 1 , 5 : 1 , 6 : 1 }) >>> h6 . filter ( operator . gt , 3 , f_val = 0 ) H ({ 0 : 3 , 4 : 1 , 5 : 1 , 6 : 1 }) >>> h6 . filter ( operator . gt , 3 , t_val = 1 , f_val = 0 ) H ({ 0 : 3 , 1 : 3 }) Note that shorthands exist for many comparison operators: >>> h6 . gt ( h6 ) == h6 . filter ( operator . gt , h6 , t_val = 1 , f_val = 0 ) True >>> h6 . le ( h6 , t_val = 1 , f_val =- 1 ) == h6 . filter ( operator . le , h6 , t_val = 1 , f_val =- 1 ) True Source code in dyce/lib.py def filter ( self , predicate : _BinaryPredicateT , other : OperandT , t_val : Optional [ int ] = None , f_val : Optional [ int ] = None , ) -> \"H\" : r \"\"\" Applies *predicate* to each face of the histogram paired with *other*. If the result is ``True``, *t_val* is returned, if set. Otherwise the face is returned. If the result is ``False``, *f_val* is returned, if set. Otherwise, the other face is returned. ```python >>> h6 = H(6) >>> h6.filter(operator.gt, 3) H({3: 3, 4: 1, 5: 1, 6: 1}) >>> h6.filter(operator.gt, 3, f_val=0) H({0: 3, 4: 1, 5: 1, 6: 1}) >>> h6.filter(operator.gt, 3, t_val=1, f_val=0) H({0: 3, 1: 3}) ``` Note that shorthands exist for many comparison operators: ```python >>> h6.gt(h6) == h6.filter(operator.gt, h6, t_val=1, f_val=0) True >>> h6.le(h6, t_val=1, f_val=-1) == h6.filter(operator.le, h6, t_val=1, f_val=-1) True ``` \"\"\" def _resolve ( a : int , b : int ): if predicate ( a , b ): return a if t_val is None else t_val else : return b if f_val is None else f_val return self . map ( _resolve , other )","title":"filter()"},{"location":"dyce/#dyce.lib.H.format","text":"Returns a formatted string representation of the histogram. If provided, fill_items supplies defaults for any missing faces. If width is greater than zero, a horizontal bar ASCII graph is printed using tick and sep (which are otherwise ignored if width is zero or less). >>> print ( H ( 6 ) . format ( width = 0 )) { avg : 3.50 , 1 : 16.67 % , 2 : 16.67 % , 3 : 16.67 % , 4 : 16.67 % , 5 : 16.67 % , 6 : 16.67 % } >>> print (( 2 @H ( 6 )) . format ( fill_items = { i : 0 for i in range ( 1 , 21 )}, width = 65 , tick = \"@\" )) avg | 7.00 1 | 0.00 % | 2 | 2.78 % |@ 3 | 5.56 % |@@ 4 | 8.33 % |@@@@ 5 | 11.11 % |@@@@@ 6 | 13.89 % |@@@@@@ 7 | 16.67 % |@@@@@@@@ 8 | 13.89 % |@@@@@@ 9 | 11.11 % |@@@@@ 10 | 8.33 % |@@@@ 11 | 5.56 % |@@ 12 | 2.78 % |@ 13 | 0.00 % | 14 | 0.00 % | 15 | 0.00 % | 16 | 0.00 % | 17 | 0.00 % | 18 | 0.00 % | 19 | 0.00 % | 20 | 0.00 % | Source code in dyce/lib.py def format ( self , fill_items : Optional [ Mapping [ int , int ]] = None , width : int = _ROW_WIDTH , tick : str = \"#\" , sep : str = os . linesep , ) -> str : r \"\"\" Returns a formatted string representation of the histogram. If provided, *fill_items* supplies defaults for any missing faces. If *width* is greater than zero, a horizontal bar ASCII graph is printed using *tick* and *sep* (which are otherwise ignored if *width* is zero or less). ```python >>> print(H(6).format(width=0)) {avg: 3.50, 1: 16.67%, 2: 16.67%, 3: 16.67%, 4: 16.67%, 5: 16.67%, 6: 16.67%} >>> print((2@H(6)).format(fill_items={i: 0 for i in range(1, 21)}, width=65, tick=\"@\")) avg | 7.00 1 | 0.00% | 2 | 2.78% |@ 3 | 5.56% |@@ 4 | 8.33% |@@@@ 5 | 11.11% |@@@@@ 6 | 13.89% |@@@@@@ 7 | 16.67% |@@@@@@@@ 8 | 13.89% |@@@@@@ 9 | 11.11% |@@@@@ 10 | 8.33% |@@@@ 11 | 5.56% |@@ 12 | 2.78% |@ 13 | 0.00% | 14 | 0.00% | 15 | 0.00% | 16 | 0.00% | 17 | 0.00% | 18 | 0.00% | 19 | 0.00% | 20 | 0.00% | ``` \"\"\" if width <= 0 : def parts (): yield \"avg: {:.2f} \" . format ( self . avg ()) for face , percentage in self . data ( relative = True , fill_items = fill_items ): yield \" {} : {:7.2%} \" . format ( face , percentage ) return \"{\" + \", \" . join ( parts ()) + \"}\" else : w = width - 15 def lines (): yield \"avg | {:7.2f} \" . format ( self . avg ()) for face , percentage in self . data ( relative = True , fill_items = fill_items ): ticks = int ( w * percentage ) yield \" {: 3} | {:7.2%} | {} \" . format ( face , percentage , tick * ticks ) return sep . join ( lines ())","title":"format()"},{"location":"dyce/#dyce.lib.H.ge","text":"Shorthand for self.filter(operator.ge, other, t_val, f_val) . >>> H ( 6 ) . ge ( 3 ) H ({ 0 : 2 , 1 : 4 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def ge ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.ge, other, t_val, f_val)``. ```python >>> H(6).ge(3) H({0: 2, 1: 4}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . ge , other , t_val , f_val )","title":"ge()"},{"location":"dyce/#dyce.lib.H.gt","text":"Shorthand for self.filter(operator.gt, other, t_val, f_val) . >>> H ( 6 ) . gt ( 3 ) H ({ 0 : 3 , 1 : 3 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def gt ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.gt, other, t_val, f_val)``. ```python >>> H(6).gt(3) H({0: 3, 1: 3}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . gt , other , t_val , f_val )","title":"gt()"},{"location":"dyce/#dyce.lib.H.items","text":"D.items() -> a set-like object providing a view on D's items Source code in dyce/lib.py def items ( self ): return self . _h . items ()","title":"items()"},{"location":"dyce/#dyce.lib.H.keys","text":"D.keys() -> a set-like object providing a view on D's keys Source code in dyce/lib.py def keys ( self ): return self . _h . keys ()","title":"keys()"},{"location":"dyce/#dyce.lib.H.le","text":"Shorthand for self.filter(operator.le, other, t_val, f_val) . >>> H ( 6 ) . le ( 3 ) H ({ 0 : 3 , 1 : 3 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def le ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.le, other, t_val, f_val)``. ```python >>> H(6).le(3) H({0: 3, 1: 3}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . le , other , t_val , f_val )","title":"le()"},{"location":"dyce/#dyce.lib.H.lowest_terms","text":"Computes and returns a histogram whose counts share a greatest common divisor of 1. >>> H (( - 1 , - 1 , 0 , 0 , 1 , 1 )) H ({ - 1 : 2 , 0 : 2 , 1 : 2 }) >>> _ . lowest_terms () H ({ - 1 : 1 , 0 : 1 , 1 : 1 }) >>> H (( 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 5 , 5 )) H ({ 2 : 2 , 3 : 4 , 4 : 4 , 5 : 2 }) >>> _ . lowest_terms () H ({ 2 : 1 , 3 : 2 , 4 : 2 , 5 : 1 }) Source code in dyce/lib.py def lowest_terms ( self ) -> \"H\" : r \"\"\" Computes and returns a histogram whose counts share a greatest common divisor of 1. ```python >>> H((-1, -1, 0, 0, 1, 1)) H({-1: 2, 0: 2, 1: 2}) >>> _.lowest_terms() H({-1: 1, 0: 1, 1: 1}) >>> H((2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5)) H({2: 2, 3: 4, 4: 4, 5: 2}) >>> _.lowest_terms() H({2: 1, 3: 2, 4: 2, 5: 1}) ``` \"\"\" counts_gcd = functools . reduce ( math . gcd , self . counts (), 0 ) return H ({ k : v // counts_gcd for k , v in self . items ()})","title":"lowest_terms()"},{"location":"dyce/#dyce.lib.H.lt","text":"Shorthand for self.filter(operator.lt, other, t_val, f_val) : >>> H ( 6 ) . lt ( 3 ) H ({ 0 : 4 , 1 : 2 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def lt ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.lt, other, t_val, f_val)``: ```python >>> H(6).lt(3) H({0: 4, 1: 2}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . lt , other , t_val , f_val )","title":"lt()"},{"location":"dyce/#dyce.lib.H.map","text":"Applies oper to each face of the histogram paired with other : >>> h6 = H ( 6 ) >>> h6 . map ( operator . add , h6 ) H ({ 2 : 1 , 3 : 2 , 4 : 3 , 5 : 4 , 6 : 5 , 7 : 6 , 8 : 5 , 9 : 4 , 10 : 3 , 11 : 2 , 12 : 1 }) >>> h6 . map ( operator . mul , - 1 ) H ({ - 6 : 1 , - 5 : 1 , - 4 : 1 , - 3 : 1 , - 2 : 1 , - 1 : 1 }) Note that shorthands exist for many arithmetic operators: >>> h6 * - 1 == h6 . map ( operator . mul , - 1 ) True >>> h6 + h6 == h6 . map ( operator . add , h6 ) True Source code in dyce/lib.py def map ( self , oper : _BinaryOperatorT , other : OperandT ) -> \"H\" : r \"\"\" Applies *oper* to each face of the histogram paired with *other*: ```python >>> h6 = H(6) >>> h6.map(operator.add, h6) H({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1}) >>> h6.map(operator.mul, -1) H({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1}) ``` Note that shorthands exist for many arithmetic operators: ```python >>> h6 * -1 == h6.map(operator.mul, -1) True >>> h6 + h6 == h6.map(operator.add, h6) True ``` \"\"\" if isinstance ( other , H . AbleT ): other = other . h () if isinstance ( other , int ): return H (( int ( oper ( face , other )), count ) for face , count in self . items ()) elif isinstance ( other , H ): return H ( ( int ( oper ( a , b )), self [ a ] * other [ b ]) for a , b in itertools . product ( self , other ) ) else : raise NotImplementedError","title":"map()"},{"location":"dyce/#dyce.lib.H.ne","text":"Shorthand for self.filter(operator.ne, other, t_val, f_val) . >>> H ( 6 ) . ne ( 3 ) H ({ 0 : 1 , 1 : 5 }) See the [ filter method][dyce.lib.H.filter]. Source code in dyce/lib.py def ne ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.filter(operator.ne, other, t_val, f_val)``. ```python >>> H(6).ne(3) H({0: 1, 1: 5}) ``` See the [``filter`` method][dyce.lib.H.filter]. \"\"\" return self . filter ( operator . ne , other , t_val , f_val )","title":"ne()"},{"location":"dyce/#dyce.lib.H.odd","text":">>> H (( - 4 , - 2 , 0 , 1 , 2 , 3 )) . odd () H ({ 0 : 4 , 1 : 2 }) Source code in dyce/lib.py def odd ( self , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 ) -> \"H\" : r \"\"\" ```python >>> H((-4, -2, 0, 1, 2, 3)).odd() H({0: 4, 1: 2}) ``` \"\"\" def is_odd ( a , _ ): return a % 2 != 0 return self . filter ( is_odd , 0 , t_val , f_val )","title":"odd()"},{"location":"dyce/#dyce.lib.H.roll","text":"Returns a (weighted) random face. Source code in dyce/lib.py def roll ( self ) -> int : r \"\"\" Returns a (weighted) random face. \"\"\" val = random . randrange ( 0 , sum ( self . counts ())) total = 0 for face , count in self . items (): total += count if val < total : return face assert False , \"val ( {} ) \u2265 total ( {} )\" . format ( val , total )","title":"roll()"},{"location":"dyce/#dyce.lib.H.substitute","text":"Calls expand on each face, recursively up to max_depth times. If expand returns non- None , coalesce is called on the face and the expanded histogram, and the returned histogram is folded into result. The default behavior for coalesce is to replace the face with the expanded histogram. This can be used to model complex rules. The following models re-rolling a face of 1 on the first roll: >>> def reroll_one ( h : H , face : int ) -> Optional [ H ]: ... return h if face == 1 else None >>> H ( 6 ) . substitute ( reroll_one ) H ({ 1 : 1 , 2 : 7 , 3 : 7 , 4 : 7 , 5 : 7 , 6 : 7 }) The following approximates an exploding three-sided die (i.e., if the greatest face comes up, the die is rolled again and its face is added to the total): >>> def reroll_greatest ( h : H , face : int ) -> Optional [ H ]: ... return h if face == max ( h ) else None >>> H ( 3 ) . substitute ( reroll_greatest , operator . add , max_depth = 4 ) H ({ 1 : 81 , 2 : 81 , 4 : 27 , 5 : 27 , 7 : 9 , 8 : 9 , 10 : 3 , 11 : 3 , 13 : 1 , 14 : 1 , 15 : 1 }) Consider the following rules: Start with a total of zero. Roll a six-sided die. Add the face to the total. If the face was a six, go to step 3. Otherwise stop. Roll a four-sided die. Add the face to the total. If the face was a four, go to step 2. Otherwise stop. What is the likelihood of an even final tally? This can be approximated by: >>> h4 , h6 = H ( 4 ), H ( 6 ) >>> def reroll_greatest_on_h4_h6 ( h : H , face : int ) -> Optional [ H ]: ... if face == max ( h ): ... if h == h6 : return h4 ... if h == h4 : return h6 ... return None >>> h = h6 . substitute ( reroll_greatest_on_h4_h6 , operator . add , max_depth = 6 ) >>> h_even = h . even () >>> print ( \" {:.3%} \" . format ( h_even . get ( 1 , 0 ) / sum ( h_even . counts ()))) 39.131 % Source code in dyce/lib.py def substitute ( self , expand : _ExpandT , coalesce : Optional [ _CoalesceT ] = None , max_depth : int = 1 , ) -> \"H\" : r \"\"\" Calls *expand* on each face, recursively up to *max_depth* times. If *expand* returns non-``None``, *coalesce* is called on the face and the expanded histogram, and the returned histogram is folded into result. The default behavior for *coalesce* is to replace the face with the expanded histogram. This can be used to model complex rules. The following models re-rolling a face of 1 on the first roll: ```python >>> def reroll_one(h: H, face: int) -> Optional[H]: ... return h if face == 1 else None >>> H(6).substitute(reroll_one) H({1: 1, 2: 7, 3: 7, 4: 7, 5: 7, 6: 7}) ``` The following approximates an exploding three-sided die (i.e., if the greatest face comes up, the die is rolled again and its face is added to the total): ```python >>> def reroll_greatest(h: H, face: int) -> Optional[H]: ... return h if face == max(h) else None >>> H(3).substitute(reroll_greatest, operator.add, max_depth=4) H({1: 81, 2: 81, 4: 27, 5: 27, 7: 9, 8: 9, 10: 3, 11: 3, 13: 1, 14: 1, 15: 1}) ``` Consider the following rules: 1. Start with a total of zero. 2. Roll a six-sided die. Add the face to the total. If the face was a six, go to step 3. Otherwise stop. 3. Roll a four-sided die. Add the face to the total. If the face was a four, go to step 2. Otherwise stop. What is the likelihood of an even final tally? This can be approximated by: ```python >>> h4, h6 = H(4), H(6) >>> def reroll_greatest_on_h4_h6(h: H, face: int) -> Optional[H]: ... if face == max(h): ... if h == h6: return h4 ... if h == h4: return h6 ... return None >>> h = h6.substitute(reroll_greatest_on_h4_h6, operator.add, max_depth=6) >>> h_even = h.even() >>> print(\"{:.3%}\".format(h_even.get(1, 0) / sum(h_even.counts()))) 39.131% ``` \"\"\" if coalesce is None : coalesce = _coalesce_replace def _substitute ( h : H , depth : int = 0 , ) -> H : assert coalesce is not None if depth == max_depth : return h expanded_items = [] # type: List[Tuple[int, int]] expanded_histograms = [] # type: List[H] for face , count in h . items (): expanded = expand ( h , face ) if expanded : expanded = _substitute ( expanded , depth + 1 ) expanded = H (( f , count * c ) for f , c in expanded . items ()) expanded = coalesce ( expanded , face ) expanded_histograms . append ( expanded ) else : expanded_items . append (( face , count )) count_multiplier = ( sum ( itertools . chain ( * ( ah . counts () for ah in expanded_histograms ))) or 1 ) expanded_counts = (( f , count_multiplier * c ) for f , c in expanded_items ) return H ( itertools . chain ( expanded_counts , * ( ah . items () for ah in expanded_histograms ) ) ) return _substitute ( self )","title":"substitute()"},{"location":"dyce/#dyce.lib.H.values","text":"D.values() -> an object providing a view on D's values Source code in dyce/lib.py def values ( self ): return self . _h . values ()","title":"values()"},{"location":"dyce/#dyce.lib.H.within","text":"Computes the difference between this histogram and other . -1 is represents where that difference is less than lo . 0 represents where that difference between lo and hi (inclusive). 1 represents where that difference is greater than hi . >>> ( 2 @H ( 6 )) . within ( 7 , 9 ) H ({ - 1 : 15 , 0 : 15 , 1 : 6 }) >>> print ( _ . format ( width = 65 )) avg | - 0.25 - 1 | 41.67 % | #################### 0 | 41.67 % | #################### 1 | 16.67 % | ######## >>> ( 3 @H ( 6 )) . within ( - 1 , 1 , 2 @H ( 8 )) # 3d6 w/in 1 of 2d8 H ({ - 1 : 3500 , 0 : 3412 , 1 : 6912 }) >>> print ( _ . format ( width = 65 )) avg | 0.25 - 1 | 25.32 % | ############ 0 | 24.68 % | ############ 1 | 50.00 % | ######################### Source code in dyce/lib.py def within ( self , lo : int , hi : int , other : OperandT = 0 ) -> \"H\" : r \"\"\" Computes the difference between this histogram and *other*. -1 is represents where that difference is less than *lo*. 0 represents where that difference between *lo* and *hi* (inclusive). 1 represents where that difference is greater than *hi*. ```python >>> (2@H(6)).within(7, 9) H({-1: 15, 0: 15, 1: 6}) >>> print(_.format(width=65)) avg | -0.25 -1 | 41.67% |#################### 0 | 41.67% |#################### 1 | 16.67% |######## >>> (3@H(6)).within(-1, 1, 2@H(8)) # 3d6 w/in 1 of 2d8 H({-1: 3500, 0: 3412, 1: 6912}) >>> print(_.format(width=65)) avg | 0.25 -1 | 25.32% |############ 0 | 24.68% |############ 1 | 50.00% |######################### ``` \"\"\" return self . map ( _within ( lo , hi ), other )","title":"within()"},{"location":"dyce/#dyce.lib.D","text":"An immutable container of convenience for a vector of zero or more [ H ][dyce.lib.H] objects supporting group operations. The vector can be flattened to a single histogram, either explicitly via the [ h method][dyce.lib.D.h], or by using binary arithmetic operations. Unary operators and the @ operator result in new D objects. If any of the initializer \u2019s args parameter is an int , it is passed to the constructor for H . >>> d6 = D ( 6 ) # shorthand for D(H(6)) >>> d6 D ( 6 ) >>> - d6 D ( - 6 ) >>> D ( d6 , d6 ) # 2d6 D ( 6 , 6 ) >>> 2 @d6 # also 2d6 D ( 6 , 6 ) >>> 2 @ ( 2 @d6 ) == 4 @d6 True >>> D ( 4 , D ( 6 , D ( 8 , D ( 10 , D ( 12 , D ( 20 )))))) D ( 4 , 6 , 8 , 10 , 12 , 20 ) >>> sum ( _ . roll ()) in _ . h () True Arithmetic operators involving an int or another D object produces an [ H object][dyce.lib.H]: >>> d6 + d6 H ({ 2 : 1 , 3 : 2 , 4 : 3 , 5 : 4 , 6 : 5 , 7 : 6 , 8 : 5 , 9 : 4 , 10 : 3 , 11 : 2 , 12 : 1 }) >>> 2 * D ( 8 ) - 1 H ({ 1 : 1 , 3 : 1 , 5 : 1 , 7 : 1 , 9 : 1 , 11 : 1 , 13 : 1 , 15 : 1 }) Comparisons between D and [ H ][dyce.lib.H] objects still work: >>> 3 @d6 == H ( 6 ) + H ( 6 ) + H ( 6 ) True For D objects containing more than one [ H object][dyce.lib.H], slicing grabs a subset of faces from least to greatest. Modeling the sum of the greatest two faces of three six-sided dice ( 3d6 ) can be expressed as: >>> ( 3 @d6 )[ - 2 :] H ({ 2 : 1 , 3 : 3 , 4 : 7 , 5 : 12 , 6 : 19 , 7 : 27 , 8 : 34 , 9 : 36 , 10 : 34 , 11 : 27 , 12 : 16 }) >>> print ( _ . format ( width = 65 )) avg | 8.46 2 | 0.46 % | 3 | 1.39 % | 4 | 3.24 % | # 5 | 5.56 % | ## 6 | 8.80 % | #### 7 | 12.50 % | ###### 8 | 15.74 % | ####### 9 | 16.67 % | ######## 10 | 15.74 % | ####### 11 | 12.50 % | ###### 12 | 7.41 % | ### Arbitrary iterables can be used for more flexible selections: >>> d = 6 @D ( 6 ) >>> every_other_d6 = d [:: - 2 ] >>> every_other_d6 H ({ 3 : 1 , 4 : 21 , 5 : 86 , ... , 16 : 1106 , 17 : 395 , 18 : 31 }) >>> d [ 5 , 3 , 1 ] == every_other_d6 True >>> d [ range ( 1 , 6 , 2 )] == every_other_d6 True >>> d [( i for i in range ( 0 , 6 ) if i % 2 == 1 )] == every_other_d6 True >>> d [{ 1 , 3 , 5 }] == every_other_d6 True Modeling the sum of the greatest two and least two faces of ten four-sided dice ( 10d4 ) can be expressed as: >>> ( 10 @D ( 4 ))[: 2 , - 2 :] H ({ 4 : 1 , 5 : 10 , 6 : 1012 , 7 : 5030 , 8 : 51973 , 9 : 168760 , 10 : 595004 , 11 : 168760 , 12 : 51973 , 13 : 5030 , 14 : 1012 , 15 : 10 , 16 : 1 }) >>> print ( _ . format ( width = 65 )) avg | 10.00 4 | 0.00 % | 5 | 0.00 % | 6 | 0.10 % | 7 | 0.48 % | 8 | 4.96 % | ## 9 | 16.09 % | ######## 10 | 56.74 % | ############################ 11 | 16.09 % | ######## 12 | 4.96 % | ## 13 | 0.48 % | 14 | 0.10 % | 15 | 0.00 % | 16 | 0.00 % |","title":"D"},{"location":"dyce/#dyce.lib.D.__init__","text":"Initializer. Source code in dyce/lib.py def __init__ ( self , * args : Union [ int , \"D\" , \"H\" ]) -> None : r \"Initializer.\" super () . __init__ () def _gen_hs (): for a in args : if isinstance ( a , int ): yield H ( a ) elif isinstance ( a , H ): yield a elif isinstance ( a , D ): for h in a . _hs : # pylint: disable=protected-access yield h else : raise TypeError ( \"type {} incompatible initializer for {} \" . format ( type ( a ), type ( self ) ) ) hs = list ( h for h in _gen_hs () if h ) hs . sort ( key = lambda h : tuple ( h . items ())) self . _hs = tuple ( hs )","title":"__init__()"},{"location":"dyce/#dyce.lib.D.eq","text":"Shorthand for self.h().eq(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.eq ][dyce.lib.H.eq]. Source code in dyce/lib.py def eq ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().eq(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.eq``][dyce.lib.H.eq]. \"\"\" return self . h () . eq ( other , t_val , f_val )","title":"eq()"},{"location":"dyce/#dyce.lib.D.even","text":"Shorthand for self.h().even(t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.even ][dyce.lib.H.even]. Source code in dyce/lib.py def even ( self , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 ) -> \"H\" : r \"\"\" Shorthand for ``self.h().even(t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.even``][dyce.lib.H.even]. \"\"\" return self . h () . even ( t_val , f_val )","title":"even()"},{"location":"dyce/#dyce.lib.D.ge","text":"Shorthand for self.h().ge(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.ge ][dyce.lib.H.ge]. Source code in dyce/lib.py def ge ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().ge(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.ge``][dyce.lib.H.ge]. \"\"\" return self . h () . ge ( other , t_val , f_val )","title":"ge()"},{"location":"dyce/#dyce.lib.D.gt","text":"Shorthand for self.h().gt(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.gt ][dyce.lib.H.gt]. Source code in dyce/lib.py def gt ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().gt(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.gt``][dyce.lib.H.gt]. \"\"\" return self . h () . gt ( other , t_val , f_val )","title":"gt()"},{"location":"dyce/#dyce.lib.D.h","text":"Combines contained histograms: >>> ( 2 @D ( 6 )) . h () H ({ 2 : 1 , 3 : 2 , 4 : 3 , 5 : 4 , 6 : 5 , 7 : 6 , 8 : 5 , 9 : 4 , 10 : 3 , 11 : 2 , 12 : 1 }) If the optional index parameter is provided, extract the contained histogram at that index: >>> D ( 4 , 6 , 8 ) . h ( 0 ) H ( 4 ) Note that containers are opinionated about histogram ordering: >>> D ( 8 , 6 , 4 ) . h ( 0 ) == D ( 8 , 4 , 6 ) . h ( 0 ) == H ( 4 ) True Source code in dyce/lib.py def h ( self , index : Optional [ int ] = None ) -> \"H\" : r \"\"\" Combines contained histograms: ```python >>> (2@D(6)).h() H({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1}) ``` If the optional *index* parameter is provided, extract the contained histogram at that index: ```python >>> D(4, 6, 8).h(0) H(4) ``` Note that containers are opinionated about histogram ordering: ```python >>> D(8, 6, 4).h(0) == D(8, 4, 6).h(0) == H(4) True ``` \"\"\" if index is not None : return self . _hs [ index ] if self . _hs : hs_sum = sum ( self . _hs ) else : hs_sum = H (()) return cast ( H , hs_sum )","title":"h()"},{"location":"dyce/#dyce.lib.D.le","text":"Shorthand for self.h().le(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.le ][dyce.lib.H.le]. Source code in dyce/lib.py def le ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().le(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.le``][dyce.lib.H.le]. \"\"\" return self . h () . le ( other , t_val , f_val )","title":"le()"},{"location":"dyce/#dyce.lib.D.lt","text":"Shorthand for self.h().lt(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.lt ][dyce.lib.H.lt]. Source code in dyce/lib.py def lt ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().lt(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.lt``][dyce.lib.H.lt]. \"\"\" return self . h () . lt ( other , t_val , f_val )","title":"lt()"},{"location":"dyce/#dyce.lib.D.ne","text":"Shorthand for self.h().ne(other, t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.ne ][dyce.lib.H.ne]. Source code in dyce/lib.py def ne ( self , other : OperandT , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 , ) -> \"H\" : r \"\"\" Shorthand for ``self.h().ne(other, t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.ne``][dyce.lib.H.ne]. \"\"\" return self . h () . ne ( other , t_val , f_val )","title":"ne()"},{"location":"dyce/#dyce.lib.D.odd","text":"Shorthand for self.h().odd(t_val, f_val) . See the [ h method][dyce.lib.D.h] and [ H.odd ][dyce.lib.H.odd]. Source code in dyce/lib.py def odd ( self , t_val : Optional [ int ] = 1 , f_val : Optional [ int ] = 0 ) -> \"H\" : r \"\"\" Shorthand for ``self.h().odd(t_val, f_val)``. See the [``h`` method][dyce.lib.D.h] and [``H.odd``][dyce.lib.H.odd]. \"\"\" return self . h () . odd ( t_val , f_val )","title":"odd()"},{"location":"dyce/#dyce.lib.D.roll","text":"Returns (weighted) random faces from contained histograms. Source code in dyce/lib.py def roll ( self ) -> Tuple [ int , ... ]: r \"\"\" Returns (weighted) random faces from contained histograms. \"\"\" return tuple ( h . roll () for h in self . _hs )","title":"roll()"},{"location":"dyce/#dyce.lib.D.substitute","text":"Shorthand for self.h().substitute(expand, coalesce, max_depth) . See the [ h method][dyce.lib.D.h] and [ H.substitute ][dyce.lib.H.substitute]. Source code in dyce/lib.py def substitute ( self , expand : _ExpandT , coalesce : Optional [ _CoalesceT ] = None , max_depth : int = 1 , ) -> H : r \"\"\" Shorthand for ``self.h().substitute(expand, coalesce, max_depth)``. See the [``h`` method][dyce.lib.D.h] and [``H.substitute``][dyce.lib.H.substitute]. \"\"\" return self . h () . substitute ( expand , coalesce , max_depth )","title":"substitute()"},{"location":"dyce/#dyce.lib.D.within","text":"Shorthand for self.h().within(lo, hi, other) . See the [ h method][dyce.lib.D.h] and [ H.within ][dyce.lib.H.within]. Source code in dyce/lib.py def within ( self , lo : int , hi : int , other : OperandT = 0 ) -> \"H\" : r \"\"\" Shorthand for ``self.h().within(lo, hi, other)``. See the [``h`` method][dyce.lib.D.h] and [``H.within``][dyce.lib.H.within]. \"\"\" return self . h () . within ( lo , hi , other )","title":"within()"},{"location":"dyce.plt/","text":"dyce.plt package reference Experimental This package is an attempt to explore conveniences for integration with Matplotlib . It is an explicit departure from RFC 1925, \u00a7 2.2 and should be considered experimental. Be warned that future release may introduce incompatibilities or remove this package altogether. Suggestions and contributions are welcome. display_burst ( ax , h_inner , outer = None , desc = None , graph_color = 'RdYlGn' , text_color = 'black' , alpha = 0.5 ) Source code in dyce/plt.py def display_burst ( ax : AxesT , h_inner : H , outer : Optional [ Iterable [ LabelT ]] = None , desc : Optional [ str ] = None , graph_color : str = \"RdYlGn\" , text_color : str = \"black\" , alpha : float = 0.5 , ) -> None : assert matplotlib if outer is None : outer = ( ( \" {:.2%} \" . format ( v ) if v >= _HIDE_LIM else \"\" , v ) for _ , v in h_inner . data ( relative = True ) ) outer_labels , outer_values = list ( zip ( * outer )) if desc : ax . set_title ( desc , fontdict = { \"fontweight\" : \"bold\" }, pad = 24.0 ) ax . pie ( outer_values , labels = outer_labels , radius = 1.2 , labeldistance = 1.2 , startangle = 90 , colors = graph_colors ( graph_color , outer_values , alpha ), wedgeprops = dict ( width = 0.8 , edgecolor = text_color ), ) ax . pie ( h_inner . values (), labels = h_inner , radius = 1 , labeldistance = 0.8 , startangle = 90 , colors = graph_colors ( graph_color , h_inner , alpha ), textprops = dict ( color = text_color ), wedgeprops = dict ( width = 0.4 , edgecolor = text_color ), ) ax . set ( aspect = \"equal\" ) labels_cumulative ( h ) Source code in dyce/plt.py def labels_cumulative ( h : H , ) -> Iterator [ LabelT ]: le_total , ge_total = 0.0 , 1.0 for face , percentage in h . data ( relative = True ): le_total += percentage if percentage >= _HIDE_LIM : label = \" {} {:.2%} ; \u2265 {:.2%} ; \u2264 {:.2%} \" . format ( face , percentage , le_total , ge_total ) else : label = \"\" ge_total -= percentage yield ( label , percentage ) plot_burst ( h_inner , outer = None , desc = None , graph_color = 'RdYlGn_r' , text_color = 'black' , alpha = 0.5 ) Source code in dyce/plt.py def plot_burst ( h_inner : H , outer : Optional [ Iterable [ LabelT ]] = None , desc : Optional [ str ] = None , graph_color : str = DEFAULT_GRAPH_COLOR , text_color : str = DEFAULT_TEXT_COLOR , alpha : float = DEFAULT_GRAPH_ALPHA , ) -> Tuple [ FigureT , AxesT ]: assert matplotlib fig , ax = matplotlib . pyplot . subplots () display_burst ( ax , h_inner , outer , desc , graph_color , text_color , alpha ) matplotlib . pyplot . tight_layout () return fig , ax","title":"<tt>dyce.plt</tt>"},{"location":"dyce.plt/#dyceplt-package-reference","text":"Experimental This package is an attempt to explore conveniences for integration with Matplotlib . It is an explicit departure from RFC 1925, \u00a7 2.2 and should be considered experimental. Be warned that future release may introduce incompatibilities or remove this package altogether. Suggestions and contributions are welcome.","title":"dyce.plt package reference"},{"location":"dyce.plt/#dyce.plt","text":"","title":"dyce.plt"},{"location":"dyce.plt/#dyce.plt.display_burst","text":"Source code in dyce/plt.py def display_burst ( ax : AxesT , h_inner : H , outer : Optional [ Iterable [ LabelT ]] = None , desc : Optional [ str ] = None , graph_color : str = \"RdYlGn\" , text_color : str = \"black\" , alpha : float = 0.5 , ) -> None : assert matplotlib if outer is None : outer = ( ( \" {:.2%} \" . format ( v ) if v >= _HIDE_LIM else \"\" , v ) for _ , v in h_inner . data ( relative = True ) ) outer_labels , outer_values = list ( zip ( * outer )) if desc : ax . set_title ( desc , fontdict = { \"fontweight\" : \"bold\" }, pad = 24.0 ) ax . pie ( outer_values , labels = outer_labels , radius = 1.2 , labeldistance = 1.2 , startangle = 90 , colors = graph_colors ( graph_color , outer_values , alpha ), wedgeprops = dict ( width = 0.8 , edgecolor = text_color ), ) ax . pie ( h_inner . values (), labels = h_inner , radius = 1 , labeldistance = 0.8 , startangle = 90 , colors = graph_colors ( graph_color , h_inner , alpha ), textprops = dict ( color = text_color ), wedgeprops = dict ( width = 0.4 , edgecolor = text_color ), ) ax . set ( aspect = \"equal\" )","title":"display_burst()"},{"location":"dyce.plt/#dyce.plt.labels_cumulative","text":"Source code in dyce/plt.py def labels_cumulative ( h : H , ) -> Iterator [ LabelT ]: le_total , ge_total = 0.0 , 1.0 for face , percentage in h . data ( relative = True ): le_total += percentage if percentage >= _HIDE_LIM : label = \" {} {:.2%} ; \u2265 {:.2%} ; \u2264 {:.2%} \" . format ( face , percentage , le_total , ge_total ) else : label = \"\" ge_total -= percentage yield ( label , percentage )","title":"labels_cumulative()"},{"location":"dyce.plt/#dyce.plt.plot_burst","text":"Source code in dyce/plt.py def plot_burst ( h_inner : H , outer : Optional [ Iterable [ LabelT ]] = None , desc : Optional [ str ] = None , graph_color : str = DEFAULT_GRAPH_COLOR , text_color : str = DEFAULT_TEXT_COLOR , alpha : float = DEFAULT_GRAPH_ALPHA , ) -> Tuple [ FigureT , AxesT ]: assert matplotlib fig , ax = matplotlib . pyplot . subplots () display_burst ( ax , h_inner , outer , desc , graph_color , text_color , alpha ) matplotlib . pyplot . tight_layout () return fig , ax","title":"plot_burst()"},{"location":"license/","text":"License & Credits The MIT License (MIT) Copyright \u00a9 2015-2021 Matt Bogosian ( @posita ). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Contributors The following individuals or entities have contributed to this software: Matt Bogosian ; GitHub - @posita By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.","title":"License"},{"location":"license/#license-credits","text":"","title":"License &amp; Credits"},{"location":"license/#the-mit-license-mit","text":"Copyright \u00a9 2015-2021 Matt Bogosian ( @posita ). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"license/#contributors","text":"The following individuals or entities have contributed to this software: Matt Bogosian ; GitHub - @posita By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.","title":"Contributors"}]}