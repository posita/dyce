{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Copyright and other protections apply. Please see the accompanying <code>LICENSE</code> file for rights and restrictions governing use of this software. All rights not expressly waived or licensed are reserved. If that file is missing or appears to be modified from its original, then please contact the author before viewing or using this software in any capacity.</p> <p> </p> <p>Now you\u2019re playing with \u2026</p> <p></p>"},{"location":"#dyce-simple-python-tools-for-exploring-dice-outcomes-and-other-finite-discrete-probabilities","title":"<code>dyce</code> \u2013 simple Python tools for exploring dice outcomes and other finite discrete probabilities","text":"<p>\ud83d\udca5 Now 100% Bear-ified\u2122! \ud83d\udc4c\ud83c\udffe\ud83d\udc3b (Details below.)</p> <p><code>dyce</code> is a pure-Python library for modeling arbitrarily complex dice mechanics. It strives for compact expression and efficient computation, especially for the most common cases. Its primary applications are:</p> <ol> <li>Computing finite discrete probability distributions for:<ul> <li>Game designers who want to understand or experiment with various dice mechanics and interactions; and</li> <li>Design tool developers.</li> </ul> </li> <li>Generating transparent, weighted random rolls for:<ul> <li>Game environment developers who want flexible dice mechanic resolution in, e.g., virtual tabletops (VTTs), chat servers, etc.</li> </ul> </li> </ol> <p>Beyond those audiences, <code>dyce</code> may be useful to anyone interested in exploring finite discrete probabilities but not in developing all the low-level math bits from scratch.</p> <p><code>dyce</code> is designed to be immediately and broadly useful with minimal additional investment beyond basic knowledge of Python. While not as compact as a dedicated grammar, <code>dyce</code>\u2019s Python-based primitives are quite sufficient, and often more expressive. Those familiar with various game notations should be able to adapt quickly. If you\u2019re looking at something on which to build your own grammar or interface, <code>dyce</code> can serve you well.</p> <p><code>dyce</code> should be able to replicate or replace most other dice probability modeling tools. It strives to be fully documented and relies heavily on examples to develop understanding.</p> <p><code>dyce</code> is licensed under the MIT License. See the accompanying <code>LICENSE</code> file for details. Non-experimental features should be considered stable (but an unquenchable thirst to increase performance remains). See the release notes for a summary of version-to-version changes. Source code is available on GitHub.</p> <p>If you find it lacking in any way, please don\u2019t hesitate to bring it to my attention.</p>"},{"location":"#donors","title":"Donors","text":"<p>When one worries that the flickering light of humanity may be snuffed out at any moment, when one\u2019s heart breaks at the perverse celebration of judgment, vengeance, and death and the demonizing of empathy, compassion, and love, sometimes all that is needed is the kindness of a single stranger to reinvigorate one\u2019s faith that\u2014while all may not be right in the world\u2014there is hope for us human beings.</p> <ul> <li>David Eyk not only inspires others to explore creative writing, but has graciously ceded his PyPI project dedicated to his own prior work under a similar name.   As such, <code>dyce</code> is now available as <code>dycelib</code> <code>dyce</code>!   Thanks to his generosity, millions dozens of future <code>dyce</code> users will be spared from typing superfluous characters.   On behalf of myself, those souls, and our keyboards, we salute you, Mr. Eyk. \ud83d\ude47\u200d\u2642\ufe0f</li> </ul>"},{"location":"#a-taste","title":"A taste","text":"<p><code>dyce</code> provides several core primitives. <code>H</code> objects represent histograms for modeling finite discrete outcomes, like individual dice. <code>P</code> objects represent pools (ordered sequences) of histograms. <code>R</code> objects (covered elsewhere) represent nodes in arbitrary roller trees useful for translating from proprietary grammars and generating weighted random rolls that \u201cshow their work\u201d without the overhead of enumeration. All support a variety of operations.</p> <pre><code>&gt;&gt;&gt; from dyce import H\n&gt;&gt;&gt; d6 = H(6)  # a standard six-sided die\n&gt;&gt;&gt; 2@d6 * 3 - 4  # 2d6 \u00d7 3 - 4\nH({2: 1, 5: 2, 8: 3, 11: 4, 14: 5, 17: 6, 20: 5, 23: 4, 26: 3, 29: 2, 32: 1})\n&gt;&gt;&gt; d6.lt(d6)  # how often a first six-sided die shows a face less than a second\nH({False: 21, True: 15})\n&gt;&gt;&gt; abs(d6 - d6)  # subtract the least of two six-sided dice from the greatest\nH({0: 6, 1: 10, 2: 8, 3: 6, 4: 4, 5: 2})\n</code></pre> <pre><code>&gt;&gt;&gt; from dyce import P\n&gt;&gt;&gt; p_2d6 = 2@P(d6)  # a pool of two six-sided dice\n&gt;&gt;&gt; p_2d6.h()  # pools can be collapsed into histograms\nH({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n&gt;&gt;&gt; p_2d6 == 2@d6  # pools and histograms are comparable\nTrue\n</code></pre> <p>By providing an optional argument to the <code>P.h</code> method, one can \u201ctake\u201d individual dice from pools, ordered least to greatest. (The <code>H.format</code> method provides rudimentary visualization for convenience.)</p> <pre><code>&gt;&gt;&gt; p_2d6.h(0)  # take the lowest die of 2d6\nH({1: 11, 2: 9, 3: 7, 4: 5, 5: 3, 6: 1})\n&gt;&gt;&gt; print(p_2d6.h(0).format())\navg |    2.53\nstd |    1.40\nvar |    1.97\n  1 |  30.56% |###############\n  2 |  25.00% |############\n  3 |  19.44% |#########\n  4 |  13.89% |######\n  5 |   8.33% |####\n  6 |   2.78% |#\n</code></pre> <pre><code>&gt;&gt;&gt; p_2d6.h(-1)  # take the highest die of 2d6\nH({1: 1, 2: 3, 3: 5, 4: 7, 5: 9, 6: 11})\n&gt;&gt;&gt; print(p_2d6.h(-1).format())\navg |    4.47\nstd |    1.40\nvar |    1.97\n  1 |   2.78% |#\n  2 |   8.33% |####\n  3 |  13.89% |######\n  4 |  19.44% |#########\n  5 |  25.00% |############\n  6 |  30.56% |###############\n</code></pre> <p><code>H</code> objects provide a <code>distribution</code> method and a <code>distribution_xy</code> method to ease integration with plotting packages <code>anydyce</code>, for example, makes use of these to integrate with <code>matplotlib</code>.</p> <p> </p>    Source: <code>plot_2d6_lo_hi.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom anydyce.viz import plot_bar\n\nfrom dyce import H, P\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n\n    p_2d6 = 2 @ P(H(6))\n    p_2d6_lowest = p_2d6.h(0)\n    p_2d6_highest = p_2d6.h(-1)\n\n    ax = matplotlib.pyplot.axes()\n    text_color = \"white\" if style == \"dark\" else \"black\"\n    ax.tick_params(axis=\"x\", colors=text_color)\n    ax.tick_params(axis=\"y\", colors=text_color)\n    plot_bar(ax, [(\"Lowest\", p_2d6_lowest), (\"Highest\", p_2d6_highest)])\n    ax.legend()\n    ax.set_title(\"Taking the lowest or highest die of 2d6\", color=text_color)\n</code></pre> <p><code>H</code> objects and <code>P</code> objects can generate random rolls.</p> <pre><code>&gt;&gt;&gt; d6 = H(6)\n&gt;&gt;&gt; d6.roll()  # doctest: +SKIP\n4\n</code></pre> <pre><code>&gt;&gt;&gt; d10 = H(10) - 1\n&gt;&gt;&gt; p_6d10 = 6@P(d10)\n&gt;&gt;&gt; p_6d10.roll()  # doctest: +SKIP\n(0, 1, 2, 3, 5, 7)\n</code></pre> <p>See the tutorials on counting and rolling, as well as the API guide for much more thorough treatments, including detailed examples.</p>"},{"location":"#design-philosophy","title":"Design philosophy","text":"<p><code>dyce</code> is fairly low-level by design, prioritizing ergonomics and composability. It explicitly avoids stochastic simulation, but instead determines outcomes through enumeration and discrete computation. That\u2019s a highfalutin way of saying it doesn\u2019t guess. It knows, even if knowing is harder or more limiting. Which, if we possess a modicum of humility, it often is.</p> <p>Quote</p> <p>\u201cIt\u2019s frightening to think that you might not know something, but more frightening to think that, by and large, the world is run by people who have faith that they know exactly what is going on.\u201d</p> <p>\u2014Amos Tversky</p> <p>Because <code>dyce</code> exposes Python primitives rather than defining a dedicated grammar and interpreter, one can more easily integrate it with other tools.1 It can be installed and run anywhere2, and modified as desired. On its own, <code>dyce</code> is completely adequate for casual tinkering. However, it really shines when used in larger contexts such as with Matplotlib or Jupyter or embedded in a special-purpose application.</p> <p>In an intentional departure from RFC 1925, \u00a7 2.2, <code>dyce</code> includes some conveniences, such as minor computation optimizations (e.g., the <code>H.lowest_terms</code> method, various other shorthands, etc.) and formatting conveniences (e.g., the <code>H.distribution</code>, <code>H.distribution_xy</code>, and <code>H.format</code> methods).</p>"},{"location":"#comparison-to-alternatives","title":"Comparison to alternatives","text":"<p>The following is a best-effort3 summary of the differences between various available tools in this space. Consider exploring the applications and translations for added color.</p> <code>dyce</code>Bogosian et al. <code>icepool</code>Albert Julius Liu <code>dice_roll.py</code>Karonen python-diceRobson et al. AnyDiceFlick d20Curse LLC DnDice\u201cLordSembor\u201d diceClements et al. dice-notationGarrido Latest release 2022 2022 N/A 2021 Unknown 2021 2016 2021 2022 Actively maintained and documented \u2705 \u2705 \u26a0\ufe0f4 \u2705 \u2705 \u2705 \u274c \u2705 \u274c Combinatorics optimizations \u2705 \u2705 \u2705 \u274c \u274c \u274c \u274c \u274c \u274c Suitable as a dependency in other projects \u2705 \u2705 \u26a0\ufe0f5 \u2705 \u274c \u2705 \u26a0\ufe0f5 \u2705 \u274c Discrete outcome enumeration \u2705 \u2705 \u2705 \u2705 \u2705 \u274c \u2705 \u274c \u274c Arbitrary expressions \u2705 \u2705 \u26a0\ufe0f6 \u2705 \u2705 \u2705 \u26a0\ufe0f7 \u274c \u274c Arbitrary dice definitions \u2705 \u2705 \u2705 \u2705 \u2705 \u274c \u274c \u274c \u274c Integrates with other tools \u2705 \u2705 \u2705 \u26a0\ufe0f8 \u274c \u26a0\ufe0f8 \u2705 \u26a0\ufe0f8 \u26a0\ufe0f8 Open source (can inspect) \u2705 \u2705 \u2705 \u2705 \u274c \u2705 \u2705 \u2705 \u2705 Permissive licensing (can use and extend) \u2705 \u2705 \u2705 \u2705 N/A \u2705 \u2705 \u2705 \u2705"},{"location":"#license","title":"License","text":"<p><code>dyce</code> is licensed under the MIT License. See the included <code>LICENSE</code> file for details. Source code is available on GitHub.</p>"},{"location":"#installation","title":"Installation","text":"<p>Installation can be performed via PyPI.</p> <pre><code>% pip install dyce\n...\n</code></pre> <p>Alternately, you can download the source and install manually.</p> <pre><code>% git clone https://github.com/posita/dyce.git\n...\n% cd dyce\n% python -m pip install .  # -or- python -c 'from setuptools import setup ; setup()' install .\n...\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<p><code>dyce</code> requires a relatively modern version of Python:</p> <ul> <li>CPython (3.9+)</li> <li>PyPy (CPython 3.9+ compatible)</li> </ul> <p>It has the following runtime dependencies:</p> <ul> <li> <p><code>numerary</code> for proper best-effort hacking around deficiencies in static and runtime numeric type-checking   </p> </li> <li> <p><code>beartype</code> for yummy runtime type-checking goodness (a dependency of <code>numerary</code>)   </p> </li> </ul> <p><code>dyce</code> will opportunistically use the following, if available at runtime:</p> <ul> <li><code>numpy</code> to supply <code>dyce</code> with an alternate random number generator implementation</li> </ul> <p>If you use <code>beartype</code> for type checking your code, but don\u2019t want <code>dyce</code> or <code>numerary</code> to use it internally, disable it with <code>numerary</code>\u2019s <code>NUMERARY_BEARTYPE</code> environment variable.</p> <p>See the hacking quick-start for additional development and testing dependencies.</p>"},{"location":"#customers","title":"Customers","text":"<ul> <li>This could be you! \ud83d\udc4b</li> </ul> <p>Do you have a project that uses <code>dyce</code>? Let me know, and I\u2019ll promote it here!</p> <p>And don\u2019t forget to do your part in perpetuating gratuitous badge-ification!</p> <pre><code>&lt;!-- Markdown --&gt;\nAs of version 1.1, HighRollin is\n[![dyce-powered](https://raw.githubusercontent.com/posita/dyce/latest/docs/dyce-powered.svg)][dyce-powered]!\n[dyce-powered]: https://posita.github.io/dyce/ \"dyce-powered!\"\n</code></pre> <pre><code>..\n    reStructuredText - see https://docutils.sourceforge.io/docs/ref/rst/directives.html#image\n\nAs of version 1.1, HighRollin is |dyce-powered|!\n\n.. |dyce-powered| image:: https://raw.githubusercontent.com/posita/dyce/latest/docs/dyce-powered.svg\n   :align: top\n   :target: https://posita.github.io/dyce/\n   :alt: dyce-powered\n</code></pre> <pre><code>&lt;!-- HTML --&gt;\nAs of version 1.1, HighRollin is &lt;a href=\"https://posita.github.io/dyce/\"&gt;&lt;img\n  src=\"https://raw.githubusercontent.com/posita/dyce/latest/docs/dyce-powered.svg\"\n  alt=\"dyce-powered\"\n  style=\"vertical-align: middle;\"&gt;&lt;/a&gt;!\n</code></pre> <ol> <li> <p>You won\u2019t find any lexers, parsers, or tokenizers in <code>dyce</code>\u2019s core, other than straight-up Python. That being said, you can always \u201croll\u201d your own (see what we did there?) and lean on <code>dyce</code> underneath. It doesn\u2019t mind. It actually kind of likes it.\u00a0\u21a9</p> </li> <li> <p>Okay, maybe not literally anywhere, but you\u2019d be surprised. Void where prohibited. Certain restrictions apply. Do not taunt Happy Fun Ball.\u00a0\u21a9</p> </li> <li> <p>I have attempted to ensure the above is reasonably accurate, but please consider contributing an issue if you observe discrepancies.\u00a0\u21a9</p> </li> <li> <p>Sparsely documented. The author has expressed a desire to release a more polished version.\u00a0\u21a9</p> </li> <li> <p>Source can be downloaded and incorporated directly, but there is no packaging, versioning, or dependency tracking.\u00a0\u21a9\u21a9</p> </li> <li> <p>Callers must perform their own arithmetic and characterize results in terms of a lightweight die primitive, which may be less accessible to the novice. That being said, the library is remarkably powerful, given its size.\u00a0\u21a9</p> </li> <li> <p>Limited arithmetic operations are available. The library also provides game-specific functions.\u00a0\u21a9</p> </li> <li> <p>Results only. Input is limited to specialized grammar.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"contrib/","title":"Contributing","text":""},{"location":"contrib/#contributing-to-dyce","title":"Contributing to <code>dyce</code>","text":"<p>There are many ways you can contribute. You have only but to try.</p>"},{"location":"contrib/#starting-discussions-and-filing-issues","title":"Starting discussions and filing issues","text":"<p>You can file new issues as you find them. Please try to avoid duplicating issues. \u201cWriting Effective Bug Reports\u201d by Elisabeth Hendrickson (PDF) may be helpful.</p> <p>For more free-flow discussions (beefs, rants, ideas, recipes, etc.), consider starting or joining a discussion.</p>"},{"location":"contrib/#hacking-quick-start","title":"Hacking quick-start","text":"<p>An easy way to bootstrap an isolated development environment is:</p> <pre><code>% git clone --recurse-submodules https://github.com/posita/dyce.git\n\u2026\n% cd dyce\n% /path/to/python -m venv .venv\n\u2026\n% . .venv/bin/activate\n% pip install --upgrade --editable '.[dev]'\n\u2026\n% python -m pre_commit install\n\u2026\n</code></pre> <p>Substitute your preferred virtual environment process for <code>venv</code>. The <code>[dev]</code> variant includes additional dependencies necessary for development and testing. See the <code>[options.extras_require]</code> section in <code>setup.cfg</code>.</p> <p>Unit tests are run with pytest via Tox.</p> <pre><code>% cd \u2026/path/to/dyce\n% . .venv/bin/activate\n% tox [TOX_ARGS... [-- PYTEST_ARGS...]]\n\u2026\n</code></pre> <p>Special considerations for regenerating class diagrams</p> <p>We use Pyreverse to generate class diagrams. Pyreverse is not very flexible with respect to what it includes. We use PyGraphviz to get rid of unwanted entries from the <code>.dot</code> file generated by Pyreverse. This is because the pure-Python alternative we use elsewhere does not support editing. PyGraphviz has some special needs when it comes to installation.</p> <p>This dumpster fire is complicated and fragile.1 Depending on your configuration, PyGraphviz may not be able to find the native Graphviz library it needs. This can often be remedied by setting the appropriate <code>gcc</code> environment variables.</p> <pre><code>CPATH=/opt/local/include LIBRARY_PATH=/optlocal/lib tox -e check-classdiagrams\n</code></pre>"},{"location":"contrib/#submission-guidelines","title":"Submission guidelines","text":"<p>If you are willing and able, consider submitting a pull request with a fix. See the docs if you\u2019re not already familiar with pull requests. <code>dyce</code> releases from <code>master</code> (although not always immediately), so a lot of these workflows are helpful. There are only a few additional guidelines:</p> <ul> <li>If it is not already present, please add your name (and optionally your email, GitHub username, website address, or other contact information) to the <code>LICENSE</code> file.</li> </ul> <pre><code>...\n* [Matt Bogosian](mailto:matt@bogosian.net?Subject=dyce); GitHub \u2013 [**@posita**](https://github.com/posita)\n...\n</code></pre> <ul> <li> <p>Use Black to format your changes.   Do your best to follow the source conventions as you observe them.   If it\u2019s important to you, Existing comments are wrapped at 88 characters per line to match Black\u2019s default.   (Don\u2019t spend too much effort on strict conformance, though.   I can clean things up later if they really bother me.)</p> </li> <li> <p>Provide tests where feasible and appropriate.   At the very least, existing tests should not fail.   (There are exceptions, but if there is any doubt, they probably do not apply.)   Unit tests live in <code>tests</code>.</p> </li> <li> <p>If you want feedback on a work-in-progress, consider \u201cmentioning\u201d me (@posita), and describe specifically how I can help.   Consider prefixing your pull request\u2019s title with something like, \u201c<code>NEED FEEDBACK \u2013</code>\u201d.</p> </li> <li> <p>If your pull request is still in progress, but you are not blocked on anything, consider using the draft feature.</p> </li> <li> <p>Once you are ready for a merge, resolve any conflicts, squash your commits, and provide a useful commit message.   (This and this may be helpful.)   If your pull request started out as a draft, promote it by requesting a review.   Consider prefixing the pull request\u2019s title to something like, \u201c<code>READY FOR MERGE \u2013</code>\u201d.   I will try to get to it as soon as I can.</p> </li> </ul> <ol> <li> <p>It is uncanny how often those two properties are found together.\u00a0\u21a9</p> </li> </ol>"},{"location":"countin/","title":"Countin\u2019 with histograms and pools","text":"<p><code>dyce</code> provides two core primitives for enumeration1.</p> <pre><code>&gt;&gt;&gt; from dyce import H, P\n</code></pre> <p><code>H</code> objects represent histograms for modeling discrete outcomes. They encode finite discrete probability distributions as integer counts without any denominator. <code>P</code> objects represent pools (ordered sequences) of histograms. If all you need is to aggregate outcomes (sums) from rolling a bunch of dice (or perform calculations on aggregate outcomes), <code>H</code> objects are probably sufficient. If you need to select certain histograms from a group prior to computing aggregate outcomes (e.g., taking the highest and lowest of each possible roll of n dice), that\u2019s where <code>P</code> objects come in.</p> <p>As a wise person whose name has been lost to history once said: \u201cLanguage is imperfect. If at all possible, shut up and point.\u201d So with that illuminating (or perhaps impenetrable) introduction out of the way, let\u2019s dive into some examples!</p>"},{"location":"countin/#basic-examples","title":"Basic examples","text":"<p>A six-sided die can be modeled as:</p> <pre><code>&gt;&gt;&gt; H(6)\nH({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})\n</code></pre> <p><code>H(n)</code> is shorthand for explicitly enumerating outcomes \\([{ {1} .. {n} }]\\), each with a frequency of 1.</p> <pre><code>&gt;&gt;&gt; H(6) == H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})\nTrue\n</code></pre> <p>Tuples with repeating outcomes are accumulated. A six-sided \u201c2, 3, 3, 4, 4, 5\u201d die can be modeled as:</p> <pre><code>&gt;&gt;&gt; H((2, 3, 3, 4, 4, 5))\nH({2: 1, 3: 2, 4: 2, 5: 1})\n</code></pre> <p>A fudge die can be modeled as:</p> <pre><code>&gt;&gt;&gt; H((-1, 0, 1))\nH({-1: 1, 0: 1, 1: 1})\n</code></pre> <p>Python\u2019s matrix multiplication operator (<code>@</code>) is used to express the number of a particular die (roughly equivalent to the \u201c<code>d</code>\u201d operator in common notations). The outcomes of rolling two six-sided dice (<code>2d6</code>) are:</p> <pre><code>&gt;&gt;&gt; 2@H(6)\nH({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n</code></pre> <p>A pool of two six-sided dice is:</p> <pre><code>&gt;&gt;&gt; P(H(6), H(6))\n2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))\n</code></pre> <p>Where <code>n</code> is an integer, <code>P(n, ...)</code> is shorthand for <code>P(H(n), ...)</code>. Python\u2019s matrix multiplication operator (<code>@</code>) can also be used with pools. The above can be expressed more succinctly.</p> <pre><code>&gt;&gt;&gt; 2@P(6)\n2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))\n</code></pre> <p>Pools (in this case, Sicherman dice) can be compared to histograms.</p> <pre><code>&gt;&gt;&gt; d_sicherman = P(H((1, 2, 2, 3, 3, 4)), H((1, 3, 4, 5, 6, 8)))\n&gt;&gt;&gt; d_sicherman == 2@H(6)\nTrue\n</code></pre> <p>Both histograms and pools support arithmetic operations. <code>3\u00d7(2d6+4)</code> is:</p> <pre><code>&gt;&gt;&gt; 3*(2@H(6)+4)\nH({18: 1, 21: 2, 24: 3, 27: 4, 30: 5, 33: 6, 36: 5, 39: 4, 42: 3, 45: 2, 48: 1})\n</code></pre> <p>The results show there is one way to make <code>18</code>, two ways to make <code>21</code>, three ways to make <code>24</code>, etc.</p> <p>Histograms provide rudimentary formatting for convenience.</p> <pre><code>&gt;&gt;&gt; print((2@H(6)).format())\navg |    7.00\nstd |    2.42\nvar |    5.83\n  2 |   2.78% |#\n  3 |   5.56% |##\n  4 |   8.33% |####\n  5 |  11.11% |#####\n  6 |  13.89% |######\n  7 |  16.67% |########\n  8 |  13.89% |######\n  9 |  11.11% |#####\n 10 |   8.33% |####\n 11 |   5.56% |##\n 12 |   2.78% |#\n</code></pre> <p>The Miwin-Distribution is:</p> <pre><code>&gt;&gt;&gt; miwin_iii = H((1, 2, 5, 6, 7, 9))\n&gt;&gt;&gt; miwin_iv = H((1, 3, 4, 5, 8, 9))\n&gt;&gt;&gt; miwin_v = H((2, 3, 4, 6, 7, 8))\n&gt;&gt;&gt; miwin_dist = miwin_iii + miwin_iv + miwin_v ; miwin_dist\nH({4: 1, 5: 2, 6: 3, 7: 4, 8: 7, ..., 22: 7, 23: 4, 24: 3, 25: 2, 26: 1})\n&gt;&gt;&gt; print((miwin_dist).format(scaled=True))\navg |   15.00\nstd |    4.47\nvar |   20.00\n  4 |   0.46% |##\n  5 |   0.93% |#####\n  6 |   1.39% |#######\n  7 |   1.85% |##########\n  8 |   3.24% |##################\n  9 |   4.17% |#######################\n 10 |   4.63% |##########################\n 11 |   5.09% |############################\n 12 |   7.87% |############################################\n 13 |   8.80% |#################################################\n 14 |   8.33% |###############################################\n 15 |   6.48% |####################################\n 16 |   8.33% |###############################################\n 17 |   8.80% |#################################################\n 18 |   7.87% |############################################\n 19 |   5.09% |############################\n 20 |   4.63% |##########################\n 21 |   4.17% |#######################\n 22 |   3.24% |##################\n 23 |   1.85% |##########\n 24 |   1.39% |#######\n 25 |   0.93% |#####\n 26 |   0.46% |##\n</code></pre> <p>One way to model the outcomes of subtracting the lesser of two six-sided dice from the greater is:</p> <pre><code>&gt;&gt;&gt; abs(H(6) - H(6))\nH({0: 6, 1: 10, 2: 8, 3: 6, 4: 4, 5: 2})\n</code></pre> <p>Arithmetic operations implicitly \u201cflatten\u201d pools into histograms.</p> <pre><code>&gt;&gt;&gt; 3*(2@P(6)+4)\nH({18: 1, 21: 2, 24: 3, 27: 4, 30: 5, 33: 6, 36: 5, 39: 4, 42: 3, 45: 2, 48: 1})\n&gt;&gt;&gt; abs(P(6) - P(6))\nH({0: 6, 1: 10, 2: 8, 3: 6, 4: 4, 5: 2})\n</code></pre> <p>Histograms should be sufficient for most calculations. However, pools are useful for \u201ctaking\u201d (selecting) only some of each roll\u2019s outcomes. This is done by providing one or more index arguments to the <code>P.h</code> method or the <code>P.rolls_with_counts</code> method. Indexes can be integers, slices, or a mix thereof. Outcome indexes are ordered from least to greatest with negative values counting from the right, as one would expect (i.e., <code>[0]</code>, <code>[1]</code>, \u2026, <code>[-2]</code>, <code>[-1]</code>). Summing the least two faces when rolling three six-sided dice would be:</p> <pre><code>&gt;&gt;&gt; 3@P(6)\n3@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))\n&gt;&gt;&gt; (3@P(6)).h(0, 1)  # see warning below about parentheses\nH({2: 16, 3: 27, 4: 34, 5: 36, 6: 34, 7: 27, 8: 19, 9: 12, 10: 7, 11: 3, 12: 1})\n</code></pre> <p>Mind your parentheses</p> <p>Parentheses are needed in the above example because <code>@</code> has a lower precedence than <code>.</code> and <code>[\u2026]</code>.</p> <pre><code>&gt;&gt;&gt; 2@P(6).h(1)  # equivalent to 2@(P(6).h(1))\nTraceback (most recent call last):\n...\nIndexError: tuple index out of range\n&gt;&gt;&gt; (2@P(6)).h(1)\nH({1: 1, 2: 3, 3: 5, 4: 7, 5: 9, 6: 11})\n</code></pre> <p>Taking the least, middle, or greatest face when rolling three six-sided dice would be:</p> <pre><code>&gt;&gt;&gt; p_3d6 = 3@P(6)\n&gt;&gt;&gt; p_3d6.h(0)\nH({1: 91, 2: 61, 3: 37, 4: 19, 5: 7, 6: 1})\n&gt;&gt;&gt; print(p_3d6.h(0).format())\navg |    2.04\nstd |    1.14\nvar |    1.31\n  1 |  42.13% |#####################\n  2 |  28.24% |##############\n  3 |  17.13% |########\n  4 |   8.80% |####\n  5 |   3.24% |#\n  6 |   0.46% |\n</code></pre> <pre><code>&gt;&gt;&gt; p_3d6.h(1)\nH({1: 16, 2: 40, 3: 52, 4: 52, 5: 40, 6: 16})\n&gt;&gt;&gt; print(p_3d6.h(1).format())\navg |    3.50\nstd |    1.37\nvar |    1.88\n  1 |   7.41% |###\n  2 |  18.52% |#########\n  3 |  24.07% |############\n  4 |  24.07% |############\n  5 |  18.52% |#########\n  6 |   7.41% |###\n</code></pre> <pre><code>&gt;&gt;&gt; p_3d6.h(2)\nH({1: 1, 2: 7, 3: 19, 4: 37, 5: 61, 6: 91})\n&gt;&gt;&gt; print(p_3d6.h(-1).format())\navg |    4.96\nstd |    1.14\nvar |    1.31\n  1 |   0.46% |\n  2 |   3.24% |#\n  3 |   8.80% |####\n  4 |  17.13% |########\n  5 |  28.24% |##############\n  6 |  42.13% |#####################\n</code></pre> <p>Summing the greatest and the least faces when rolling a typical six-die polygonal set would be:</p> <pre><code>&gt;&gt;&gt; d10 = H(10)-1 ; d10  # a common \u201cd10\u201d with faces [0 .. 9]\nH({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1})\n&gt;&gt;&gt; h = P(4, 6, 8, d10, 12, 20).h(0, -1)\n&gt;&gt;&gt; print(h.format(scaled=True))\navg |   13.48\nstd |    4.40\nvar |   19.39\n  1 |   0.00% |\n  2 |   0.01% |\n  3 |   0.06% |\n  4 |   0.30% |#\n  5 |   0.92% |#####\n  6 |   2.03% |###########\n  7 |   3.76% |####################\n  8 |   5.57% |##############################\n  9 |   7.78% |###########################################\n 10 |   8.99% |##################################################\n 11 |   8.47% |###############################################\n 12 |   8.64% |################################################\n 13 |   8.66% |################################################\n 14 |   6.64% |####################################\n 15 |   5.62% |###############################\n 16 |   5.16% |############################\n 17 |   5.00% |###########################\n 18 |   5.00% |###########################\n 19 |   5.00% |###########################\n 20 |   5.00% |###########################\n 21 |   4.50% |#########################\n 22 |   2.01% |###########\n 23 |   0.73% |####\n 24 |   0.18% |\n</code></pre> <p>Pools are ordered and iterable.</p> <pre><code>&gt;&gt;&gt; list(2@P(8, 4, 6))\n[H({1: 1, 2: 1, 3: 1, 4: 1}), H({1: 1, 2: 1, 3: 1, 4: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1})]\n</code></pre> <p>Indexing selects particular histograms into a new pool.</p> <pre><code>&gt;&gt;&gt; 2@P(8, 4, 6)\nP(2@P(H({1: 1, 2: 1, 3: 1, 4: 1})), 2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})), 2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1})))\n&gt;&gt;&gt; (2@P(8, 4, 6))[:2]\n2@P(H({1: 1, 2: 1, 3: 1, 4: 1}))\n&gt;&gt;&gt; (2@P(8, 4, 6))[::3]\nP(H({1: 1, 2: 1, 3: 1, 4: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))\n</code></pre> <p>An inefficient way to enumerate all possible rolls is:</p> <pre><code>&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; list(itertools.product(*P(-3, 3)))\n[(-3, 1), (-3, 2), (-3, 3), (-2, 1), (-2, 2), (-2, 3), (-1, 1), (-1, 2), (-1, 3)]\n</code></pre> <p>Both histograms and pools support various comparison operations. The odds of observing all even faces when rolling \\(n\\) six-sided dice, for \\(n\\) in \\([1..6]\\) is:</p> <pre><code>&gt;&gt;&gt; d6_even = H(6).is_even()\n&gt;&gt;&gt; for n in range(6, 0, -1):\n...   number_of_evens_in_nd6 = n@d6_even\n...   all_even = number_of_evens_in_nd6.eq(n)\n...   print(f\"{n: &gt;2}d6: {all_even[1] / all_even.total: &gt;6.2%}\")\n 6d6:  1.56%\n 5d6:  3.12%\n 4d6:  6.25%\n 3d6: 12.50%\n 2d6: 25.00%\n 1d6: 50.00%\n</code></pre> <p>The odds of scoring at least one nine or higher on any single die when rolling \\(n\\) \u201cexploding\u201d six-sided dice, for \\(n\\) in \\([1..10]\\) is:</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import explode\n&gt;&gt;&gt; # By the time we're rolling a third die, we're guaranteed a nine or higher, so we only need to look that far\n&gt;&gt;&gt; exploding_d6 = explode(H(6), limit=2)\n&gt;&gt;&gt; for n in range(10, 0, -1):\n...   d6e_ge_9 = exploding_d6.ge(9)\n...   number_of_nines_or_higher_in_nd6e = n@d6e_ge_9\n...   at_least_one_9 = number_of_nines_or_higher_in_nd6e.ge(1)\n...   print(f\"{n: &gt;2}d6-exploding: {at_least_one_9[1] / at_least_one_9.total: &gt;6.2%}\")\n10d6-exploding: 69.21%\n 9d6-exploding: 65.36%\n 8d6-exploding: 61.03%\n 7d6-exploding: 56.15%\n 6d6-exploding: 50.67%\n 5d6-exploding: 44.51%\n 4d6-exploding: 37.57%\n 3d6-exploding: 29.77%\n 2d6-exploding: 20.99%\n 1d6-exploding: 11.11%\n</code></pre>"},{"location":"countin/#dependent-probabilities","title":"Dependent probabilities","text":"<p>Where we can identify independent terms and reduce the dependent term to a calculation solely involving independent terms, dependent probabilities can often be compactly expressed via an <code>expandable</code>-decorated function or callback passed to <code>foreach</code>. First, we express independent terms as histograms or pools. Second, we express the dependent term as a function that will be called once for each of the Cartesian product of the results from each independent term. Results are passed to the dependent function from independent histogram terms as <code>HResult</code> objects or from independent pool terms as <code>PResult</code> objects. Finally, we pass the dependent function to <code>foreach</code>, along with the independent terms, or, in the alternative, we decorate the function with <code>expandable</code>, and call it with the independent terms.</p> <p>To illustrate, say we want to roll a d6 and compare whether the result is strictly greater than its distance from some constant.</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import HResult, foreach\n&gt;&gt;&gt; d6 = H(6)  # independent term\n&gt;&gt;&gt; constant = 4\n\n&gt;&gt;&gt; def outcome_strictly_greater_than_constant(h_result: HResult):\n...   return h_result.outcome &gt; abs(h_result.outcome - constant)  # dependent term\n\n&gt;&gt;&gt; print(foreach(outcome_strictly_greater_than_constant, h_result=d6).format())\navg |    0.67\nstd |    0.47\nvar |    0.22\n  0 |  33.33% |################\n  1 |  66.67% |#################################\n</code></pre> <p>Instead of a constant, let\u2019s use another die as a second independent term. We\u2019ll roll a d4 and a d6 and compare whether the d6 is strictly greater than the absolute difference between dice.</p> <pre><code>&gt;&gt;&gt; d4 = H(4)  # first independent term\n&gt;&gt;&gt; d6 = H(6)  # second independent term\n\n&gt;&gt;&gt; def second_is_strictly_greater_than_first(first: HResult, second: HResult):\n...   return second.outcome &gt; abs(first.outcome - second.outcome)  # dependent term\n\n&gt;&gt;&gt; h = foreach(second_is_strictly_greater_than_first, first=d4, second=d6)\n&gt;&gt;&gt; print(h.format())\navg |    0.83\nstd |    0.37\nvar |    0.14\n  0 |  16.67% |########\n  1 |  83.33% |#########################################\n</code></pre> <p>In the alternative, one could nest <code>expandable</code> functions, where the innermost holds the dependent term, and the outer functions each establish the scope of their respective independent outcomes. However, this isn\u2019t very readable, and is often less efficient than using a single function.</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import expandable\n\n&gt;&gt;&gt; @expandable\n... def sub_first(first: HResult):\n...\n...   @expandable\n...   def sub_second(second: HResult):\n...     res = second.outcome &gt; abs(first.outcome - second.outcome)\n...     return res\n...\n...   return sub_second(d6)\n\n&gt;&gt;&gt; sub_first(d4, limit=-1) == h\nTrue\n</code></pre> <p>This technique also works where the dependent term requires inspection of rolls from one or more pools as independent terms. Let\u2019s say we have two pools. A roll from the first pool wins if it shows no duplicates but a roll from the second does. A roll from the second pool wins if it shows no duplicates but a roll from the first does. Otherwise, it\u2019s a tie (i.e., if neither or both rolls show duplicates). Let\u2019s compare how three six-sided dice fair against two four-sided dice.</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import PResult\n&gt;&gt;&gt; from enum import IntEnum\n\n&gt;&gt;&gt; class DupeVs(IntEnum):\n...   SECOND_WINS = -1  # where second.roll shows no duplicates, but first.roll does\n...   TIE = 0  # where both rolls show no duplicates or rolls pools have duplicates\n...   FIRST_WINS = 1  # where first.roll shows no duplicates, but second.roll does\n\n&gt;&gt;&gt; def compare_duplicates(first: PResult, second: PResult):\n...   return DupeVs((len(set(first.roll)) == len(first.roll)) - (len(set(second.roll)) == len(second.roll)))\n\n&gt;&gt;&gt; h = foreach(compare_duplicates, first=P(6, 6, 6), second=P(4, 4)) ; h\nH({&lt;DupeVs.SECOND_WINS: -1&gt;: 12,\n &lt;DupeVs.TIE: 0&gt;: 19,\n &lt;DupeVs.FIRST_WINS: 1&gt;: 5})\n&gt;&gt;&gt; print(h.format())\navg |   -0.19\nstd |    0.66\nvar |    0.43\n -1 |  33.33% |################\n  0 |  52.78% |##########################\n  1 |  13.89% |######\n</code></pre>"},{"location":"countin/#visualization","title":"Visualization","text":"<p><code>H</code> objects provide a <code>distribution</code> method and a <code>distribution_xy</code> method to ease integration with plotting packages like <code>matplotlib</code>. In addition, <code>anydyce</code> provides additional visualization and interactivity conveniences. (Many of the figures in these docs leverage <code>anydyce</code> in their construction.)</p> <p> </p>    Source: <code>plot_histogram.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom anydyce.viz import plot_bar\n\nfrom dyce import H\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n\n    ax = matplotlib.pyplot.axes()\n    text_color = \"white\" if style == \"dark\" else \"black\"\n    ax.tick_params(axis=\"x\", colors=text_color)\n    ax.tick_params(axis=\"y\", colors=text_color)\n    plot_bar(ax, [(\"\", 3 @ H(6))])\n    ax.set_title(\"Distribution for 3d6\", color=text_color)\n</code></pre>"},{"location":"countin/#time-to-get-meta-evil-on-those-outcomes","title":"Time to get meta-evil on those outcomes!","text":"<p>Thanks to <code>numerary</code>, <code>dyce</code> offers best-effort support for arbitrary number-like outcomes, including primitives from symbolic expression packages such as SymPy.</p> <pre><code>&gt;&gt;&gt; import sympy.abc\n&gt;&gt;&gt; d6x = H(6) + sympy.abc.x\n&gt;&gt;&gt; d8y = H(8) + sympy.abc.y\n&gt;&gt;&gt; P(d6x, d8y, d6x).h()\nH({2*x + y + 3: 1, 2*x + y + 4: 3, 2*x + y + 5: 6, ..., 2*x + y + 18: 6, 2*x + y + 19: 3, 2*x + y + 20: 1})\n</code></pre> <p></p> <p>Note</p> <p>Be aware that, depending on implementation, performance can suffer quite a bit when using symbolic primitives.</p> <p>For histograms and pools, <code>dyce</code> remains opinionated about ordering. For non-critical contexts where relative values are indeterminate, <code>dyce</code> will attempt a \u201cnatural\u201d ordering based on the string representation of each outcome. This is to accommodate symbolic expressions whose relative values are often unknowable.</p> <pre><code>&gt;&gt;&gt; expr = sympy.abc.x &lt; sympy.abc.x * 3 ; expr\nx &lt; 3*x\n&gt;&gt;&gt; bool(expr)  # nope\nTraceback (most recent call last):\n  ...\nTypeError: cannot determine truth value of Relational\n</code></pre> <p>SymPy does not even attempt simple relative comparisons between symbolic expressions, even where they are unambiguously resolvable. Instead, it relies on the caller to invoke its proprietary solver APIs.</p> <pre><code>&gt;&gt;&gt; bool(sympy.abc.x &lt; sympy.abc.x + 1)\nTraceback (most recent call last):\n  ...\nTypeError: cannot determine truth value of Relational\n&gt;&gt;&gt; import sympy.solvers.inequalities\n&gt;&gt;&gt; sympy.solvers.inequalities.reduce_inequalities(sympy.abc.x &lt; sympy.abc.x + 1, [sympy.abc.x])\nTrue\n</code></pre> <p><code>dyce</code>, of course, is happily ignorant of all that keenness. (As it should be.) In practice, that means that certain operations won\u2019t work with symbolic expressions where correctness depends on ordering outcomes according to relative value (e.g., dice selection from pools).</p> <p>Flattening pools works.</p> <pre><code>&gt;&gt;&gt; d3x = H(3) * sympy.abc.x ; d3x\nH({2*x: 1, 3*x: 1, x: 1})\n&gt;&gt;&gt; p = P(d3x / 3, (d3x + 1) / 3, (d3x + 2) / 3)\n&gt;&gt;&gt; p.h()\nH({2*x + 1: 7, 3*x + 1: 1, 4*x/3 + 1: 3, 5*x/3 + 1: 6, 7*x/3 + 1: 6, 8*x/3 + 1: 3, x + 1: 1})\n</code></pre> <p>Selecting the \u201clowest\u201d die doesn\u2019t.</p> <pre><code>&gt;&gt;&gt; p.h(0)\nTraceback (most recent call last):\n  ...\nTypeError: cannot determine truth value of Relational\n</code></pre> <p>Selecting all dice works, since it\u2019s equivalent to flattening (no sorting is required).</p> <pre><code>&gt;&gt;&gt; p.h(slice(None))\nH({2*x + 1: 7, 3*x + 1: 1, 4*x/3 + 1: 3, 5*x/3 + 1: 6, 7*x/3 + 1: 6, 8*x/3 + 1: 3, x + 1: 1})\n</code></pre> <p>Enumerating rolls doesn\u2019t, even where there is no selection, because each roll\u2019s outcomes are sorted least-to-greatest.</p> <pre><code>&gt;&gt;&gt; list(p.rolls_with_counts())\nTraceback (most recent call last):\n  ...\nTypeError: cannot determine truth value of Relational\n</code></pre> <p><code>P.roll</code> \u201cworks\u201d (i.e., falls back to natural ordering of outcomes), but that is a deliberate compromise of convenience.</p> <pre><code>&gt;&gt;&gt; p.roll()  # doctest: +SKIP\n(2*x/3, 2*x/3 + 1/3, x/3 + 2/3)\n</code></pre> <p><code>P.umap</code> can help pave the way back to concrete outcomes.</p> <pre><code>&gt;&gt;&gt; f = lambda outcome: outcome.subs({sympy.abc.x: sympy.Rational(1, 3)})\n&gt;&gt;&gt; p.umap(f)\nP(H({1/9: 1, 2/9: 1, 1/3: 1}), H({4/9: 1, 5/9: 1, 2/3: 1}), H({7/9: 1, 8/9: 1, 1: 1}))\n&gt;&gt;&gt; p.umap(f).h(-1)\nH({7/9: 9, 8/9: 9, 1: 9})\n</code></pre>"},{"location":"countin/#further-exploration","title":"Further exploration","text":"<p>Consider delving into some applications and translations for more sophisticated examples, or jump right into the API.</p> <p>Anywhere you see a JupyterLite logo , you can click on it to immediately start tinkering with a temporal instance of that example using <code>anydyce</code>. Just be aware that changes are stored in browser memory, so make sure to download any notebooks you want to preserve.</p> <ol> <li> <p><code>dyce</code> also provides additional primitives (<code>R</code> objects and their kin) which are useful for producing weighted randomized rolls without the overhead of enumeration. These are covered seperately.\u00a0\u21a9</p> </li> </ol>"},{"location":"dyce.evaluation/","title":"<tt>dyce.evaluation</tt>","text":""},{"location":"dyce.evaluation/#dyceevaluation-package-reference","title":"<code>dyce.evaluation</code> package reference","text":""},{"location":"dyce.evaluation/#dyce.evaluation.HResult","title":"<code>HResult</code>","text":"<p>             Bases: <code>NamedTuple</code></p> Source code in <code>dyce/evaluation.py</code> <pre><code>class HResult(NamedTuple):\n    h: H\n    outcome: RealLike\n</code></pre>"},{"location":"dyce.evaluation/#dyce.evaluation.HResult.h","title":"<code>h: H</code>  <code>instance-attribute</code>","text":""},{"location":"dyce.evaluation/#dyce.evaluation.HResult.outcome","title":"<code>outcome: RealLike</code>  <code>instance-attribute</code>","text":""},{"location":"dyce.evaluation/#dyce.evaluation.PResult","title":"<code>PResult</code>","text":"<p>             Bases: <code>NamedTuple</code></p> Source code in <code>dyce/evaluation.py</code> <pre><code>class PResult(NamedTuple):\n    p: P\n    roll: RollT\n</code></pre>"},{"location":"dyce.evaluation/#dyce.evaluation.PResult.p","title":"<code>p: P</code>  <code>instance-attribute</code>","text":""},{"location":"dyce.evaluation/#dyce.evaluation.PResult.roll","title":"<code>roll: RollT</code>  <code>instance-attribute</code>","text":""},{"location":"dyce.evaluation/#dyce.evaluation.PWithSelection","title":"<code>PWithSelection</code>","text":"<p>             Bases: <code>NamedTuple</code></p> Source code in <code>dyce/evaluation.py</code> <pre><code>class PWithSelection(NamedTuple):\n    p: P\n    which: Iterable[_GetItemT] = ()\n\n    @property\n    def total(self) -&gt; int:\n        return self.p.total\n</code></pre>"},{"location":"dyce.evaluation/#dyce.evaluation.PWithSelection.p","title":"<code>p: P</code>  <code>instance-attribute</code>","text":""},{"location":"dyce.evaluation/#dyce.evaluation.PWithSelection.total","title":"<code>total: int</code>  <code>property</code>","text":""},{"location":"dyce.evaluation/#dyce.evaluation.PWithSelection.which","title":"<code>which: Iterable[_GetItemT] = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.evaluation/#dyce.evaluation.aggregate_weighted","title":"<code>aggregate_weighted(weighted_sources: Iterable[Tuple[HOrOutcomeT, int]], h_type: Type[H] = H) -&gt; H</code>","text":"<p>Aggregates weighted_sources into an <code>H</code> object. Each of weighted_sources is a two-tuple of either an outcome-count pair or a histogram-count pair. This function is used in the implementation of the <code>expandable</code> decorator and derivatives (like the <code>foreach</code> function) as well as the (deprecated) <code>H.substitute</code> and <code>P.foreach</code> methods. Unlike those, the histogram returned from this function is not reduced to its lowest terms.</p> <p>In nearly all cases, when a source contains a histogram, its total takes on the corresponding count\u2019s weight. In other words, the sum of the counts of the histogram retains the same proportion to other outcomes as its corresponding count. This becomes clearer when there is no overlap between the histogram and the other outcomes.</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import aggregate_weighted\n&gt;&gt;&gt; weighted_sources = ((H({1: 1}), 1), (H({1: 1, 2: 2}), 2))\n&gt;&gt;&gt; h = aggregate_weighted(weighted_sources).lowest_terms() ; h\nH({1: 5, 2: 4})\n</code></pre> <p>An important exception</p> <p>If a source is the empty histogram (<code>H({})</code>), it and its count is omitted from the result without scaling.</p> <pre><code>&gt;&gt;&gt; weighted_sources = ((H(2), 1), (H({}), 20))\n&gt;&gt;&gt; aggregate_weighted(weighted_sources)\nH({1: 1, 2: 1})\n</code></pre> Source code in <code>dyce/evaluation.py</code> <pre><code>@beartype\ndef aggregate_weighted(\n    weighted_sources: Iterable[Tuple[HOrOutcomeT, int]],\n    h_type: Type[H] = H,\n) -&gt; H:\nr\"\"\"\n    Aggregates *weighted_sources* into an [``H`` object][dyce.h.H]. Each of\n    *weighted_sources* is a two-tuple of either an outcome-count pair or a\n    histogram-count pair. This function is used in the implementation of the\n    [``expandable`` decorator][dyce.evaluation.expandable] and derivatives (like the\n    [``foreach`` function][dyce.evaluation.foreach]) as well as the (deprecated)\n    [``H.substitute``][dyce.h.H.substitute] and [``P.foreach``][dyce.p.P.foreach]\n    methods. Unlike those, the histogram returned from this function is *not* reduced to\n    its lowest terms.\n\n    In nearly all cases, when a source contains a histogram, its total takes on the\n    corresponding count\u2019s weight. In other words, the sum of the counts of the histogram\n    retains the same proportion to other outcomes as its corresponding count. This\n    becomes clearer when there is no overlap between the histogram and the other\n    outcomes.\n\n    ``` python\n    &gt;&gt;&gt; from dyce.evaluation import aggregate_weighted\n    &gt;&gt;&gt; weighted_sources = ((H({1: 1}), 1), (H({1: 1, 2: 2}), 2))\n    &gt;&gt;&gt; h = aggregate_weighted(weighted_sources).lowest_terms() ; h\n    H({1: 5, 2: 4})\n\n    ```\n\n    !!! note \"An important exception\"\n\n        If a source is the empty histogram (``H({})``), it and its count is omitted from\n        the result without scaling.\n\n        ``` python\n        &gt;&gt;&gt; weighted_sources = ((H(2), 1), (H({}), 20))\n        &gt;&gt;&gt; aggregate_weighted(weighted_sources)\n        H({1: 1, 2: 1})\n\n        ```\n    \"\"\"\n    aggregate_scalar = 1\n    outcome_counts: List[_OutcomeCountT] = []\n\n    for outcome_or_h, count in weighted_sources:\n        if isinstance(outcome_or_h, H):\n            if outcome_or_h:\n                h_scalar = outcome_or_h.total\n\n                for i, (prior_outcome, prior_count) in enumerate(outcome_counts):\n                    outcome_counts[i] = (prior_outcome, prior_count * h_scalar)\n\n                for new_outcome, new_count in outcome_or_h.items():\n                    outcome_counts.append(\n                        (new_outcome, count * aggregate_scalar * new_count)\n                    )\n\n                aggregate_scalar *= h_scalar\n        else:\n            outcome_counts.append((outcome_or_h, count * aggregate_scalar))\n\n    return h_type(outcome_counts)\n</code></pre>"},{"location":"dyce.evaluation/#dyce.evaluation.expandable","title":"<code>expandable(f: Optional[_DependentTermT] = None, *, sentinel: H = _DEFAULT_SENTINEL) -&gt; Union[Callable[[_DependentTermT], _ForEachEvaluatorT], _ForEachEvaluatorT]</code>","text":"<p>Experimental</p> <p>This function should be considered experimental and may change or disappear in future versions.</p> <p>Calls <code>dependent_term</code> for each set of outcomes from the product of any independent sources provided to the decorated function and accumulates the results. Independent sources are <code>H</code> objects, <code>P</code> objects, or <code>PWithSelection</code> wrapper objects. Results are passed to <code>dependent_term</code> via <code>HResult</code> objects or <code>PResult</code> objects, corresponding to the respective independent term. This is useful for resolving dependent probabilities. Returned histograms are always reduced to their lowest terms.</p> <p>For example, let\u2019s say we\u2019re rolling a d20 but want to re-roll a <code>1</code> if it comes up, then keep the result.</p> <pre><code>&gt;&gt;&gt; from dyce import H\n&gt;&gt;&gt; from dyce.evaluation import HResult, expandable\n\n&gt;&gt;&gt; @expandable\n... def reroll_on_one(h_result: HResult):\n...   if h_result.outcome == 1:\n...     return h_result.h\n...   else:\n...     return h_result.outcome\n\n&gt;&gt;&gt; reroll_on_one(H(20))\nH({1: 1,\n 2: 21,\n 3: 21,\n 4: 21,\n ...,\n 18: 21,\n 19: 21,\n 20: 21})\n&gt;&gt;&gt; reroll_on_one(H(6))\nH({1: 1, 2: 7, 3: 7, 4: 7, 5: 7, 6: 7})\n</code></pre> <p>When the decorated function returns an <code>H</code> object, that histogram\u2019s outcomes are accumulated, but the counts retain their \u201cscale\u201d within the context of the evaluation. This becomes clearer when there is no overlap between the evaluated histogram and the other outcomes.</p> <pre><code>&gt;&gt;&gt; d6 = H(6)\n&gt;&gt;&gt; d00 = (H(10) - 1) * 10 ; d00\nH({0: 1, 10: 1, 20: 1, 30: 1, 40: 1, 50: 1, 60: 1, 70: 1, 80: 1, 90: 1})\n&gt;&gt;&gt; set(d6) &amp; set(d00) == set()  # no outcomes in common\nTrue\n\n&gt;&gt;&gt; @expandable\n... def roll_d00_on_one(h_result: HResult):\n...   # If a 1 comes up when rolling the d6,\n...   # roll a d00 and take that result instead\n...   return d00 if h_result.outcome == 1 else h_result.outcome\n\n&gt;&gt;&gt; d6_d00 = roll_d00_on_one(d6) ; d6_d00\nH({0: 1,\n 2: 10,\n 3: 10,\n 4: 10,\n 5: 10,\n 6: 10,\n 10: 1,\n 20: 1,\n 30: 1,\n 40: 1,\n 50: 1,\n 60: 1,\n 70: 1,\n 80: 1,\n 90: 1})\n</code></pre> <p>Note that the sum of the outcomes\u2019 counts from the d00 make up the same proportion as the one\u2019s outcome and count they replaced from the d6.</p> <pre><code>&gt;&gt;&gt; Fraction(\n...   sum(count for outcome, count in d6_d00.items() if outcome in d00),\n...   d6_d00.total,\n... )\nFraction(1, 6)\n&gt;&gt;&gt; Fraction(d6[1], d6.total)\nFraction(1, 6)\n</code></pre> <p>We can leverage this to compute distributions for an \u201cexploding\u201d die (i.e., re-rolling and adding when rolling its highest face).</p> <pre><code>&gt;&gt;&gt; @expandable\n... def explode_once(h_result: HResult):\n...   if h_result.outcome == max(h_result.h):\n...     return h_result.h + h_result.outcome\n...   else:\n...     return h_result.outcome\n\n&gt;&gt;&gt; explode_once(H(6))\nH({1: 6, 2: 6, 3: 6, 4: 6, 5: 6, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})\n&gt;&gt;&gt; explode_once(H(20))\nH({1: 20,\n   2: 20,\n   ...,\n   18: 20,\n   19: 20,\n   21: 1,\n   22: 1,\n   ...,\n   39: 1,\n   40: 1})\n</code></pre> <p><code>@expandable</code> functions can call themselves recursively. They take a limit keyword argument to control when such recursion should stop. The decorator itself takes an optional argument sentinel, which defines what is returned once limit is reached (or a <code>RecursionError</code> is encountered, whichever comes first). The default value for sentinel is <code>H({0: 1})</code> and the value ascribed to limit, if not provided, is <code>1</code>.</p> <p>If limit is a whole number, it defines the maximum recursive evaluation \u201cdepth\u201d. The way to express no recursion (i.e., merely return sentinel) is to set limit to an integral value of <code>0</code>. An integral value of <code>-1</code> is equivalent to setting it to <code>sys.maxsize</code>.1</p> <pre><code>&gt;&gt;&gt; def explode_recursive(h: H, limit=None) -&gt; H:\n...\n...   @expandable(sentinel=h)  # return the original histogram at the recursion limit\n...   def _expand(h_result: HResult):\n...     return _expand(h_result.h) + h_result.outcome if h_result.outcome == max(h_result.h) else h_result.outcome\n...\n...   return _expand(h, limit=limit)\n\n&gt;&gt;&gt; explode_recursive(H(6), limit=1) == explode_once(H(6))\nTrue\n&gt;&gt;&gt; explode_recursive(H(6), limit=0) == H(6)  # return the sentinel without evaluation\nTrue\n&gt;&gt;&gt; exploded_d6_h = explode_recursive(H(6), limit=2) ; exploded_d6_h\nH({1: 36,\n 2: 36,\n 3: 36,\n 4: 36,\n 5: 36,\n 7: 6,\n 8: 6,\n 9: 6,\n 10: 6,\n 11: 6,\n 13: 1,\n 14: 1,\n 15: 1,\n 16: 1,\n 17: 1,\n 18: 1})\n</code></pre> <p>If limit is a fractional value between zero and one, exclusive, recursion will halt on any branch whose \u201ccontextual precision\u201d is less than or equal to that value. Recursion is attempted for all of the outcomes of a(n evaluated) histogram or none of them. The contextual precision of a returned histogram is its proportion to the whole.</p> <p>The contextual precision of the original (or top-level) execution is <code>Fraction(1, 1)</code> or <code>1.0</code>. A limit of either of those values would theoretically ensure no substitution. Similarly, a fractional value for limit of <code>Fraction(0, 1)</code> or <code>0.0</code> would theoretically ensure there is no limit. However, These expressions would likely lead to confusion because they have different meanings than equivalent integral values for limit. This is why fractional types with values equivalent to zero and one are not allowed.</p> <pre><code>&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; explode_recursive(H(6), limit=Fraction(1, 6 ** 2)) == exploded_d6_h\nTrue\n</code></pre> <p>While whole number limit values will always cut off recursion at a constant depth, fractional limit values can skew results in favor of certain recursion branches. This is easily demonstrated when examining \u201cunfair\u201d dice (i.e., those disproportionately weighted toward particular faces).</p> <pre><code>&gt;&gt;&gt; explode_recursive(H({1: 1, 2: 19}), limit=3)\nH({1: 8000, 3: 7600, 5: 7220, 7: 6859, 8: 130321})\n&gt;&gt;&gt; explode_recursive(H({1: 19, 2: 1}), limit=3)  # same depth\nH({1: 152000, 3: 7600, 5: 380, 7: 19, 8: 1})\n\n&gt;&gt;&gt; explode_recursive(H({1: 1, 2: 19}), limit=Fraction(9, 10))\nH({1: 8000, 3: 7600, 5: 7220, 7: 6859, 8: 130321})\n&gt;&gt;&gt; explode_recursive(H({1: 19, 2: 1}), limit=Fraction(9, 10))  # same limit, different depth\nH({1: 380, 3: 19, 4: 1})\n</code></pre> <p>Be aware that some recursions are guaranteed to result in maxing out the stack, even with fractional values for limit that are very close to one. We can often guard against this by short-circuiting recursion where we know the evaluated contextual probabilities do not asymptotically approach zero (e.g., where an entire branch reliably generates histograms with precisely one outcome).</p> <pre><code>&gt;&gt;&gt; def guarded_explode(h: H, limit=None) -&gt; H:\n...\n...   @expandable(sentinel=h)\n...   def _expand(h_result: HResult):\n...     if len(h_result.h) == 1:\n...       raise ValueError(\"cannot explode a histogram with a single outcome\")\n...     elif h_result.outcome == max(h_result.h):\n...       return _expand(h_result.h) + h_result.outcome\n...     else:\n...       return h_result.outcome\n...\n...   return _expand(h, limit=limit)\n\n&gt;&gt;&gt; guarded_explode(H(1), limit=Fraction(999_999, 1_000_000))\nTraceback (most recent call last):\n  ...\nValueError: cannot explode a histogram with a single outcome\n</code></pre> <p>We can also evaluate multiple independent sources. For example, let\u2019s say we want to understand when a d6 will beat each face on two d10s. We can use a nested function to also allow for a penalty or bonus modifier to the d6.</p> <pre><code>&gt;&gt;&gt; from dyce import P\n&gt;&gt;&gt; from dyce.evaluation import PResult\n&gt;&gt;&gt; p_2d10 = 2@P(10)\n\n&gt;&gt;&gt; def times_a_modded_d6_beats_two_d10s(mod: int = 0) -&gt; H:\n...\n...   @expandable\n...   def _expand(d6: HResult, p_2d10: PResult):\n...     return sum(1 for outcome in p_2d10.roll if outcome &lt; d6.outcome + mod)\n...\n...   return _expand(H(6), p_2d10)\n\n&gt;&gt;&gt; times_a_modded_d6_beats_two_d10s()\nH({0: 71, 1: 38, 2: 11})\n&gt;&gt;&gt; times_a_modded_d6_beats_two_d10s(mod=-1)\nH({0: 43, 1: 14, 2: 3})\n&gt;&gt;&gt; times_a_modded_d6_beats_two_d10s(mod=+2)\nH({0: 199, 1: 262, 2: 139})\n</code></pre> <p>Now let\u2019s say we want to introduce the concept of an \u201cadvantage\u201d or \u201cdisadvantage\u201d to the above, meaning we roll an extra d10 that can further penalize or benefit us. We could just roll 3d10 and look at the best or worst two of each roll.</p> <pre><code>&gt;&gt;&gt; from enum import Enum, auto\n&gt;&gt;&gt; p_3d10 = 3@P(10)\n\n&gt;&gt;&gt; class Advantage(Enum):\n...   DISADVANTAGE = auto()\n...   NORMAL = auto()\n...   ADVANTAGE = auto()\n\n&gt;&gt;&gt; def times_a_modded_d6_beats_two_d10s_w_adv_brute_force(mod: int = 0, adv: Advantage = Advantage.NORMAL) -&gt; H:\n...\n...   @expandable\n...   def _expand(d6: HResult, p_d10s: PResult):\n...     if adv is Advantage.ADVANTAGE:\n...       roll = p_d10s.roll[:2]  # try to beat the worst two values\n...     elif adv is Advantage.DISADVANTAGE:\n...       roll = p_d10s.roll[-2:]  # try to beat the best two values\n...     else:\n...       roll = p_d10s.roll\n...     return sum(1 for outcome in roll if outcome &lt; d6.outcome + mod)\n...\n...   if adv is Advantage.NORMAL:\n...     return _expand(H(6), p_2d10)\n...   else:\n...     return _expand(H(6), p_3d10)\n\n&gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv_brute_force() == times_a_modded_d6_beats_two_d10s()\nTrue\n&gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv_brute_force(adv=Advantage.ADVANTAGE)\nH({0: 39, 1: 25, 2: 16})\n&gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv_brute_force(adv=Advantage.DISADVANTAGE)\nH({0: 64, 1: 13, 2: 3})\n</code></pre> <p>However, we could be more computationally more efficient by narrowing our selection before we get to our evaluation function. We do this using <code>PWithSelection</code> objects whose <code>PWithSelection.which</code> values are passed to the <code>P.rolls_with_counts</code> method when enumerating the rolls.</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import PWithSelection\n\n&gt;&gt;&gt; def times_a_modded_d6_beats_two_d10s_w_adv(mod: int = 0, adv: Advantage = Advantage.NORMAL) -&gt; H:\n...\n...   @expandable\n...   def _expand(d6: HResult, p_d10s: PResult):\n...     return sum(1 for outcome in p_d10s.roll if outcome &lt; d6.outcome + mod)\n...\n...   if adv is Advantage.ADVANTAGE:\n...     return _expand(H(6), PWithSelection(p_3d10, (0, 1)))  # pass only the worst two values\n...   elif adv is Advantage.DISADVANTAGE:\n...     return _expand(H(6), PWithSelection(p_3d10, (-2, -1)))  # pass only the best two values\n...   else:\n...     return _expand(H(6), p_2d10)\n\n&gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv() == times_a_modded_d6_beats_two_d10s()\nTrue\n&gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv(adv=Advantage.ADVANTAGE)\nH({0: 39, 1: 25, 2: 16})\n&gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv(adv=Advantage.DISADVANTAGE)\nH({0: 64, 1: 13, 2: 3})\n</code></pre> <p>This function uses the <code>aggregate_weighted</code> function in its implementation. As such, if the empty histogram (<code>H({})</code>) is returned at any point, the corresponding branch and its count is omitted from the result without substitution or scaling. A silly example is modeling a d5 by indefinitely re-rolling a d6 until something other than a 6 comes up.</p> <pre><code>&gt;&gt;&gt; @expandable\n... def omit_6s(h_result: HResult):\n...   return H({}) if h_result.outcome == 6 else h_result.outcome\n\n&gt;&gt;&gt; omit_6s(H(6))\nH({1: 1, 2: 1, 3: 1, 4: 1, 5: 1})\n</code></pre> <p>This technique is more useful when modeling re-rolling certain derived outcomes, like ties in a contest.</p> <pre><code>&gt;&gt;&gt; @expandable\n... def vs(attack: HResult, defend: HResult):\n...   return (attack.outcome &gt; defend.outcome) - (attack.outcome &lt; defend.outcome)\n\n&gt;&gt;&gt; vs(3@H(6), 2@H(8))\nH({-1: 4553, 0: 1153, 1: 8118})\n\n&gt;&gt;&gt; @expandable\n... def vs_reroll_ties(attack: HResult, defend: HResult):\n...   res = (attack.outcome &gt; defend.outcome) - (attack.outcome &lt; defend.outcome)\n...   return H({}) if res == 0 else res\n\n&gt;&gt;&gt; vs_reroll_ties(3@H(6), 2@H(8))\nH({-1: 4553, 1: 8118})\n</code></pre> <p>Expandables are quite flexible and well suited to modeling logical progressions with dependent variables. Consider the following mechanic:</p> <ol> <li> <p>Start with a total of zero.</p> </li> <li> <p>Roll a six-sided die. If the face was a six, go to step 3. Otherwise, add the      face to the total and stop.</p> </li> <li> <p>Roll a four-sided die. Add the face to the total. If the face was a one, go to      step 2. Otherwise, stop.</p> </li> </ol> <p>What is the likelihood of an even final tally? This can be approximated by:</p> <pre><code>&gt;&gt;&gt; def alternating_d6_d4_mechanic(limit=None) -&gt; H:\n...   d4, d6 = H(4), H(6)\n...\n...   @expandable\n...   def _expand(h_result: HResult):\n...     if h_result.h == d6 and h_result.outcome == 6:\n...       return _expand(d4)\n...     elif h_result.h == d4 and h_result.outcome == 1:\n...       return h_result.outcome + _expand(d6)\n...     else:\n...       return h_result.outcome\n...\n...   return _expand(d6, limit=limit)\n\n&gt;&gt;&gt; h = alternating_d6_d4_mechanic(limit=Fraction(1, 5_000))\n&gt;&gt;&gt; print(h.format(scaled=True))\navg |    3.04\nstd |    1.37\nvar |    1.87\n  1 |  16.67% |######################################\n  2 |  21.53% |#################################################\n  3 |  21.74% |##################################################\n  4 |  21.74% |##################################################\n  5 |  17.57% |########################################\n  6 |   0.73% |#\n  7 |   0.03% |\n&gt;&gt;&gt; h_even = h.is_even()\n&gt;&gt;&gt; print(f\"{h_even[True] / h_even.total:.2%}\")\n44.00%\n</code></pre> <p>We can also use this decorator to help model expected damage from a single attack in d20-like role playing games.</p> <pre><code>&gt;&gt;&gt; def expected_dmg_from_attack_roll(dmg_h, dmg_bonus, target):\n...   normal_dmg = dmg_h + dmg_bonus\n...   crit_dmg = 2@dmg_h + dmg_bonus\n...\n...   @expandable\n...   def _expand(attack: HResult):\n...     if attack.outcome == 20:\n...       return crit_dmg\n...     elif attack.outcome &gt;= target:\n...       return normal_dmg\n...     else:\n...       return 0\n...\n...   return _expand(H(20))\n\n&gt;&gt;&gt; h = expected_dmg_from_attack_roll(dmg_h=H(8), dmg_bonus=+1, target=14)\n&gt;&gt;&gt; print(h.format(scaled=True))\navg |    2.15\nstd |    3.40\nvar |   11.55\n  0 |  65.00% |##################################################\n  2 |   3.75% |##\n  3 |   3.83% |##\n  4 |   3.91% |###\n  5 |   3.98% |###\n  6 |   4.06% |###\n  7 |   4.14% |###\n  8 |   4.22% |###\n  9 |   4.30% |###\n 10 |   0.62% |\n 11 |   0.55% |\n 12 |   0.47% |\n 13 |   0.39% |\n 14 |   0.31% |\n 15 |   0.23% |\n 16 |   0.16% |\n 17 |   0.08% |\n</code></pre> <p>On the current implementation</p> <p>This decorator relies on context variables for enforcing limits without requiring decorated functions to explicitly propagate additional state.</p> <ol> <li> <p>An integral limit in the low-to-mid single digits is often more than sufficient to exceed a useful precision. Consider starting small and edging up incrementally to avoid protracted execution times. Consider:</p> <pre><code>&gt;&gt;&gt; @expandable\n... def wicked_explode(h_result: HResult):\n...   if h_result.outcome == max(h_result.h):\n...     # Replace a high roll with two recursively exploding dice\n...     return wicked_explode(h_result.h) + wicked_explode(h_result.h)\n...   else:\n...     return h_result.outcome\n\n&gt;&gt;&gt; h = wicked_explode(H(6), limit=6)\n&gt;&gt;&gt; print(f\"Likelihood of making {max(h)}: {h[max(h)] / h.total:.50%}\")\nLikelihood of making 160: 0.00000000000000000000000000000000000000000000000947%\n</code></pre> <p>The above limit is tolerable for modern computing devices, but much more might render it intractable.\u00a0\u21a9</p> </li> </ol> Source code in <code>dyce/evaluation.py</code> <pre><code>@experimental\n@beartype\ndef expandable(\n    f: Optional[_DependentTermT] = None,\n    *,\n    sentinel: H = _DEFAULT_SENTINEL,\n) -&gt; Union[Callable[[_DependentTermT], _ForEachEvaluatorT], _ForEachEvaluatorT]:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This function should be considered experimental and may change or disappear in\n        future versions.\n\n    Calls ``#!python dependent_term`` for each set of outcomes from the product of any\n    independent sources provided to the decorated function and accumulates the results.\n    Independent sources are [``H`` objects][dyce.h.H], [``P`` objects][dyce.p.P], or\n    [``PWithSelection`` wrapper objects][dyce.evaluation.PWithSelection]. Results are\n    passed to ``#!python dependent_term`` via\n    [``HResult`` objects][dyce.evaluation.HResult] or\n    [``PResult`` objects][dyce.evaluation.PResult], corresponding to the respective\n    independent term. This is useful for resolving dependent probabilities. Returned\n    histograms are always reduced to their lowest terms.\n\n    For example, let\u2019s say we\u2019re rolling a d20 but want to re-roll a ``#!python 1`` if\n    it comes up, then keep the result.\n\n    ``` python\n    &gt;&gt;&gt; from dyce import H\n    &gt;&gt;&gt; from dyce.evaluation import HResult, expandable\n\n    &gt;&gt;&gt; @expandable\n    ... def reroll_on_one(h_result: HResult):\n    ...   if h_result.outcome == 1:\n    ...     return h_result.h\n    ...   else:\n    ...     return h_result.outcome\n\n    &gt;&gt;&gt; reroll_on_one(H(20))\n    H({1: 1,\n     2: 21,\n     3: 21,\n     4: 21,\n     ...,\n     18: 21,\n     19: 21,\n     20: 21})\n    &gt;&gt;&gt; reroll_on_one(H(6))\n    H({1: 1, 2: 7, 3: 7, 4: 7, 5: 7, 6: 7})\n\n    ```\n\n    When the decorated function returns an [``H`` object][dyce.h.H], that histogram\u2019s\n    outcomes are accumulated, but the counts retain their \u201cscale\u201d within the context of\n    the evaluation. This becomes clearer when there is no overlap between the evaluated\n    histogram and the other outcomes.\n\n    ``` python\n    &gt;&gt;&gt; d6 = H(6)\n    &gt;&gt;&gt; d00 = (H(10) - 1) * 10 ; d00\n    H({0: 1, 10: 1, 20: 1, 30: 1, 40: 1, 50: 1, 60: 1, 70: 1, 80: 1, 90: 1})\n    &gt;&gt;&gt; set(d6) &amp; set(d00) == set()  # no outcomes in common\n    True\n\n    &gt;&gt;&gt; @expandable\n    ... def roll_d00_on_one(h_result: HResult):\n    ...   # If a 1 comes up when rolling the d6,\n    ...   # roll a d00 and take that result instead\n    ...   return d00 if h_result.outcome == 1 else h_result.outcome\n\n    &gt;&gt;&gt; d6_d00 = roll_d00_on_one(d6) ; d6_d00\n    H({0: 1,\n     2: 10,\n     3: 10,\n     4: 10,\n     5: 10,\n     6: 10,\n     10: 1,\n     20: 1,\n     30: 1,\n     40: 1,\n     50: 1,\n     60: 1,\n     70: 1,\n     80: 1,\n     90: 1})\n\n    ```\n\n    Note that the sum of the outcomes\u2019 counts from the d00 make up the same\n    proportion as the one\u2019s outcome and count they replaced from the d6.\n\n    ``` python\n    &gt;&gt;&gt; Fraction(\n    ...   sum(count for outcome, count in d6_d00.items() if outcome in d00),\n    ...   d6_d00.total,\n    ... )\n    Fraction(1, 6)\n    &gt;&gt;&gt; Fraction(d6[1], d6.total)\n    Fraction(1, 6)\n\n    ```\n\n    We can leverage this to compute distributions for an \u201cexploding\u201d die (i.e.,\n    re-rolling and adding when rolling its highest face).\n\n    ``` python\n    &gt;&gt;&gt; @expandable\n    ... def explode_once(h_result: HResult):\n    ...   if h_result.outcome == max(h_result.h):\n    ...     return h_result.h + h_result.outcome\n    ...   else:\n    ...     return h_result.outcome\n\n    &gt;&gt;&gt; explode_once(H(6))\n    H({1: 6, 2: 6, 3: 6, 4: 6, 5: 6, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})\n    &gt;&gt;&gt; explode_once(H(20))\n    H({1: 20,\n       2: 20,\n       ...,\n       18: 20,\n       19: 20,\n       21: 1,\n       22: 1,\n       ...,\n       39: 1,\n       40: 1})\n\n    ```\n\n    ``#!python @expandable`` functions can call themselves recursively. They take a\n    *limit* keyword argument to control when such recursion should stop. The decorator\n    itself takes an optional argument *sentinel*, which defines what is returned once\n    *limit* is reached (or a ``#!python RecursionError`` is encountered, whichever comes\n    first). The default value for *sentinel* is ``#!python H({0: 1})`` and the value\n    ascribed to *limit*, if not provided, is ``#!python 1``.\n\n    If *limit* is a whole number, it defines the maximum recursive evaluation \u201cdepth\u201d.\n    The way to express no recursion (i.e., merely return *sentinel*) is to set *limit*\n    to an integral value of ``#!python 0``. An integral value of ``#!python -1`` is\n    equivalent to setting it to ``#!python sys.maxsize``.[^1]\n\n    [^1]:\n\n        An integral *limit* in the low-to-mid single digits is often more than\n        sufficient to exceed a useful precision. Consider starting small and edging up\n        incrementally to avoid protracted execution times. Consider:\n\n        ``` python\n        &gt;&gt;&gt; @expandable\n        ... def wicked_explode(h_result: HResult):\n        ...   if h_result.outcome == max(h_result.h):\n        ...     # Replace a high roll with two recursively exploding dice\n        ...     return wicked_explode(h_result.h) + wicked_explode(h_result.h)\n        ...   else:\n        ...     return h_result.outcome\n\n        &gt;&gt;&gt; h = wicked_explode(H(6), limit=6)\n        &gt;&gt;&gt; print(f\"Likelihood of making {max(h)}: {h[max(h)] / h.total:.50%}\")\n        Likelihood of making 160: 0.00000000000000000000000000000000000000000000000947%\n\n        ```\n\n        The above *limit* is tolerable for modern computing devices, but much more might\n        render it intractable.\n\n    ``` python\n    &gt;&gt;&gt; def explode_recursive(h: H, limit=None) -&gt; H:\n    ...\n    ...   @expandable(sentinel=h)  # return the original histogram at the recursion limit\n    ...   def _expand(h_result: HResult):\n    ...     return _expand(h_result.h) + h_result.outcome if h_result.outcome == max(h_result.h) else h_result.outcome\n    ...\n    ...   return _expand(h, limit=limit)\n\n    &gt;&gt;&gt; explode_recursive(H(6), limit=1) == explode_once(H(6))\n    True\n    &gt;&gt;&gt; explode_recursive(H(6), limit=0) == H(6)  # return the sentinel without evaluation\n    True\n    &gt;&gt;&gt; exploded_d6_h = explode_recursive(H(6), limit=2) ; exploded_d6_h\n    H({1: 36,\n     2: 36,\n     3: 36,\n     4: 36,\n     5: 36,\n     7: 6,\n     8: 6,\n     9: 6,\n     10: 6,\n     11: 6,\n     13: 1,\n     14: 1,\n     15: 1,\n     16: 1,\n     17: 1,\n     18: 1})\n\n    ```\n\n    If *limit* is a fractional value between zero and one, exclusive, recursion will\n    halt on any branch whose \u201ccontextual precision\u201d is less than or equal to that value.\n    Recursion is attempted for all of the outcomes of a(n evaluated) histogram or none\n    of them. The contextual precision of a returned histogram is its proportion to the\n    whole.\n\n    The contextual precision of the original (or top-level) execution is ``#!python\n    Fraction(1, 1)`` or ``#!python 1.0``. A *limit* of either of those values would\n    theoretically ensure no substitution. Similarly, a fractional value for *limit* of\n    ``#!python Fraction(0, 1)`` or ``#!python 0.0`` would theoretically ensure there is\n    no limit. However, These expressions would likely lead to confusion because they\n    have different meanings than equivalent integral values for *limit*. This is why\n    fractional types with values equivalent to zero and one are not allowed.\n\n    ``` python\n    &gt;&gt;&gt; from fractions import Fraction\n    &gt;&gt;&gt; explode_recursive(H(6), limit=Fraction(1, 6 ** 2)) == exploded_d6_h\n    True\n\n    ```\n\n    While whole number *limit* values will always cut off recursion at a constant depth,\n    fractional *limit* values can skew results in favor of certain recursion branches.\n    This is easily demonstrated when examining \u201cunfair\u201d dice (i.e., those\n    disproportionately weighted toward particular faces).\n\n    ``` python\n    &gt;&gt;&gt; explode_recursive(H({1: 1, 2: 19}), limit=3)\n    H({1: 8000, 3: 7600, 5: 7220, 7: 6859, 8: 130321})\n    &gt;&gt;&gt; explode_recursive(H({1: 19, 2: 1}), limit=3)  # same depth\n    H({1: 152000, 3: 7600, 5: 380, 7: 19, 8: 1})\n\n    &gt;&gt;&gt; explode_recursive(H({1: 1, 2: 19}), limit=Fraction(9, 10))\n    H({1: 8000, 3: 7600, 5: 7220, 7: 6859, 8: 130321})\n    &gt;&gt;&gt; explode_recursive(H({1: 19, 2: 1}), limit=Fraction(9, 10))  # same limit, different depth\n    H({1: 380, 3: 19, 4: 1})\n\n    ```\n\n    Be aware that some recursions are guaranteed to result in maxing out the stack, even\n    with fractional values for *limit* that are very close to one. We can often guard\n    against this by short-circuiting recursion where we know the evaluated contextual\n    probabilities do not asymptotically approach zero (e.g., where an entire branch\n    reliably generates histograms with precisely one outcome).\n\n    ``` python\n    &gt;&gt;&gt; def guarded_explode(h: H, limit=None) -&gt; H:\n    ...\n    ...   @expandable(sentinel=h)\n    ...   def _expand(h_result: HResult):\n    ...     if len(h_result.h) == 1:\n    ...       raise ValueError(\"cannot explode a histogram with a single outcome\")\n    ...     elif h_result.outcome == max(h_result.h):\n    ...       return _expand(h_result.h) + h_result.outcome\n    ...     else:\n    ...       return h_result.outcome\n    ...\n    ...   return _expand(h, limit=limit)\n\n    &gt;&gt;&gt; guarded_explode(H(1), limit=Fraction(999_999, 1_000_000))\n    Traceback (most recent call last):\n      ...\n    ValueError: cannot explode a histogram with a single outcome\n\n    ```\n\n    We can also evaluate multiple independent sources. For example, let\u2019s say we want to\n    understand when a d6 will beat each face on two d10s. We can use a nested function\n    to also allow for a penalty or bonus modifier to the d6.\n\n    ``` python\n    &gt;&gt;&gt; from dyce import P\n    &gt;&gt;&gt; from dyce.evaluation import PResult\n    &gt;&gt;&gt; p_2d10 = 2@P(10)\n\n    &gt;&gt;&gt; def times_a_modded_d6_beats_two_d10s(mod: int = 0) -&gt; H:\n    ...\n    ...   @expandable\n    ...   def _expand(d6: HResult, p_2d10: PResult):\n    ...     return sum(1 for outcome in p_2d10.roll if outcome &lt; d6.outcome + mod)\n    ...\n    ...   return _expand(H(6), p_2d10)\n\n    &gt;&gt;&gt; times_a_modded_d6_beats_two_d10s()\n    H({0: 71, 1: 38, 2: 11})\n    &gt;&gt;&gt; times_a_modded_d6_beats_two_d10s(mod=-1)\n    H({0: 43, 1: 14, 2: 3})\n    &gt;&gt;&gt; times_a_modded_d6_beats_two_d10s(mod=+2)\n    H({0: 199, 1: 262, 2: 139})\n\n    ```\n\n    Now let\u2019s say we want to introduce the concept of an \u201cadvantage\u201d or \u201cdisadvantage\u201d\n    to the above, meaning we roll an extra d10 that can further penalize or benefit us.\n    We *could* just roll 3d10 and look at the best or worst two of each roll.\n\n\n    ``` python\n    &gt;&gt;&gt; from enum import Enum, auto\n    &gt;&gt;&gt; p_3d10 = 3@P(10)\n\n    &gt;&gt;&gt; class Advantage(Enum):\n    ...   DISADVANTAGE = auto()\n    ...   NORMAL = auto()\n    ...   ADVANTAGE = auto()\n\n    &gt;&gt;&gt; def times_a_modded_d6_beats_two_d10s_w_adv_brute_force(mod: int = 0, adv: Advantage = Advantage.NORMAL) -&gt; H:\n    ...\n    ...   @expandable\n    ...   def _expand(d6: HResult, p_d10s: PResult):\n    ...     if adv is Advantage.ADVANTAGE:\n    ...       roll = p_d10s.roll[:2]  # try to beat the worst two values\n    ...     elif adv is Advantage.DISADVANTAGE:\n    ...       roll = p_d10s.roll[-2:]  # try to beat the best two values\n    ...     else:\n    ...       roll = p_d10s.roll\n    ...     return sum(1 for outcome in roll if outcome &lt; d6.outcome + mod)\n    ...\n    ...   if adv is Advantage.NORMAL:\n    ...     return _expand(H(6), p_2d10)\n    ...   else:\n    ...     return _expand(H(6), p_3d10)\n\n    &gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv_brute_force() == times_a_modded_d6_beats_two_d10s()\n    True\n    &gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv_brute_force(adv=Advantage.ADVANTAGE)\n    H({0: 39, 1: 25, 2: 16})\n    &gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv_brute_force(adv=Advantage.DISADVANTAGE)\n    H({0: 64, 1: 13, 2: 3})\n\n    ```\n\n    However, we could be more computationally more efficient by narrowing our selection\n    before we get to our evaluation function. We do this using\n    [``PWithSelection`` objects][dyce.evaluation.PWithSelection] whose ``#!python\n    PWithSelection.which`` values are passed to the\n    [``P.rolls_with_counts``][dyce.p.P.rolls_with_counts] method when enumerating the\n    rolls.\n\n    ``` python\n    &gt;&gt;&gt; from dyce.evaluation import PWithSelection\n\n    &gt;&gt;&gt; def times_a_modded_d6_beats_two_d10s_w_adv(mod: int = 0, adv: Advantage = Advantage.NORMAL) -&gt; H:\n    ...\n    ...   @expandable\n    ...   def _expand(d6: HResult, p_d10s: PResult):\n    ...     return sum(1 for outcome in p_d10s.roll if outcome &lt; d6.outcome + mod)\n    ...\n    ...   if adv is Advantage.ADVANTAGE:\n    ...     return _expand(H(6), PWithSelection(p_3d10, (0, 1)))  # pass only the worst two values\n    ...   elif adv is Advantage.DISADVANTAGE:\n    ...     return _expand(H(6), PWithSelection(p_3d10, (-2, -1)))  # pass only the best two values\n    ...   else:\n    ...     return _expand(H(6), p_2d10)\n\n    &gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv() == times_a_modded_d6_beats_two_d10s()\n    True\n    &gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv(adv=Advantage.ADVANTAGE)\n    H({0: 39, 1: 25, 2: 16})\n    &gt;&gt;&gt; times_a_modded_d6_beats_two_d10s_w_adv(adv=Advantage.DISADVANTAGE)\n    H({0: 64, 1: 13, 2: 3})\n\n    ```\n\n    This function uses the [``aggregate_weighted``][dyce.evaluation.aggregate_weighted]\n    function in its implementation. As such, if the empty histogram (``H({})``) is\n    returned at any point, the corresponding branch and its count is omitted from the\n    result without substitution or scaling. A silly example is modeling a d5 by\n    indefinitely re-rolling a d6 until something other than a 6 comes up.\n\n    ``` python\n    &gt;&gt;&gt; @expandable\n    ... def omit_6s(h_result: HResult):\n    ...   return H({}) if h_result.outcome == 6 else h_result.outcome\n\n    &gt;&gt;&gt; omit_6s(H(6))\n    H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1})\n\n    ```\n\n    This technique is more useful when modeling re-rolling certain derived outcomes,\n    like ties in a contest.\n\n    ``` python\n    &gt;&gt;&gt; @expandable\n    ... def vs(attack: HResult, defend: HResult):\n    ...   return (attack.outcome &gt; defend.outcome) - (attack.outcome &lt; defend.outcome)\n\n    &gt;&gt;&gt; vs(3@H(6), 2@H(8))\n    H({-1: 4553, 0: 1153, 1: 8118})\n\n    &gt;&gt;&gt; @expandable\n    ... def vs_reroll_ties(attack: HResult, defend: HResult):\n    ...   res = (attack.outcome &gt; defend.outcome) - (attack.outcome &lt; defend.outcome)\n    ...   return H({}) if res == 0 else res\n\n    &gt;&gt;&gt; vs_reroll_ties(3@H(6), 2@H(8))\n    H({-1: 4553, 1: 8118})\n\n    ```\n\n    Expandables are quite flexible and well suited to modeling logical progressions with\n    dependent variables. Consider the following mechanic:\n\n      1. Start with a total of zero.\n\n      2. Roll a six-sided die. If the face was a six, go to step 3. Otherwise, add the\n         face to the total and stop.\n\n      3. Roll a four-sided die. Add the face to the total. If the face was a one, go to\n         step 2. Otherwise, stop.\n\n    What is the likelihood of an even final tally? This can be approximated by:\n\n    ``` python\n    &gt;&gt;&gt; def alternating_d6_d4_mechanic(limit=None) -&gt; H:\n    ...   d4, d6 = H(4), H(6)\n    ...\n    ...   @expandable\n    ...   def _expand(h_result: HResult):\n    ...     if h_result.h == d6 and h_result.outcome == 6:\n    ...       return _expand(d4)\n    ...     elif h_result.h == d4 and h_result.outcome == 1:\n    ...       return h_result.outcome + _expand(d6)\n    ...     else:\n    ...       return h_result.outcome\n    ...\n    ...   return _expand(d6, limit=limit)\n\n    &gt;&gt;&gt; h = alternating_d6_d4_mechanic(limit=Fraction(1, 5_000))\n    &gt;&gt;&gt; print(h.format(scaled=True))\n    avg |    3.04\n    std |    1.37\n    var |    1.87\n      1 |  16.67% |######################################\n      2 |  21.53% |#################################################\n      3 |  21.74% |##################################################\n      4 |  21.74% |##################################################\n      5 |  17.57% |########################################\n      6 |   0.73% |#\n      7 |   0.03% |\n    &gt;&gt;&gt; h_even = h.is_even()\n    &gt;&gt;&gt; print(f\"{h_even[True] / h_even.total:.2%}\")\n    44.00%\n\n    ```\n\n    We can also use this decorator to help model expected damage from a single attack in\n    d20-like role playing games.\n\n    ``` python\n    &gt;&gt;&gt; def expected_dmg_from_attack_roll(dmg_h, dmg_bonus, target):\n    ...   normal_dmg = dmg_h + dmg_bonus\n    ...   crit_dmg = 2@dmg_h + dmg_bonus\n    ...\n    ...   @expandable\n    ...   def _expand(attack: HResult):\n    ...     if attack.outcome == 20:\n    ...       return crit_dmg\n    ...     elif attack.outcome &gt;= target:\n    ...       return normal_dmg\n    ...     else:\n    ...       return 0\n    ...\n    ...   return _expand(H(20))\n\n    &gt;&gt;&gt; h = expected_dmg_from_attack_roll(dmg_h=H(8), dmg_bonus=+1, target=14)\n    &gt;&gt;&gt; print(h.format(scaled=True))\n    avg |    2.15\n    std |    3.40\n    var |   11.55\n      0 |  65.00% |##################################################\n      2 |   3.75% |##\n      3 |   3.83% |##\n      4 |   3.91% |###\n      5 |   3.98% |###\n      6 |   4.06% |###\n      7 |   4.14% |###\n      8 |   4.22% |###\n      9 |   4.30% |###\n     10 |   0.62% |\n     11 |   0.55% |\n     12 |   0.47% |\n     13 |   0.39% |\n     14 |   0.31% |\n     15 |   0.23% |\n     16 |   0.16% |\n     17 |   0.08% |\n\n    ```\n\n    !!! info \"On the current implementation\"\n\n        This decorator relies on [context\n        variables](https://docs.python.org/3/library/contextvars.html) for enforcing\n        limits without requiring decorated functions to explicitly propagate additional\n        state.\n    \"\"\"\n\n    def _decorator(f):\n        @wraps(f)\n        def _f(\n            *args: _POrPWithSelectionOrSourceT,\n            limit: Optional[LimitT] = None,\n            **kw: _POrPWithSelectionOrSourceT,\n        ) -&gt; H:\n            try:\n                cur_ctxt = _expandable_ctxt.get()\n            except LookupError:\n                cur_ctxt = _Context()\n\n            callback = f\n\n            if limit is None:\n                new_norm_limit = (\n                    _DEFAULT_LIMIT\n                    if cur_ctxt.normalized_limit is None\n                    else _normalize_limit(cur_ctxt.normalized_limit)\n                )\n            else:\n                new_norm_limit = _normalize_limit(limit)\n\n            if (\n                isinstance(new_norm_limit, int)\n                and cur_ctxt.contextual_depth &gt;= new_norm_limit\n                or isinstance(new_norm_limit, Fraction)\n                and cur_ctxt.contextual_precision &lt;= new_norm_limit\n            ):\n                res = sentinel\n            else:\n                # Mixing these requires dictionaries' orders to be durable across state\n                # mutations. We're relying on args and kw to remain constant and\n                # ordered.\n                objs: Tuple[Union[H, P, PWithSelection], ...] = tuple(\n                    _source_to_h_or_p_or_p_with_selection(arg)\n                    for arg in chain(args, kw.values())\n                )\n\n                total = sum(obj.total for obj in objs)\n\n                def _expand_if_we_can_can_can() -&gt; Iterator[Tuple[HOrOutcomeT, int]]:\n                    for result_counts in product(\n                        *(\n                            _h_or_p_or_p_with_selection_to_result_iterable(obj)\n                            for obj in objs\n                        )\n                    ):\n                        results, counts = zip(*result_counts)\n                        combined_count = prod(counts)\n                        token = _expandable_ctxt.set(\n                            _Context(\n                                normalized_limit=new_norm_limit,\n                                contextual_depth=cur_ctxt.contextual_depth + 1,\n                                contextual_precision=Fraction(\n                                    cur_ctxt.contextual_precision.numerator\n                                    * combined_count,\n                                    cur_ctxt.contextual_precision.denominator * total,\n                                ),\n                            )\n                        )\n\n                        try:\n                            # Remember how we signaled our reliance on the ordering\n                            # above? Here's why. We're going to take the first part as\n                            # the args, and the second part as the ordered kw values,\n                            # then zip them back up with the ordered kw keys.\n                            callback_args = results[: len(args)]\n                            callback_kw = dict(zip(kw.keys(), results[len(args) :]))\n\n                            # This is either our callback or our sentinel function (if\n                            # we hit our limit above)\n                            evaluated = callback(*callback_args, **callback_kw)\n                        except RecursionError:\n                            # We bottomed out the system stack when calling our\n                            # callback, so return our sentinel\n                            evaluated = sentinel\n                        finally:\n                            _expandable_ctxt.reset(token)\n\n                        yield evaluated, combined_count\n\n                res = aggregate_weighted(_expand_if_we_can_can_can())\n\n            if cur_ctxt.contextual_depth == 0:\n                res = res.lowest_terms()\n\n            return res\n\n        return _f\n\n    assert callable(f) or f is None\n\n    return _decorator(f) if callable(f) else _decorator\n</code></pre>"},{"location":"dyce.evaluation/#dyce.evaluation.explode","title":"<code>explode(source: _SourceT, predicate: _PredicateT = lambda result: result.outcome == max(result.h), limit: Optional[LimitT] = None, inf: Optional[LimitT] = float('inf')) -&gt; H</code>","text":"<p>Experimental</p> <p>This function should be considered experimental and may change or disappear in future versions.</p> <p>Approximates an \u201cexploding\u201d die (i.e., one where a running total is accumulated and re-rolls are allowed so long as predicate returns <code>True</code>). predicate takes two arguments: outcome is the outcome being considered and h is the histogram from which it originated. The default predicate returns <code>True</code> if its outcome is <code>max(h)</code>, and <code>False</code> otherwise. limit shares the same semantics as with the <code>expandable</code> decorator.</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import HResult, explode\n&gt;&gt;&gt; explode(H(6), limit=2)\nH({1: 36,\n 2: 36,\n 3: 36,\n 4: 36,\n 5: 36,\n 7: 6,\n 8: 6,\n 9: 6,\n 10: 6,\n 11: 6,\n 13: 1,\n 14: 1,\n 15: 1,\n 16: 1,\n 17: 1,\n 18: 1})\n\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; # approximates d20 that explodes when rolling any even number (to a precision of 0.0001 or better)\n\n&gt;&gt;&gt; def is_even_predicate(h_result: HResult):\n...   return h_result.outcome % 2 == 0\n\n&gt;&gt;&gt; explode(H(20), is_even_predicate, limit=Fraction(1, 10_000))\nH({1: 160000,\n 3: 168000,\n 5: 176400,\n 7: 185220,\n 9: 194481,\n 10: 1,\n 11: 204205,\n 12: 5,\n 13: 214415,\n 14: 15,\n 15: 225135,\n ...,\n 95: 15,\n 96: 15,\n 97: 5,\n 98: 5,\n 99: 1,\n 100: 1})\n</code></pre> <p>Where h has a single outcome that satisfies predicate and limit is a fractional value, this function returns special histograms, possibly leveraging the inf parameter. The default for inf is <code>float(\"inf\")</code>.</p> <pre><code>&gt;&gt;&gt; explode(H({3: 1}), is_even_predicate, limit=Fraction(1, 10_000))  # returns h\nH({3: 1})\n&gt;&gt;&gt; explode(H({2: 1}), is_even_predicate, limit=Fraction(1, 10_000))  # extrapolated to positive infinity\nH({inf: 1})\n&gt;&gt;&gt; explode(H({0: 1}), is_even_predicate, limit=Fraction(1, 10_000))  # returns h\nH({0: 1})\n&gt;&gt;&gt; explode(H({-2: 1}), is_even_predicate, limit=Fraction(1, 10_000))  # extrapolated to negative infinity\nH({-inf: 1})\n&gt;&gt;&gt; explode(H({-2: 1}), is_even_predicate, limit=Fraction(1, 10_000), inf=1_000_000)\nH({-2000000: 1})\n</code></pre> <pre><code>&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; x = sympy.sympify(\"x\")\n&gt;&gt;&gt; explode(H({x: 1}), limit=Fraction(1, 10_000))\nH({oo*x: 1})\n</code></pre> Source code in <code>dyce/evaluation.py</code> <pre><code>@experimental\n@beartype\ndef explode(\n    source: _SourceT,\n    predicate: _PredicateT = lambda result: result.outcome == max(result.h),\n    limit: Optional[LimitT] = None,\n    inf=float(\"inf\"),\n) -&gt; H:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This function should be considered experimental and may change or disappear in\n        future versions.\n\n    Approximates an \u201cexploding\u201d die (i.e., one where a running total is accumulated\n    and re-rolls are allowed so long as *predicate* returns ``#!python True``).\n    *predicate* takes two arguments: *outcome* is the outcome being considered and *h*\n    is the histogram from which it originated. The default *predicate* returns\n    ``#!python True`` if its *outcome* is ``#!python max(h)``, and ``#!python False``\n    otherwise. *limit* shares the same semantics as with the\n    [``expandable`` decorator][dyce.evaluation.expandable].\n\n    ``` python\n    &gt;&gt;&gt; from dyce.evaluation import HResult, explode\n    &gt;&gt;&gt; explode(H(6), limit=2)\n    H({1: 36,\n     2: 36,\n     3: 36,\n     4: 36,\n     5: 36,\n     7: 6,\n     8: 6,\n     9: 6,\n     10: 6,\n     11: 6,\n     13: 1,\n     14: 1,\n     15: 1,\n     16: 1,\n     17: 1,\n     18: 1})\n\n    &gt;&gt;&gt; from fractions import Fraction\n    &gt;&gt;&gt; # approximates d20 that explodes when rolling any even number (to a precision of 0.0001 or better)\n\n    &gt;&gt;&gt; def is_even_predicate(h_result: HResult):\n    ...   return h_result.outcome % 2 == 0\n\n    &gt;&gt;&gt; explode(H(20), is_even_predicate, limit=Fraction(1, 10_000))\n    H({1: 160000,\n     3: 168000,\n     5: 176400,\n     7: 185220,\n     9: 194481,\n     10: 1,\n     11: 204205,\n     12: 5,\n     13: 214415,\n     14: 15,\n     15: 225135,\n     ...,\n     95: 15,\n     96: 15,\n     97: 5,\n     98: 5,\n     99: 1,\n     100: 1})\n\n    ```\n\n    Where *h* has a single outcome that satisfies *predicate* and *limit* is a\n    fractional value, this function returns special histograms, possibly leveraging the\n    *inf* parameter. The default for *inf* is ``#!python float(\"inf\")``.\n\n    ``` python\n    &gt;&gt;&gt; explode(H({3: 1}), is_even_predicate, limit=Fraction(1, 10_000))  # returns h\n    H({3: 1})\n    &gt;&gt;&gt; explode(H({2: 1}), is_even_predicate, limit=Fraction(1, 10_000))  # extrapolated to positive infinity\n    H({inf: 1})\n    &gt;&gt;&gt; explode(H({0: 1}), is_even_predicate, limit=Fraction(1, 10_000))  # returns h\n    H({0: 1})\n    &gt;&gt;&gt; explode(H({-2: 1}), is_even_predicate, limit=Fraction(1, 10_000))  # extrapolated to negative infinity\n    H({-inf: 1})\n    &gt;&gt;&gt; explode(H({-2: 1}), is_even_predicate, limit=Fraction(1, 10_000), inf=1_000_000)\n    H({-2000000: 1})\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; x = sympy.sympify(\"x\")\n    &gt;&gt;&gt; explode(H({x: 1}), limit=Fraction(1, 10_000))\n    H({oo*x: 1})\n\n    ```\n    \"\"\"\n    h = source if isinstance(source, H) else H(source)\n\n    @expandable(sentinel=h)\n    def _explode(h_result: HResult) -&gt; HOrOutcomeT:\n        if predicate(h_result):\n            if len(h_result.h) == 1 and not isinstance(\n                limit, (type(None), IntegralLike)\n            ):\n                if h_result.outcome == h_result.outcome - h_result.outcome:\n                    return H({h_result.outcome: 1})\n                else:\n                    return H({inf * h_result.outcome: 1})\n            else:\n                return _explode(h_result.h) + h_result.outcome\n        else:\n            return h_result.outcome\n\n    return _explode(h, limit=limit)\n</code></pre>"},{"location":"dyce.evaluation/#dyce.evaluation.foreach","title":"<code>foreach(callback: _DependentTermT, *args: _POrPWithSelectionOrSourceT, limit: Optional[LimitT] = None, sentinel: H = _DEFAULT_SENTINEL, **kw: _POrPWithSelectionOrSourceT) -&gt; H</code>","text":"<p>Experimental</p> <p>This function should be considered experimental and may change or disappear in future versions.</p> <p>Shorthand for <code>expandable(callback, sentinel=sentinel)(*args, limit=limit,**kw)</code>.</p> <p>Many common cases do not need the full flexibility of the <code>expandable</code>. This wrapper that strives to be simpler or more readable under those circumstances (e.g., where the callback is a <code>lambda</code> function).</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import foreach\n&gt;&gt;&gt; foreach(lambda d8, d12: d8.outcome + d12.outcome, d8=H(8), d12=H(12))\nH({2: 1,\n 3: 2,\n 4: 3,\n 5: 4,\n 6: 5,\n 7: 6,\n 8: 7,\n 9: 8,\n 10: 8,\n 11: 8,\n 12: 8,\n 13: 8,\n 14: 7,\n 15: 6,\n 16: 5,\n 17: 4,\n 18: 3,\n 19: 2,\n 20: 1})\n</code></pre> Source code in <code>dyce/evaluation.py</code> <pre><code>@experimental\n@beartype\ndef foreach(\n    callback: _DependentTermT,\n    *args: _POrPWithSelectionOrSourceT,\n    limit: Optional[LimitT] = None,\n    sentinel: H = _DEFAULT_SENTINEL,\n    **kw: _POrPWithSelectionOrSourceT,\n) -&gt; H:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This function should be considered experimental and may change or disappear in\n        future versions.\n\n    Shorthand for ``#!python expandable(callback, sentinel=sentinel)(*args, limit=limit,\n    **kw)``.\n\n    Many common cases do not need the full flexibility of the\n    [``expandable``][dyce.evaluation.expandable]. This wrapper that strives to be\n    simpler or more readable under those circumstances (e.g., where the callback is a\n    ``#!python lambda`` function).\n\n    ``` python\n    &gt;&gt;&gt; from dyce.evaluation import foreach\n    &gt;&gt;&gt; foreach(lambda d8, d12: d8.outcome + d12.outcome, d8=H(8), d12=H(12))\n    H({2: 1,\n     3: 2,\n     4: 3,\n     5: 4,\n     6: 5,\n     7: 6,\n     8: 7,\n     9: 8,\n     10: 8,\n     11: 8,\n     12: 8,\n     13: 8,\n     14: 7,\n     15: 6,\n     16: 5,\n     17: 4,\n     18: 3,\n     19: 2,\n     20: 1})\n\n    ```\n    \"\"\"\n    return expandable(callback, sentinel=sentinel)(*args, limit=limit, **kw)\n</code></pre>"},{"location":"dyce.h/","title":"<tt>dyce.h</tt>","text":""},{"location":"dyce.h/#dyceh-package-reference","title":"<code>dyce.h</code> package reference","text":""},{"location":"dyce.h/#dyce.h.HableT","title":"<code>HableT</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol whose implementer can be expressed as (or reduced to) an <code>H</code> object by calling its <code>h</code> method. Currently, only the <code>P</code> class implements this protocol, but this affords an integration point for <code>dyce</code> users.</p> <p>Info</p> <p>The intended pronunciation of <code>Hable</code> is AYCH-uh-BUL1 (i.e., <code>H</code>-able). Yes, that is a clumsy attempt at verbing. (You could totally <code>H</code> that, dude!) However, if you prefer something else (e.g. HAY-bul or AYCH-AY-bul), no one is going to judge you. (Well, they might, but they shouldn\u2019t.) We all know what you mean.</p> <ol> <li> <p>World Book Online (WBO) style pronunciation respelling.\u00a0\u21a9</p> </li> </ol> Source code in <code>dyce/h.py</code> <pre><code>@runtime_checkable\nclass HableT(Protocol, metaclass=CachingProtocolMeta):\nr\"\"\"\n    A protocol whose implementer can be expressed as (or reduced to) an\n    [``H`` object][dyce.h.H] by calling its [``h`` method][dyce.h.HableT.h]. Currently,\n    only the [``P`` class][dyce.p.P] implements this protocol, but this affords an\n    integration point for ``#!python dyce`` users.\n\n    !!! info\n\n        The intended pronunciation of ``Hable`` is *AYCH-uh-BUL*[^1] (i.e.,\n        [``H``][dyce.h.H]-able). Yes, that is a clumsy attempt at\n        [verbing](https://www.gocomics.com/calvinandhobbes/1993/01/25). (You could\n        *totally* [``H``][dyce.h.H] that, dude!) However, if you prefer something else\n        (e.g. *HAY-bul* or *AYCH-AY-bul*), no one is going to judge you. (Well, they\n        *might*, but they *shouldn\u2019t*.) We all know what you mean.\n\n    [^1]:\n\n        World Book Online (WBO) style [pronunciation\n        respelling](https://en.wikipedia.org/wiki/Pronunciation_respelling_for_English#Traditional_respelling_systems).\n    \"\"\"\n    __slots__: Any = ()\n\n    @abstractmethod\n    def h(self) -&gt; H:\nr\"\"\"\n        Express its implementer as an [``H`` object][dyce.h.H].\n        \"\"\"\n        pass\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableT.__slots__","title":"<code>__slots__: Any = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.h/#dyce.h.HableT.h","title":"<code>h() -&gt; H</code>  <code>abstractmethod</code>","text":"<p>Express its implementer as an <code>H</code> object.</p> Source code in <code>dyce/h.py</code> <pre><code>@abstractmethod\ndef h(self) -&gt; H:\nr\"\"\"\n    Express its implementer as an [``H`` object][dyce.h.H].\n    \"\"\"\n    pass\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin","title":"<code>HableOpsMixin</code>","text":"<p>             Bases: <code>HableT</code></p> <p>A \u201cmix-in\u201d class providing arithmetic operations for implementers of the <code>HableT</code> protocol. The <code>P</code> class derives from this class.</p> <p>Info</p> <p>See <code>HableT</code> for notes on pronunciation.</p> Source code in <code>dyce/h.py</code> <pre><code>class HableOpsMixin(HableT):\nr\"\"\"\n    A \u201cmix-in\u201d class providing arithmetic operations for implementers of the\n    [``HableT`` protocol][dyce.h.HableT]. The [``P`` class][dyce.p.P] derives from this\n    class.\n\n    !!! info\n\n        See [``HableT``][dyce.h.HableT] for notes on pronunciation.\n    \"\"\"\n    __slots__: Any = ()\n\n    def __init__(self):\n        object.__init__(self)\n\n    @beartype\n    def __add__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__add__(self.h(), other)``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __add__(self.h(), other)\n\n    @beartype\n    def __radd__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__add__(other, self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __add__(other, self.h())\n\n    @beartype\n    def __sub__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__sub__(self.h(), other)``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __sub__(self.h(), other)\n\n    @beartype\n    def __rsub__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__sub__(other, self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __sub__(other, self.h())\n\n    @beartype\n    def __mul__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__mul__(self.h(), other)``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __mul__(self.h(), other)\n\n    @beartype\n    def __rmul__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__mul__(other, self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __mul__(other, self.h())\n\n    @beartype\n    def __truediv__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__truediv__(self.h(), other)``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __truediv__(self.h(), other)\n\n    @beartype\n    def __rtruediv__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__truediv__(other, self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __truediv__(other, self.h())\n\n    @beartype\n    def __floordiv__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__floordiv__(self.h(), other)``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __floordiv__(self.h(), other)\n\n    @beartype\n    def __rfloordiv__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__floordiv__(other, self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __floordiv__(other, self.h())\n\n    @beartype\n    def __mod__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__mod__(self.h(), other)``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __mod__(self.h(), other)\n\n    @beartype\n    def __rmod__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__mod__(other, self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __mod__(other, self.h())\n\n    @beartype\n    def __pow__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__pow__(self.h(), other)``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __pow__(self.h(), other)\n\n    @beartype\n    def __rpow__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__pow__(other, self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __pow__(other, self.h())\n\n    @beartype\n    def __and__(self: HableT, other: Union[SupportsInt, H, HableT]) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__and__(self.h(), other)``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __and__(self.h(), other)\n\n    @beartype\n    def __rand__(self: HableT, other: SupportsInt) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__and__(other, self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __and__(other, self.h())\n\n    @beartype\n    def __xor__(self: HableT, other: Union[SupportsInt, H, HableT]) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__xor__(self.h(), other)``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __xor__(self.h(), other)\n\n    @beartype\n    def __rxor__(self: HableT, other: SupportsInt) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__xor__(other, self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __xor__(other, self.h())\n\n    @beartype\n    def __or__(self: HableT, other: Union[SupportsInt, H, HableT]) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__or__(self.h(), other)``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __or__(self.h(), other)\n\n    @beartype\n    def __ror__(self: HableT, other: SupportsInt) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__or__(other, self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __or__(other, self.h())\n\n    @beartype\n    def __neg__(self: HableT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__neg__(self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __neg__(self.h())\n\n    @beartype\n    def __pos__(self: HableT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__pos__(self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __pos__(self.h())\n\n    @beartype\n    def __abs__(self: HableT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__abs__(self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __abs__(self.h())\n\n    @beartype\n    def __invert__(self: HableT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python operator.__invert__(self.h())``. See the\n        [``h`` method][dyce.h.HableT.h].\n        \"\"\"\n        return __invert__(self.h())\n\n    @beartype\n    def lt(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.h().lt(other)``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.lt``][dyce.h.H.lt].\n        \"\"\"\n        return self.h().lt(other)\n\n    @beartype\n    def le(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.h().le(other)``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.le``][dyce.h.H.le].\n        \"\"\"\n        return self.h().le(other)\n\n    @beartype\n    def eq(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.h().eq(other)``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.eq``][dyce.h.H.eq].\n        \"\"\"\n        return self.h().eq(other)\n\n    @beartype\n    def ne(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.h().ne(other)``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.ne``][dyce.h.H.ne].\n        \"\"\"\n        return self.h().ne(other)\n\n    @beartype\n    def gt(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.h().gt(other)``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.gt``][dyce.h.H.gt].\n        \"\"\"\n        return self.h().gt(other)\n\n    @beartype\n    def ge(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.h().ge(other)``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.ge``][dyce.h.H.ge].\n        \"\"\"\n        return self.h().ge(other)\n\n    @beartype\n    def is_even(self: HableT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.h().is_even()``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.is_even``][dyce.h.H.is_even].\n        \"\"\"\n        return self.h().is_even()\n\n    @beartype\n    def is_odd(self: HableT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.h().is_odd()``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.is_odd``][dyce.h.H.is_odd].\n        \"\"\"\n        return self.h().is_odd()\n\n    @overload\n    def explode(\n        self: HableT,\n        max_depth: IntegralLike,\n        precision_limit: None = None,\n    ) -&gt; H:\n        ...\n\n    @overload\n    def explode(\n        self: HableT,\n        max_depth: None,\n        precision_limit: Union[RationalLikeMixedU, RealLike],\n    ) -&gt; H:\n        ...\n\n    @overload\n    def explode(\n        self: HableT,\n        max_depth: None = None,\n        *,\n        precision_limit: Union[RationalLikeMixedU, RealLike],\n    ) -&gt; H:\n        ...\n\n    @overload\n    def explode(\n        self: HableT,\n        max_depth: None = None,\n        precision_limit: None = None,\n    ) -&gt; H:\n        ...\n\n    @beartype\n    def explode(\n        self: HableT,\n        max_depth: Optional[IntegralLike] = None,\n        precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None,\n    ) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.h().explode(max_depth, precision_limit)``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.explode``][dyce.h.H.explode].\n        \"\"\"\n        if max_depth is not None and precision_limit is not None:\n            raise ValueError(\"only one of max_depth and precision_limit is allowed\")\n        elif max_depth is not None:\n            return self.h().explode(max_depth)\n        elif precision_limit is not None:\n            return self.h().explode(precision_limit=precision_limit)\n        else:\n            return self.h().explode()\n\n    @overload\n    def substitute(\n        self: HableT,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n        *,\n        max_depth: IntegralLike,\n        precision_limit: None = None,\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self: HableT,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT,\n        max_depth: IntegralLike,\n        precision_limit: None = None,\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self: HableT,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n        *,\n        max_depth: None,\n        precision_limit: Union[RationalLikeMixedU, RealLike],\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self: HableT,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT,\n        max_depth: None,\n        precision_limit: Union[RationalLikeMixedU, RealLike],\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self: HableT,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n        max_depth: None = None,\n        *,\n        precision_limit: Union[RationalLikeMixedU, RealLike],\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self: HableT,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n        max_depth: None = None,\n        precision_limit: None = None,\n    ) -&gt; H:\n        ...\n\n    @deprecated\n    @beartype\n    def substitute(\n        self: HableT,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n        max_depth: Optional[IntegralLike] = None,\n        precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None,\n    ) -&gt; H:\nr\"\"\"\n        !!! warning \"Deprecated\"\n\n            This method has been deprecated and will be removed in a future release. See\n            the [``expandable`` decorator][dyce.evaluation.expandable] and\n            [``foreach`` function][dyce.evaluation.foreach] for more flexible\n            alternatives.\n\n        Shorthand for ``#!python self.h().substitute(expand, coalesce, max_depth)``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.substitute``][dyce.h.H.substitute].\n        \"\"\"\n        if max_depth is not None and precision_limit is not None:\n            raise ValueError(\"only one of max_depth and precision_limit is allowed\")\n        elif max_depth is not None:\n            return self.h().substitute(expand, coalesce, max_depth)\n        elif precision_limit is not None:\n            return self.h().substitute(\n                expand, coalesce, precision_limit=precision_limit\n            )\n        else:\n            return self.h().substitute(expand, coalesce)\n\n    @beartype\n    def within(self: HableT, lo: RealLike, hi: RealLike, other: _OperandT = 0) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.h().within(lo, hi, other)``. See the\n        [``h`` method][dyce.h.HableT.h] and [``H.within``][dyce.h.H.within].\n        \"\"\"\n        return self.h().within(lo, hi, other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__slots__","title":"<code>__slots__: Any = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.h/#dyce.h.HableOpsMixin.__abs__","title":"<code>__abs__() -&gt; H</code>","text":"<p>Shorthand for <code>operator.__abs__(self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __abs__(self: HableT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__abs__(self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __abs__(self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__add__","title":"<code>__add__(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__add__(self.h(), other)</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __add__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__add__(self.h(), other)``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __add__(self.h(), other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__and__","title":"<code>__and__(other: Union[SupportsInt, H, HableT]) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__and__(self.h(), other)</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __and__(self: HableT, other: Union[SupportsInt, H, HableT]) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__and__(self.h(), other)``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __and__(self.h(), other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__floordiv__","title":"<code>__floordiv__(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__floordiv__(self.h(), other)</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __floordiv__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__floordiv__(self.h(), other)``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __floordiv__(self.h(), other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__init__","title":"<code>__init__()</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>def __init__(self):\n    object.__init__(self)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__invert__","title":"<code>__invert__() -&gt; H</code>","text":"<p>Shorthand for <code>operator.__invert__(self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __invert__(self: HableT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__invert__(self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __invert__(self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__mod__","title":"<code>__mod__(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__mod__(self.h(), other)</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __mod__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__mod__(self.h(), other)``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __mod__(self.h(), other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__mul__","title":"<code>__mul__(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__mul__(self.h(), other)</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __mul__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__mul__(self.h(), other)``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __mul__(self.h(), other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__neg__","title":"<code>__neg__() -&gt; H</code>","text":"<p>Shorthand for <code>operator.__neg__(self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __neg__(self: HableT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__neg__(self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __neg__(self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__or__","title":"<code>__or__(other: Union[SupportsInt, H, HableT]) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__or__(self.h(), other)</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __or__(self: HableT, other: Union[SupportsInt, H, HableT]) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__or__(self.h(), other)``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __or__(self.h(), other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__pos__","title":"<code>__pos__() -&gt; H</code>","text":"<p>Shorthand for <code>operator.__pos__(self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __pos__(self: HableT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__pos__(self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __pos__(self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__pow__","title":"<code>__pow__(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__pow__(self.h(), other)</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __pow__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__pow__(self.h(), other)``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __pow__(self.h(), other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__radd__","title":"<code>__radd__(other: RealLike) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__add__(other, self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __radd__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__add__(other, self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __add__(other, self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__rand__","title":"<code>__rand__(other: SupportsInt) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__and__(other, self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rand__(self: HableT, other: SupportsInt) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__and__(other, self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __and__(other, self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__rfloordiv__","title":"<code>__rfloordiv__(other: RealLike) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__floordiv__(other, self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rfloordiv__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__floordiv__(other, self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __floordiv__(other, self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__rmod__","title":"<code>__rmod__(other: RealLike) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__mod__(other, self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rmod__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__mod__(other, self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __mod__(other, self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__rmul__","title":"<code>__rmul__(other: RealLike) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__mul__(other, self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rmul__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__mul__(other, self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __mul__(other, self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__ror__","title":"<code>__ror__(other: SupportsInt) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__or__(other, self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __ror__(self: HableT, other: SupportsInt) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__or__(other, self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __or__(other, self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__rpow__","title":"<code>__rpow__(other: RealLike) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__pow__(other, self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rpow__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__pow__(other, self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __pow__(other, self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__rsub__","title":"<code>__rsub__(other: RealLike) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__sub__(other, self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rsub__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__sub__(other, self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __sub__(other, self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__rtruediv__","title":"<code>__rtruediv__(other: RealLike) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__truediv__(other, self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rtruediv__(self: HableT, other: RealLike) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__truediv__(other, self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __truediv__(other, self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__rxor__","title":"<code>__rxor__(other: SupportsInt) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__xor__(other, self.h())</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rxor__(self: HableT, other: SupportsInt) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__xor__(other, self.h())``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __xor__(other, self.h())\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__sub__","title":"<code>__sub__(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__sub__(self.h(), other)</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __sub__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__sub__(self.h(), other)``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __sub__(self.h(), other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__truediv__","title":"<code>__truediv__(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__truediv__(self.h(), other)</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __truediv__(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__truediv__(self.h(), other)``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __truediv__(self.h(), other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.__xor__","title":"<code>__xor__(other: Union[SupportsInt, H, HableT]) -&gt; H</code>","text":"<p>Shorthand for <code>operator.__xor__(self.h(), other)</code>. See the <code>h</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __xor__(self: HableT, other: Union[SupportsInt, H, HableT]) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python operator.__xor__(self.h(), other)``. See the\n    [``h`` method][dyce.h.HableT.h].\n    \"\"\"\n    return __xor__(self.h(), other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.eq","title":"<code>eq(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.h().eq(other)</code>. See the <code>h</code> method and <code>H.eq</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef eq(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.h().eq(other)``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.eq``][dyce.h.H.eq].\n    \"\"\"\n    return self.h().eq(other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.explode","title":"<code>explode(max_depth: Optional[IntegralLike] = None, precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None) -&gt; H</code>","text":"<p>Shorthand for <code>self.h().explode(max_depth, precision_limit)</code>. See the <code>h</code> method and <code>H.explode</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef explode(\n    self: HableT,\n    max_depth: Optional[IntegralLike] = None,\n    precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None,\n) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.h().explode(max_depth, precision_limit)``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.explode``][dyce.h.H.explode].\n    \"\"\"\n    if max_depth is not None and precision_limit is not None:\n        raise ValueError(\"only one of max_depth and precision_limit is allowed\")\n    elif max_depth is not None:\n        return self.h().explode(max_depth)\n    elif precision_limit is not None:\n        return self.h().explode(precision_limit=precision_limit)\n    else:\n        return self.h().explode()\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.ge","title":"<code>ge(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.h().ge(other)</code>. See the <code>h</code> method and <code>H.ge</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef ge(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.h().ge(other)``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.ge``][dyce.h.H.ge].\n    \"\"\"\n    return self.h().ge(other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.gt","title":"<code>gt(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.h().gt(other)</code>. See the <code>h</code> method and <code>H.gt</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef gt(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.h().gt(other)``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.gt``][dyce.h.H.gt].\n    \"\"\"\n    return self.h().gt(other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.is_even","title":"<code>is_even() -&gt; H</code>","text":"<p>Shorthand for <code>self.h().is_even()</code>. See the <code>h</code> method and <code>H.is_even</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef is_even(self: HableT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.h().is_even()``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.is_even``][dyce.h.H.is_even].\n    \"\"\"\n    return self.h().is_even()\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.is_odd","title":"<code>is_odd() -&gt; H</code>","text":"<p>Shorthand for <code>self.h().is_odd()</code>. See the <code>h</code> method and <code>H.is_odd</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef is_odd(self: HableT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.h().is_odd()``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.is_odd``][dyce.h.H.is_odd].\n    \"\"\"\n    return self.h().is_odd()\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.le","title":"<code>le(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.h().le(other)</code>. See the <code>h</code> method and <code>H.le</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef le(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.h().le(other)``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.le``][dyce.h.H.le].\n    \"\"\"\n    return self.h().le(other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.lt","title":"<code>lt(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.h().lt(other)</code>. See the <code>h</code> method and <code>H.lt</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef lt(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.h().lt(other)``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.lt``][dyce.h.H.lt].\n    \"\"\"\n    return self.h().lt(other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.ne","title":"<code>ne(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.h().ne(other)</code>. See the <code>h</code> method and <code>H.ne</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef ne(self: HableT, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.h().ne(other)``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.ne``][dyce.h.H.ne].\n    \"\"\"\n    return self.h().ne(other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.substitute","title":"<code>substitute(expand: _SubstituteExpandCallbackT, coalesce: _SubstituteCoalesceCallbackT = coalesce_replace, max_depth: Optional[IntegralLike] = None, precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None) -&gt; H</code>","text":"<p>Deprecated</p> <p>This method has been deprecated and will be removed in a future release. See the <code>expandable</code> decorator and <code>foreach</code> function for more flexible alternatives.</p> <p>Shorthand for <code>self.h().substitute(expand, coalesce, max_depth)</code>. See the <code>h</code> method and <code>H.substitute</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@deprecated\n@beartype\ndef substitute(\n    self: HableT,\n    expand: _SubstituteExpandCallbackT,\n    coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n    max_depth: Optional[IntegralLike] = None,\n    precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None,\n) -&gt; H:\nr\"\"\"\n    !!! warning \"Deprecated\"\n\n        This method has been deprecated and will be removed in a future release. See\n        the [``expandable`` decorator][dyce.evaluation.expandable] and\n        [``foreach`` function][dyce.evaluation.foreach] for more flexible\n        alternatives.\n\n    Shorthand for ``#!python self.h().substitute(expand, coalesce, max_depth)``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.substitute``][dyce.h.H.substitute].\n    \"\"\"\n    if max_depth is not None and precision_limit is not None:\n        raise ValueError(\"only one of max_depth and precision_limit is allowed\")\n    elif max_depth is not None:\n        return self.h().substitute(expand, coalesce, max_depth)\n    elif precision_limit is not None:\n        return self.h().substitute(\n            expand, coalesce, precision_limit=precision_limit\n        )\n    else:\n        return self.h().substitute(expand, coalesce)\n</code></pre>"},{"location":"dyce.h/#dyce.h.HableOpsMixin.within","title":"<code>within(lo: RealLike, hi: RealLike, other: _OperandT = 0) -&gt; H</code>","text":"<p>Shorthand for <code>self.h().within(lo, hi, other)</code>. See the <code>h</code> method and <code>H.within</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef within(self: HableT, lo: RealLike, hi: RealLike, other: _OperandT = 0) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.h().within(lo, hi, other)``. See the\n    [``h`` method][dyce.h.HableT.h] and [``H.within``][dyce.h.H.within].\n    \"\"\"\n    return self.h().within(lo, hi, other)\n</code></pre>"},{"location":"dyce.h/#dyce.h.coalesce_replace","title":"<code>coalesce_replace(h: H, outcome: RealLike) -&gt; H</code>","text":"<p>Deprecated</p> <p>This function has been deprecated and will be removed in a future release. See the <code>expandable</code> decorator and <code>foreach</code> function for more flexible alternatives.</p> <p>Default behavior for <code>H.substitute</code>. Returns h unmodified (outcome is ignored).</p> Source code in <code>dyce/h.py</code> <pre><code>@deprecated\ndef coalesce_replace(h: H, outcome: RealLike) -&gt; H:\nr\"\"\"\n    !!! warning \"Deprecated\"\n\n        This function has been deprecated and will be removed in a future release. See\n        the [``expandable`` decorator][dyce.evaluation.expandable] and\n        [``foreach`` function][dyce.evaluation.foreach] for more flexible alternatives.\n\n    Default behavior for [``H.substitute``][dyce.h.H.substitute]. Returns *h* unmodified\n    (*outcome* is ignored).\n    \"\"\"\n    return h\n</code></pre>"},{"location":"dyce.h/#dyce.h.resolve_dependent_probability","title":"<code>resolve_dependent_probability(dependent_term: Callable[..., HOrOutcomeT], **independent_sources: _SourceT) -&gt; H</code>","text":"<p>Deprecated</p> <p>This function has been moved to the <code>H.foreach</code> class method. This alias will be removed in a future release.</p> <p>Shorthand for <code>H.foreach(dependent_term, **independent_sources)</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@deprecated\ndef resolve_dependent_probability(\n    dependent_term: Callable[..., HOrOutcomeT],\n    **independent_sources: _SourceT,\n) -&gt; H:\nr\"\"\"\n    !!! warning \"Deprecated\"\n\n        This function has been moved to the [``H.foreach``][dyce.h.H.foreach] class\n        method. This alias will be removed in a future release.\n\n    Shorthand for ``#!python H.foreach(dependent_term, **independent_sources)``.\n    \"\"\"\n    return H.foreach(dependent_term, **independent_sources)\n</code></pre>"},{"location":"dyce.h/#dyce.h.sum_h","title":"<code>sum_h(hs: Iterable[H])</code>","text":"<p>Shorthand for <code>H({}) if h_sum == 0 else sum(hs)</code>.</p> <p>This is to ensure that summing zero or more histograms always returns a histogram.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef sum_h(hs: Iterable[H]):\n\"\"\"\n    Shorthand for ``#!python H({}) if h_sum == 0 else sum(hs)``.\n\n    This is to ensure that summing zero or more histograms always returns a histogram.\n    \"\"\"\n    h_sum = sum(hs)\n\n    return H({}) if h_sum == 0 else h_sum\n</code></pre>"},{"location":"dyce/","title":"<tt>dyce</tt>","text":""},{"location":"dyce/#dyce-package-reference","title":"<code>dyce</code> package reference","text":"<p><code>dyce</code> revolves around two core primitives. <code>H</code> objects are histograms (outcomes or individual dice). <code>P</code> objects are collections of histograms (pools).</p> <p>Additionally, the <code>dyce.evaluation</code> package provides the <code>expandable</code> decorator, which is useful for substitutions, explosions, and modeling arbitrarily complex computations with dependent terms. It also provides <code>foreach</code> and <code>explode</code> as convenient shorthands. The <code>dyce.r</code> package provides scalars, histograms, pools, operators, etc. for assembling reusable roller trees.</p>"},{"location":"dyce/#dyce.h.H","title":"<code>H</code>","text":"<p>             Bases: <code>_MappingT</code></p> <p>An immutable mapping for use as a histogram which supports arithmetic operations. This is useful for modeling discrete outcomes, like individual dice. <code>H</code> objects encode finite discrete probability distributions as integer counts without any denominator.</p> <p>Info</p> <p>The lack of an explicit denominator is intentional and has two benefits. First, a denominator is redundant. Without it, one never has to worry about probabilities summing to one (e.g., via miscalculation, floating point error, etc.). Second (and perhaps more importantly), sometimes one wants to have an insight into non-reduced counts, not just probabilities. If needed, probabilities can always be derived, as shown below.</p> <p>The initializer takes a single parameter, items. In its most explicit form, items maps outcome values to counts.</p> <p>Modeling a single six-sided die (<code>1d6</code>) can be expressed as:</p> <pre><code>&gt;&gt;&gt; from dyce import H\n&gt;&gt;&gt; d6 = H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})\n</code></pre> <p>An iterable of pairs can also be used (similar to <code>dict</code>).</p> <pre><code>&gt;&gt;&gt; d6 == H(((1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1)))\nTrue\n</code></pre> <p>Two shorthands are provided. If items is an iterable of numbers, counts of 1 are assumed.</p> <pre><code>&gt;&gt;&gt; d6 == H((1, 2, 3, 4, 5, 6))\nTrue\n</code></pre> <p>Repeated items are accumulated, as one would expect.</p> <pre><code>&gt;&gt;&gt; H((2, 3, 3, 4, 4, 5))\nH({2: 1, 3: 2, 4: 2, 5: 1})\n</code></pre> <p>If items is an integer, it is shorthand for creating a sequential range \\([{1} .. {items}]\\) (or \\([{items} .. {-1}]\\) if items is negative).</p> <pre><code>&gt;&gt;&gt; d6 == H(6)\nTrue\n</code></pre> <p>Histograms are maps, so we can test equivalence against other maps.</p> <pre><code>&gt;&gt;&gt; H(6) == {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}\nTrue\n</code></pre> <p>Simple indexes can be used to look up an outcome\u2019s count.</p> <pre><code>&gt;&gt;&gt; H((2, 3, 3, 4, 4, 5))[3]\n2\n</code></pre> <p>Most arithmetic operators are supported and do what one would expect. If the operand is a number, the operator applies to the outcomes.</p> <pre><code>&gt;&gt;&gt; d6 + 4\nH({5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1})\n</code></pre> <pre><code>&gt;&gt;&gt; d6 * -1\nH({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1})\n&gt;&gt;&gt; d6 * -1 == -d6\nTrue\n&gt;&gt;&gt; d6 * -1 == H(-6)\nTrue\n</code></pre> <p>If the operand is another histogram, combinations are computed. Modeling the sum of two six-sided dice (<code>2d6</code>) can be expressed as:</p> <pre><code>&gt;&gt;&gt; d6 + d6\nH({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n&gt;&gt;&gt; print((d6 + d6).format())\navg |    7.00\nstd |    2.42\nvar |    5.83\n  2 |   2.78% |#\n  3 |   5.56% |##\n  4 |   8.33% |####\n  5 |  11.11% |#####\n  6 |  13.89% |######\n  7 |  16.67% |########\n  8 |  13.89% |######\n  9 |  11.11% |#####\n 10 |   8.33% |####\n 11 |   5.56% |##\n 12 |   2.78% |#\n</code></pre> <p>To sum \\({n}\\) identical histograms, the matrix multiplication operator (<code>@</code>) provides a shorthand.</p> <pre><code>&gt;&gt;&gt; 3@d6 == d6 + d6 + d6\nTrue\n</code></pre> <p>The <code>len</code> built-in function can be used to show the number of distinct outcomes.</p> <pre><code>&gt;&gt;&gt; len(2@d6)\n11\n</code></pre> <p>The <code>total</code> property can be used to compute the total number of combinations and each outcome\u2019s probability.</p> <pre><code>&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; (2@d6).total\n36\n&gt;&gt;&gt; [(outcome, Fraction(count, (2@d6).total)) for outcome, count in (2@d6).items()]\n[(2, Fraction(1, 36)), (3, Fraction(1, 18)), (4, Fraction(1, 12)), (5, Fraction(1, 9)), (6, Fraction(5, 36)), (7, Fraction(1, 6)), ..., (12, Fraction(1, 36))]\n</code></pre> <p>Histograms provide common comparators (e.g., <code>eq</code> <code>ne</code>, etc.). One way to count how often a first six-sided die shows a different face than a second is:</p> <pre><code>&gt;&gt;&gt; d6.ne(d6)\nH({False: 6, True: 30})\n&gt;&gt;&gt; print(d6.ne(d6).format())\navg |    0.83\nstd |    0.37\nvar |    0.14\n  0 |  16.67% |########\n  1 |  83.33% |#########################################\n</code></pre> <p>Or, how often a first six-sided die shows a face less than a second is:</p> <pre><code>&gt;&gt;&gt; d6.lt(d6)\nH({False: 21, True: 15})\n&gt;&gt;&gt; print(d6.lt(d6).format())\navg |    0.42\nstd |    0.49\nvar |    0.24\n  0 |  58.33% |#############################\n  1 |  41.67% |####################\n</code></pre> <p>Or how often at least one <code>2</code> will show when rolling four six-sided dice:</p> <pre><code>&gt;&gt;&gt; d6_eq2 = d6.eq(2) ; d6_eq2  # how often a 2 shows on a single six-sided die\nH({False: 5, True: 1})\n&gt;&gt;&gt; 4@d6_eq2  # count of 2s showing on 4d6\nH({0: 625, 1: 500, 2: 150, 3: 20, 4: 1})\n&gt;&gt;&gt; (4@d6_eq2).ge(1)  # how often that count is at least one\nH({False: 625, True: 671})\n&gt;&gt;&gt; print((4@d6_eq2).ge(1).format())\navg |    0.52\nstd |    0.50\nvar |    0.25\n  0 |  48.23% |########################\n  1 |  51.77% |#########################\n</code></pre> <p>Mind your parentheses</p> <p>Parentheses are often necessary to enforce the desired order of operations. This is most often an issue with the <code>@</code> operator, because it behaves differently than the <code>d</code> operator in most dedicated grammars. More specifically, in Python, <code>@</code> has a lower precedence than <code>.</code> and <code>[\u2026]</code>.</p> <pre><code>&gt;&gt;&gt; 2@d6[7]  # type: ignore [operator]\nTraceback (most recent call last):\n  ...\nKeyError: 7\n&gt;&gt;&gt; 2@d6.le(7)  # probably not what was intended\nH({2: 36})\n&gt;&gt;&gt; 2@d6.le(7) == 2@(d6.le(7))\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; (2@d6)[7]\n6\n&gt;&gt;&gt; (2@d6).le(7)\nH({False: 15, True: 21})\n&gt;&gt;&gt; 2@d6.le(7) == (2@d6).le(7)\nFalse\n</code></pre> <p>Counts are generally accumulated without reduction. To reduce, call the <code>lowest_terms</code> method.</p> <pre><code>&gt;&gt;&gt; d6.ge(4)\nH({False: 3, True: 3})\n&gt;&gt;&gt; d6.ge(4).lowest_terms()\nH({False: 1, True: 1})\n</code></pre> <p>Testing equivalence implicitly performs reductions of operands.</p> <pre><code>&gt;&gt;&gt; d6.ge(4) == d6.ge(4).lowest_terms()\nTrue\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>class H(_MappingT):\nr\"\"\"\n    An immutable mapping for use as a histogram which supports arithmetic operations.\n    This is useful for modeling discrete outcomes, like individual dice. ``#!python H``\n    objects encode finite discrete probability distributions as integer counts without\n    any denominator.\n\n    !!! info\n\n        The lack of an explicit denominator is intentional and has two benefits. First,\n        a denominator is redundant. Without it, one never has to worry about\n        probabilities summing to one (e.g., via miscalculation, floating point error,\n        etc.). Second (and perhaps more importantly), sometimes one wants to have an\n        insight into non-reduced counts, not just probabilities. If needed,\n        probabilities can always be derived, as shown below.\n\n    The [initializer][dyce.h.H.__init__] takes a single parameter, *items*. In its most\n    explicit form, *items* maps outcome values to counts.\n\n    Modeling a single six-sided die (``1d6``) can be expressed as:\n\n    ``` python\n    &gt;&gt;&gt; from dyce import H\n    &gt;&gt;&gt; d6 = H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})\n\n    ```\n\n    An iterable of pairs can also be used (similar to ``#!python dict``).\n\n    ``` python\n    &gt;&gt;&gt; d6 == H(((1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1)))\n    True\n\n    ```\n\n    Two shorthands are provided. If *items* is an iterable of numbers, counts of 1 are\n    assumed.\n\n    ``` python\n    &gt;&gt;&gt; d6 == H((1, 2, 3, 4, 5, 6))\n    True\n\n    ```\n\n    Repeated items are accumulated, as one would expect.\n\n    ``` python\n    &gt;&gt;&gt; H((2, 3, 3, 4, 4, 5))\n    H({2: 1, 3: 2, 4: 2, 5: 1})\n\n    ```\n\n    If *items* is an integer, it is shorthand for creating a sequential range $[{1} ..\n    {items}]$ (or $[{items} .. {-1}]$ if *items* is negative).\n\n    ``` python\n    &gt;&gt;&gt; d6 == H(6)\n    True\n\n    ```\n\n    Histograms are maps, so we can test equivalence against other maps.\n\n    ``` python\n    &gt;&gt;&gt; H(6) == {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}\n    True\n\n    ```\n\n    Simple indexes can be used to look up an outcome\u2019s count.\n\n    ``` python\n    &gt;&gt;&gt; H((2, 3, 3, 4, 4, 5))[3]\n    2\n\n    ```\n\n    Most arithmetic operators are supported and do what one would expect. If the operand\n    is a number, the operator applies to the outcomes.\n\n    ``` python\n    &gt;&gt;&gt; d6 + 4\n    H({5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1})\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; d6 * -1\n    H({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1})\n    &gt;&gt;&gt; d6 * -1 == -d6\n    True\n    &gt;&gt;&gt; d6 * -1 == H(-6)\n    True\n\n    ```\n\n    If the operand is another histogram, combinations are computed. Modeling the sum of\n    two six-sided dice (``2d6``) can be expressed as:\n\n    ``` python\n    &gt;&gt;&gt; d6 + d6\n    H({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n    &gt;&gt;&gt; print((d6 + d6).format())\n    avg |    7.00\n    std |    2.42\n    var |    5.83\n      2 |   2.78% |#\n      3 |   5.56% |##\n      4 |   8.33% |####\n      5 |  11.11% |#####\n      6 |  13.89% |######\n      7 |  16.67% |########\n      8 |  13.89% |######\n      9 |  11.11% |#####\n     10 |   8.33% |####\n     11 |   5.56% |##\n     12 |   2.78% |#\n\n    ```\n\n    To sum ${n}$ identical histograms, the matrix multiplication operator (``@``)\n    provides a shorthand.\n\n    ``` python\n    &gt;&gt;&gt; 3@d6 == d6 + d6 + d6\n    True\n\n    ```\n\n    The ``#!python len`` built-in function can be used to show the number of distinct\n    outcomes.\n\n    ``` python\n    &gt;&gt;&gt; len(2@d6)\n    11\n\n    ```\n\n    The [``total`` property][dyce.h.H.total] can be used to compute the total number of\n    combinations and each outcome\u2019s probability.\n\n    ``` python\n    &gt;&gt;&gt; from fractions import Fraction\n    &gt;&gt;&gt; (2@d6).total\n    36\n    &gt;&gt;&gt; [(outcome, Fraction(count, (2@d6).total)) for outcome, count in (2@d6).items()]\n    [(2, Fraction(1, 36)), (3, Fraction(1, 18)), (4, Fraction(1, 12)), (5, Fraction(1, 9)), (6, Fraction(5, 36)), (7, Fraction(1, 6)), ..., (12, Fraction(1, 36))]\n\n    ```\n\n    Histograms provide common comparators (e.g., [``eq``][dyce.h.H.eq]\n    [``ne``][dyce.h.H.ne], etc.). One way to count how often a first six-sided die\n    shows a different face than a second is:\n\n    ``` python\n    &gt;&gt;&gt; d6.ne(d6)\n    H({False: 6, True: 30})\n    &gt;&gt;&gt; print(d6.ne(d6).format())\n    avg |    0.83\n    std |    0.37\n    var |    0.14\n      0 |  16.67% |########\n      1 |  83.33% |#########################################\n\n    ```\n\n    Or, how often a first six-sided die shows a face less than a second is:\n\n    ``` python\n    &gt;&gt;&gt; d6.lt(d6)\n    H({False: 21, True: 15})\n    &gt;&gt;&gt; print(d6.lt(d6).format())\n    avg |    0.42\n    std |    0.49\n    var |    0.24\n      0 |  58.33% |#############################\n      1 |  41.67% |####################\n\n    ```\n\n    Or how often at least one ``#!python 2`` will show when rolling four six-sided dice:\n\n    ``` python\n    &gt;&gt;&gt; d6_eq2 = d6.eq(2) ; d6_eq2  # how often a 2 shows on a single six-sided die\n    H({False: 5, True: 1})\n    &gt;&gt;&gt; 4@d6_eq2  # count of 2s showing on 4d6\n    H({0: 625, 1: 500, 2: 150, 3: 20, 4: 1})\n    &gt;&gt;&gt; (4@d6_eq2).ge(1)  # how often that count is at least one\n    H({False: 625, True: 671})\n    &gt;&gt;&gt; print((4@d6_eq2).ge(1).format())\n    avg |    0.52\n    std |    0.50\n    var |    0.25\n      0 |  48.23% |########################\n      1 |  51.77% |#########################\n\n    ```\n\n    !!! bug \"Mind your parentheses\"\n\n        Parentheses are often necessary to enforce the desired order of operations. This\n        is most often an issue with the ``#!python @`` operator, because it behaves\n        differently than the ``d`` operator in most dedicated grammars. More\n        specifically, in Python, ``#!python @`` has a [lower\n        precedence](https://docs.python.org/3/reference/expressions.html#operator-precedence)\n        than ``#!python .`` and ``#!python [\u2026]``.\n\n        ``` python\n        &gt;&gt;&gt; 2@d6[7]  # type: ignore [operator]\n        Traceback (most recent call last):\n          ...\n        KeyError: 7\n        &gt;&gt;&gt; 2@d6.le(7)  # probably not what was intended\n        H({2: 36})\n        &gt;&gt;&gt; 2@d6.le(7) == 2@(d6.le(7))\n        True\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; (2@d6)[7]\n        6\n        &gt;&gt;&gt; (2@d6).le(7)\n        H({False: 15, True: 21})\n        &gt;&gt;&gt; 2@d6.le(7) == (2@d6).le(7)\n        False\n\n        ```\n\n    Counts are generally accumulated without reduction. To reduce, call the\n    [``lowest_terms`` method][dyce.h.H.lowest_terms].\n\n    ``` python\n    &gt;&gt;&gt; d6.ge(4)\n    H({False: 3, True: 3})\n    &gt;&gt;&gt; d6.ge(4).lowest_terms()\n    H({False: 1, True: 1})\n\n    ```\n\n    Testing equivalence implicitly performs reductions of operands.\n\n    ``` python\n    &gt;&gt;&gt; d6.ge(4) == d6.ge(4).lowest_terms()\n    True\n\n    ```\n    \"\"\"\n    __slots__: Any = (\n        \"_h\",\n        \"_hash\",\n        \"_lowest_terms\",\n        \"_order_stat_funcs_by_n\",\n        \"_total\",\n    )\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @beartype\n    def __init__(self, items: _SourceT) -&gt; None:\n        r\"Initializer.\"\n        super().__init__()\n        self._h: _MappingT\n\n        if isinstance(items, H):\n            self._h = items._h\n        elif isinstance(items, Mapping):\n            self._h = dict(\n                (outcome, as_int(count)) for outcome, count in sorted(items.items())\n            )\n        elif isinstance(items, SupportsInt):\n            if items == 0:\n                self._h = {}\n            else:\n                simple_init = as_int(items)\n                outcome_range = range(\n                    simple_init if simple_init &lt; 0 else 1,\n                    0 if simple_init &lt; 0 else simple_init + 1,\n                )\n\n                # if isinstance(items, RealLike):\n                #     outcome_type = type(items)\n                #     self._h = {outcome_type(i): 1 for i in outcome_range}\n                # else:\n                #     self._h = {i: 1 for i in outcome_range}\n                assert isinstance(items, RealLike)\n                outcome_type = type(items)\n                self._h = {outcome_type(i): 1 for i in outcome_range}\n        elif isinstance(items, HableT):\n            self._h = items.h()._h\n        elif isinstance(items, IterableC):\n            # items is either an Iterable[RealLike] or an Iterable[tuple[RealLike,\n            # SupportsInt]] (although this technically supports Iterable[RealLike |\n            # tuple[RealLike, SupportsInt]])\n            self._h = {}\n            sorted_items = list(items)\n\n            try:\n                sorted_items.sort()\n            except TypeError:\n                sorted_items.sort(key=natural_key)\n\n            # As of Python 3.7, insertion order of keys is preserved\n            for item in sorted_items:\n                if isinstance(item, tuple):\n                    outcome, count = item\n                    count = as_int(count)\n                else:\n                    outcome = item\n                    count = 1\n\n                if outcome not in self._h:\n                    self._h[outcome] = 0\n\n                self._h[outcome] += count\n        else:\n            raise TypeError(f\"unrecognized initializer type {items!r}\")\n\n        # We can't use something like functools.lru_cache for these values because those\n        # mechanisms call this object's __hash__ method which relies on both of these\n        # and we don't want a circular dependency when computing this object's hash.\n        self._hash: Optional[int] = None\n        self._total: int = sum(self._h.values())\n        self._lowest_terms: Optional[H] = None\n\n        # We don't use functools' caching mechanisms generally because they don't\n        # present a good mechanism for scoping the cache to object instances such that\n        # the cache will be purged when the object is deleted. functools.cached_property\n        # is an exception, but it requires that objects have proper __dict__ values,\n        # which Hs do not. So we basically do what functools.cached_property does, but\n        # without a __dict__.\n        self._order_stat_funcs_by_n: dict[int, Callable[[int], H]] = {}\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"{type(self).__name__}({dict.__repr__(self._h)})\"\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        if isinstance(other, HableT):\n            return __eq__(self, other.h())\n        elif isinstance(other, H):\n            return __eq__(self.lowest_terms()._h, other.lowest_terms()._h)\n        else:\n            return super().__eq__(other)\n\n    @beartype\n    def __ne__(self, other) -&gt; bool:\n        if isinstance(other, HableT):\n            return __ne__(self, other.h())\n        elif isinstance(other, H):\n            return not __eq__(self, other)\n        else:\n            return super().__ne__(other)\n\n    @beartype\n    def __hash__(self) -&gt; int:\n        if self._hash is None:\n            self._hash = hash(frozenset(self.lowest_terms().items()))\n\n        return self._hash\n\n    @beartype\n    def __bool__(self) -&gt; int:\n        return bool(self.total)\n\n    @beartype\n    def __len__(self) -&gt; int:\n        return len(self._h)\n\n    @beartype\n    def __getitem__(self, key: RealLike) -&gt; int:\n        return __getitem__(self._h, key)\n\n    @beartype\n    def __iter__(self) -&gt; Iterator[RealLike]:\n        return iter(self._h)\n\n    @beartype\n    def __reversed__(self) -&gt; Iterator[RealLike]:\n        return reversed(self._h)\n\n    @beartype\n    def __contains__(self, key: RealLike) -&gt; bool:  # type: ignore [override]\n        return key in self._h\n\n    @beartype\n    def __add__(self, other: _OperandT) -&gt; H:\n        try:\n            return self.map(__add__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __radd__(self, other: RealLike) -&gt; H:\n        try:\n            return self.rmap(other, __add__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __sub__(self, other: _OperandT) -&gt; H:\n        try:\n            return self.map(__sub__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rsub__(self, other: RealLike) -&gt; H:\n        try:\n            return self.rmap(other, __sub__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __mul__(self, other: _OperandT) -&gt; H:\n        try:\n            return self.map(__mul__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rmul__(self, other: RealLike) -&gt; H:\n        try:\n            return self.rmap(other, __mul__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __matmul__(self, other: SupportsInt) -&gt; H:\n        try:\n            other = as_int(other)\n        except TypeError:\n            return NotImplemented\n\n        if other &lt; 0:\n            raise ValueError(\"argument cannot be negative\")\n        else:\n            return sum_h(repeat(self, other))\n\n    @beartype\n    def __rmatmul__(self, other: SupportsInt) -&gt; H:\n        return self.__matmul__(other)\n\n    @beartype\n    def __truediv__(self, other: _OperandT) -&gt; H:\n        try:\n            return self.map(__truediv__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rtruediv__(self, other: RealLike) -&gt; H:\n        try:\n            return self.rmap(other, __truediv__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __floordiv__(self, other: _OperandT) -&gt; H:\n        try:\n            return self.map(__floordiv__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rfloordiv__(self, other: RealLike) -&gt; H:\n        try:\n            return self.rmap(other, __floordiv__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __mod__(self, other: _OperandT) -&gt; H:\n        try:\n            return self.map(__mod__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rmod__(self, other: RealLike) -&gt; H:\n        try:\n            return self.rmap(other, __mod__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __pow__(self, other: _OperandT) -&gt; H:\n        try:\n            return self.map(__pow__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rpow__(self, other: RealLike) -&gt; H:\n        try:\n            return self.rmap(other, __pow__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n    def __and__(self, other: Union[SupportsInt, \"H\", \"HableT\"]) -&gt; H:\n        try:\n            if isinstance(other, SupportsInt):\n                other = as_int(other)\n\n            return self.map(__and__, other)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    def __rand__(self, other: SupportsInt) -&gt; H:\n        try:\n            return self.rmap(as_int(other), __and__)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n    def __xor__(self, other: Union[SupportsInt, \"H\", \"HableT\"]) -&gt; H:\n        try:\n            if isinstance(other, SupportsInt):\n                other = as_int(other)\n\n            return self.map(__xor__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rxor__(self, other: SupportsInt) -&gt; H:\n        try:\n            return self.rmap(as_int(other), __xor__)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n    def __or__(self, other: Union[SupportsInt, \"H\", \"HableT\"]) -&gt; H:\n        try:\n            if isinstance(other, SupportsInt):\n                other = as_int(other)\n\n            return self.map(__or__, other)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    def __ror__(self, other: SupportsInt) -&gt; H:\n        try:\n            return self.rmap(as_int(other), __or__)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    def __neg__(self) -&gt; H:\n        return self.umap(__neg__)\n\n    @beartype\n    def __pos__(self) -&gt; H:\n        return self.umap(__pos__)\n\n    @beartype\n    def __abs__(self) -&gt; H:\n        return self.umap(__abs__)\n\n    @beartype\n    def __invert__(self) -&gt; H:\n        return self.umap(__invert__)\n\n    @beartype\n    def counts(self) -&gt; ValuesView[int]:\nr\"\"\"\n        More descriptive synonym for the [``values`` method][dyce.h.H.values].\n        \"\"\"\n        return self._h.values()\n\n    @beartype\n    def items(self) -&gt; ItemsView[RealLike, int]:\n        return self._h.items()\n\n    @beartype\n    def keys(self) -&gt; KeysView[RealLike]:\n        return self.outcomes()\n\n    @beartype\n    def outcomes(self) -&gt; KeysView[RealLike]:\nr\"\"\"\n        More descriptive synonym for the [``keys`` method][dyce.h.H.keys].\n        \"\"\"\n        return self._h.keys()\n\n    @beartype\n    def reversed(self) -&gt; Iterator[RealLike]:\n        return reversed(self)\n\n    @beartype\n    def values(self) -&gt; ValuesView[int]:\n        return self.counts()\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def total(self) -&gt; int:\nr\"\"\"\n        !!! warning \"Experimental\"\n\n            This property should be considered experimental and may change or disappear\n            in future versions.\n\n        Equivalent to ``#!python sum(self.counts())``.\n        \"\"\"\n        return self._total\n\n    # ---- Methods ---------------------------------------------------------------------\n\n    @classmethod\n    @deprecated\n    @beartype\n    def foreach(\n        cls,\n        dependent_term: Callable[..., HOrOutcomeT],\n        **independent_sources: _SourceT,\n    ) -&gt; H:\nr\"\"\"\n        !!! warning \"Deprecated\"\n\n            This method has been deprecated and will be removed in a future release. See\n            the [``expandable`` decorator][dyce.evaluation.expandable] and\n            [``foreach`` function][dyce.evaluation.foreach] for more flexible\n            alternatives.\n\n        Calls ``#!python dependent_term`` for each set of outcomes from the product of\n        ``independent_sources`` and accumulates the results. This is useful for\n        resolving dependent probabilities. Returned histograms are always reduced to\n        their lowest terms.\n\n        For example rolling a d20, re-rolling a ``#!python 1`` if it comes up, and\n        keeping the result might be expressed as[^1]:\n\n        [^1]:\n\n            This is primarily for illustration. [``H.substitute``][dyce.h.H.substitute]\n            is often better suited to cases involving re-rolling a single independent\n            term such as this one.\n\n        ``` python\n        &gt;&gt;&gt; d20 = H(20)\n\n        &gt;&gt;&gt; def reroll_one_dependent_term(d20_outcome):\n        ...   if d20_outcome == 1:\n        ...     return d20\n        ...   else:\n        ...     return d20_outcome\n\n        &gt;&gt;&gt; H.foreach(reroll_one_dependent_term, d20_outcome=d20)\n        H({1: 1, 2: 21, 3: 21, ..., 19: 21, 20: 21})\n\n        ```\n\n        The ``#!python foreach`` class method merely wraps *dependent_term* and calls\n        [``P.foreach``][dyce.p.P.foreach]. In doing so, it imposes a very modest\n        overhead that is negligible in most cases.\n\n        ``` python\n        --8&lt;-- \"docs/assets/perf_foreach.txt\"\n        ```\n\n        &lt;details&gt;\n        &lt;summary&gt;Source: &lt;a href=\"https://github.com/posita/dyce/blob/latest/docs/assets/perf_foreach.ipy\"&gt;&lt;code&gt;perf_foreach.ipy&lt;/code&gt;&lt;/a&gt;&lt;/summary&gt;\n\n        ``` python\n        --8&lt;-- \"docs/assets/perf_foreach.ipy\"\n        ```\n        &lt;/details&gt;\n        \"\"\"\n        from dyce import P\n\n        def _dependent_term(**roll_kw):\n            outcome_kw: dict[str, RealLike] = {}\n\n            for key, roll in roll_kw.items():\n                assert isinstance(roll, tuple)\n                assert len(roll) == 1\n                outcome_kw[key] = roll[0]\n\n            return dependent_term(**outcome_kw)\n\n        return P.foreach(_dependent_term, **independent_sources)\n\n    @beartype\n    def map(self, bin_op: _BinaryOperatorT, right_operand: _OperandT) -&gt; H:\nr\"\"\"\n        Applies *bin_op* to each outcome of the histogram as the left operand and\n        *right_operand* as the right. Shorthands exist for many arithmetic operators and\n        comparators.\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; d6 = H(6)\n        &gt;&gt;&gt; d6.map(operator.__add__, d6)\n        H({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n        &gt;&gt;&gt; d6.map(operator.__add__, d6) == d6 + d6\n        True\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; d6.map(operator.__pow__, 2)\n        H({1: 1, 4: 1, 9: 1, 16: 1, 25: 1, 36: 1})\n        &gt;&gt;&gt; d6.map(operator.__pow__, 2) == d6 ** 2\n        True\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; d6.map(operator.__gt__, 3)\n        H({False: 3, True: 3})\n        &gt;&gt;&gt; d6.map(operator.__gt__, 3) == d6.gt(3)\n        True\n\n        ```\n        \"\"\"\n        if isinstance(right_operand, HableT):\n            right_operand = right_operand.h()\n\n        if isinstance(right_operand, H):\n            return type(self)(\n                (bin_op(s, o), self[s] * right_operand[o])\n                for s, o in product(self, right_operand)\n            )\n        else:\n            return type(self)(\n                (bin_op(outcome, right_operand), count)\n                for outcome, count in self.items()\n            )\n\n    @beartype\n    def rmap(self, left_operand: RealLike, bin_op: _BinaryOperatorT) -&gt; H:\nr\"\"\"\n        Analogous to the [``map`` method][dyce.h.H.map], but where the caller supplies\n        *left_operand*.\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; d6 = H(6)\n        &gt;&gt;&gt; d6.rmap(2, operator.__pow__)\n        H({2: 1, 4: 1, 8: 1, 16: 1, 32: 1, 64: 1})\n        &gt;&gt;&gt; d6.rmap(2, operator.__pow__) == 2 ** d6\n        True\n\n        ```\n\n        !!! note\n\n            The positions of *left_operand* and *bin_op* are different from\n            [``map`` method][dyce.h.H.map]. This is intentional and serves as a reminder\n            of operand ordering.\n        \"\"\"\n        return type(self)(\n            (bin_op(left_operand, outcome), count) for outcome, count in self.items()\n        )\n\n    @beartype\n    def umap(self, un_op: _UnaryOperatorT) -&gt; H:\nr\"\"\"\n        Applies *un_op* to each outcome of the histogram.\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; H(6).umap(operator.__neg__)\n        H({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1})\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; H(4).umap(lambda outcome: (-outcome) ** outcome)\n        H({-27: 1, -1: 1, 4: 1, 256: 1})\n\n        ```\n        \"\"\"\n        return type(self)((un_op(outcome), count) for outcome, count in self.items())\n\n    @beartype\n    def lt(self, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.map(operator.__lt__, other).umap(bool)``.\n\n        ``` python\n        &gt;&gt;&gt; H(6).lt(3)\n        H({False: 4, True: 2})\n\n        ```\n\n        See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n        \"\"\"\n        return self.map(__lt__, other).umap(bool)\n\n    @beartype\n    def le(self, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.map(operator.__le__, other).umap(bool)``.\n\n        ``` python\n        &gt;&gt;&gt; H(6).le(3)\n        H({False: 3, True: 3})\n\n        ```\n\n        See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n        \"\"\"\n        return self.map(__le__, other).umap(bool)\n\n    @beartype\n    def eq(self, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.map(operator.__eq__, other).umap(bool)``.\n\n        ``` python\n        &gt;&gt;&gt; H(6).eq(3)\n        H({False: 5, True: 1})\n\n        ```\n\n        See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n        \"\"\"\n        return self.map(__eq__, other).umap(bool)\n\n    @beartype\n    def ne(self, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.map(operator.__ne__, other).umap(bool)``.\n\n        ``` python\n        &gt;&gt;&gt; H(6).ne(3)\n        H({False: 1, True: 5})\n\n        ```\n\n        See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n        \"\"\"\n        return self.map(__ne__, other).umap(bool)\n\n    @beartype\n    def gt(self, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.map(operator.__gt__, other).umap(bool)``.\n\n        ``` python\n        &gt;&gt;&gt; H(6).gt(3)\n        H({False: 3, True: 3})\n\n        ```\n\n        See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n        \"\"\"\n        return self.map(__gt__, other).umap(bool)\n\n    @beartype\n    def ge(self, other: _OperandT) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.map(operator.__ge__, other).umap(bool)``.\n\n        ``` python\n        &gt;&gt;&gt; H(6).ge(3)\n        H({False: 2, True: 4})\n\n        ```\n\n        See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n        \"\"\"\n        return self.map(__ge__, other).umap(bool)\n\n    @beartype\n    def is_even(self) -&gt; H:\nr\"\"\"\n        Equivalent to ``#!python self.umap(dyce.types.is_even)``.\n\n        ``` python\n        &gt;&gt;&gt; H((-4, -2, 0, 1, 2, 3)).is_even()\n        H({False: 2, True: 4})\n\n        ```\n\n        See the [``umap`` method][dyce.h.H.umap].\n        \"\"\"\n        return self.umap(is_even)\n\n    @beartype\n    def is_odd(self) -&gt; H:\nr\"\"\"\n        Equivalent to ``#!python self.umap(dyce.types.is_odd)``.\n\n        ``` python\n        &gt;&gt;&gt; H((-4, -2, 0, 1, 2, 3)).is_odd()\n        H({False: 4, True: 2})\n\n        ```\n\n        See the [``umap`` method][dyce.h.H.umap].\n        \"\"\"\n        return self.umap(is_odd)\n\n    @beartype\n    def accumulate(self, other: _SourceT) -&gt; H:\nr\"\"\"\n        Accumulates counts.\n\n        ``` python\n        &gt;&gt;&gt; H(4).accumulate(H(6))\n        H({1: 2, 2: 2, 3: 2, 4: 2, 5: 1, 6: 1})\n\n        ```\n        \"\"\"\n        if not isinstance(other, H):\n            other = H(other)\n\n        return type(self)(cast(_SourceT, chain(self.items(), other.items())))\n\n    @experimental\n    @beartype\n    def exactly_k_times_in_n(\n        self,\n        outcome: RealLike,\n        n: SupportsInt,\n        k: SupportsInt,\n    ) -&gt; int:\nr\"\"\"\n        !!! warning \"Experimental\"\n\n            This method should be considered experimental and may change or disappear in\n            future versions.\n\n        Computes (in constant time) and returns the number of times *outcome* appears\n        exactly *k* times among ``#!python n@self``. This is a more efficient\n        alternative to ``#!python (n@(self.eq(outcome)))[k]``.\n\n        ``` python\n        &gt;&gt;&gt; H(6).exactly_k_times_in_n(outcome=5, n=4, k=2)\n        150\n        &gt;&gt;&gt; H((2, 3, 3, 4, 4, 5)).exactly_k_times_in_n(outcome=2, n=3, k=3)\n        1\n        &gt;&gt;&gt; H((2, 3, 3, 4, 4, 5)).exactly_k_times_in_n(outcome=4, n=3, k=3)\n        8\n\n        ```\n        \"\"\"\n        n = as_int(n)\n        k = as_int(k)\n        assert k &lt;= n\n        c_outcome = self.get(outcome, 0)\n\n        return comb(n, k) * c_outcome**k * (self.total - c_outcome) ** (n - k)\n\n    @overload\n    def explode(\n        self,\n        max_depth: IntegralLike,\n        precision_limit: None = None,\n    ) -&gt; H:\n        ...\n\n    @overload\n    def explode(\n        self,\n        max_depth: None,\n        precision_limit: Union[RationalLikeMixedU, RealLike],\n    ) -&gt; H:\n        ...\n\n    @overload\n    def explode(\n        self,\n        max_depth: None = None,\n        *,\n        precision_limit: Union[RationalLikeMixedU, RealLike],\n    ) -&gt; H:\n        ...\n\n    @overload\n    def explode(\n        self,\n        max_depth: None = None,\n        precision_limit: None = None,\n    ) -&gt; H:\n        ...\n\n    @deprecated\n    @beartype\n    def explode(\n        self,\n        max_depth: Optional[IntegralLike] = None,\n        precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None,\n    ) -&gt; H:\nr\"\"\"\n        !!! warning \"Deprecated\"\n\n            This method has been deprecated and will be removed in a future release. See\n            the [``explode`` function][dyce.evaluation.explode] for a more flexible\n            alternative.\n\n        Shorthand for ``#!python self.substitute(lambda h, outcome: outcome if len(h) == 1\n        else h if outcome == max(h) else outcome, operator.__add__, max_depth,\n        precision_limit)``.\n\n        ``` python\n        &gt;&gt;&gt; H(6).explode(max_depth=2)\n        H({1: 36, 2: 36, 3: 36, 4: 36, 5: 36, 7: 6, 8: 6, 9: 6, 10: 6, 11: 6, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1})\n\n        ```\n\n        This method guards against excessive recursion by returning ``#!python outcome``\n        if the passed histogram has only one face. See the [``substitute``\n        method][dyce.h.H.substitute].\n        \"\"\"\n\n        def _explode(h: H, outcome: RealLike) -&gt; HOrOutcomeT:\n            return outcome if len(h) == 1 else h if outcome == max(h) else outcome\n\n        if max_depth is not None and precision_limit is not None:\n            raise ValueError(\"only one of max_depth and precision_limit is allowed\")\n        elif max_depth is not None:\n            return self.substitute(_explode, __add__, max_depth)\n        elif precision_limit is not None:\n            return self.substitute(_explode, __add__, precision_limit=precision_limit)\n        else:\n            return self.substitute(_explode, __add__)\n\n    @beartype\n    def lowest_terms(self) -&gt; H:\nr\"\"\"\n        Computes and returns a histogram whose nonzero counts share a greatest\n        common divisor of 1.\n\n        ``` python\n        &gt;&gt;&gt; df_obscured = H({-2: 0, -1: 2, 0: 2, 1: 2, 2: 0})\n        &gt;&gt;&gt; df_obscured.lowest_terms()\n        H({-1: 1, 0: 1, 1: 1})\n\n        ```\n        \"\"\"\n        if self._lowest_terms is None:\n            counts_gcd = gcd(*self.counts())\n\n            if counts_gcd in (0, 1) and 0 not in self.counts():\n                self._lowest_terms = self\n            else:\n                self._lowest_terms = type(self)(\n                    (outcome, count // counts_gcd)\n                    for outcome, count in self.items()\n                    if count != 0\n                )\n\n        return self._lowest_terms\n\n    @experimental\n    @beartype\n    def order_stat_for_n_at_pos(self, n: SupportsInt, pos: SupportsInt) -&gt; H:\nr\"\"\"\n        !!! warning \"Experimental\"\n\n            This method should be considered experimental and may change or disappear in\n            future versions.\n\n        Computes the probability distribution for each outcome appearing in at *pos* for\n        *n* histograms. *pos* is a zero-based index.\n\n        ``` python\n        &gt;&gt;&gt; d6avg = H((2, 3, 3, 4, 4, 5))\n        &gt;&gt;&gt; d6avg.order_stat_for_n_at_pos(5, 3)  # counts where outcome appears in the fourth of five positions\n        H({2: 26, 3: 1432, 4: 4792, 5: 1526})\n\n        ```\n\n        The results show that, when rolling five six-sided \u201caveraging\u201d dice and sorting\n        each roll, there are 26 ways where ``#!python 2`` appears at the fourth (index\n        ``#!python 3``) position, 1432 ways where ``#!python 3`` appears at the fourth\n        position, etc. This can be verified independently using the computationally\n        expensive method of enumerating rolls and counting those that meet the criteria.\n\n        ``` python\n        &gt;&gt;&gt; from dyce import P\n        &gt;&gt;&gt; p_5d6avg = 5@P(d6avg)\n        &gt;&gt;&gt; sum(count for roll, count in p_5d6avg.rolls_with_counts() if roll[3] == 5)\n        1526\n\n        ```\n\n        Negative values for *pos* follow Python index semantics:\n\n        ``` python\n        &gt;&gt;&gt; d6 = H(6)\n        &gt;&gt;&gt; d6.order_stat_for_n_at_pos(6, 0) == d6.order_stat_for_n_at_pos(6, -6)\n        True\n        &gt;&gt;&gt; d6.order_stat_for_n_at_pos(6, 5) == d6.order_stat_for_n_at_pos(6, -1)\n        True\n\n        ```\n\n        This method caches computing the betas for *n* so they can be reused for varying\n        values of *pos* in subsequent calls.\n        \"\"\"\n        # See &lt;https://math.stackexchange.com/q/4173084/226394&gt; for motivation\n        n = as_int(n)\n        pos = as_int(pos)\n\n        if n not in self._order_stat_funcs_by_n:\n            self._order_stat_funcs_by_n[n] = self._order_stat_func_for_n(n)\n\n        if pos &lt; 0:\n            pos = n + pos\n\n        return self._order_stat_funcs_by_n[n](pos)\n\n    @beartype\n    def remove(self, outcome: RealLike) -&gt; H:\n        if outcome not in self:\n            return self\n\n        return type(self)(\n            (orig_outcome, count)\n            for orig_outcome, count in self.items()\n            if orig_outcome != outcome\n        )\n\n    @overload\n    def substitute(\n        self,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n        *,\n        max_depth: IntegralLike,\n        precision_limit: None = None,\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT,\n        max_depth: IntegralLike,\n        precision_limit: None = None,\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n        *,\n        max_depth: None,\n        precision_limit: Union[RationalLikeMixedU, RealLike],\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT,\n        max_depth: None,\n        precision_limit: Union[RationalLikeMixedU, RealLike],\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n        max_depth: None = None,\n        *,\n        precision_limit: Union[RationalLikeMixedU, RealLike],\n    ) -&gt; H:\n        ...\n\n    @overload\n    def substitute(\n        self,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n        max_depth: None = None,\n        precision_limit: None = None,\n    ) -&gt; H:\n        ...\n\n    @deprecated\n    @beartype\n    def substitute(\n        self,\n        expand: _SubstituteExpandCallbackT,\n        coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n        max_depth: Optional[IntegralLike] = None,\n        precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None,\n    ) -&gt; H:\nr\"\"\"\n        !!! warning \"Deprecated\"\n\n            This method has been deprecated and will be removed in a future release. See\n            the [``expandable`` decorator][dyce.evaluation.expandable] and\n            [``foreach`` function][dyce.evaluation.foreach] for more flexible\n            alternatives.\n\n        Calls *expand* on each outcome. If *expand* returns a single outcome, it\n        replaces the existing outcome. If it returns an [``H`` object][dyce.h.H],\n        evaluation is performed again (recursively) on that object until a limit (either\n        *max_depth* or *precision_limit*) is exhausted. *coalesce* is called on the\n        original outcome and the expanded histogram or outcome and the returned\n        histogram is \u201cfolded\u201d into result. The default behavior for *coalesce* is to\n        replace the outcome with the expanded histogram. Returned histograms are always\n        reduced to their lowest terms.\n\n        !!! note \"*coalesce* is not called unless *expand* returns a histogram\"\n\n            If *expand* returns a single outcome, it *always* replaces the existing\n            outcome. This is intentional. To return a single outcome, but trigger\n            *coalesce*, characterize that outcome as a single-sided die (e.g.,\n            ``#!python H({outcome: 1})``.\n\n        See the [``coalesce_replace``][dyce.h.coalesce_replace] and\n        [``lowest_terms``][dyce.h.H.lowest_terms] methods.\n\n        !!! tip \"Precision limits\"\n\n            The *max_depth* parameter is similar to an\n            [``expandable``][dyce.evaluation.expandable]-decorated function\u2019s limit\n            argument when given a whole number. The *precision_limit* parameter is\n            similar to an [``expandable``][dyce.evaluation.expandable]-decorated\n            function\u2019s limit argument being provided a fractional value. It is an error\n            to provide values for both *max_depth* and *precision_limit*.\n        \"\"\"\n        from .evaluation import HResult, LimitT, expandable\n\n        if max_depth is not None and precision_limit is not None:\n            raise ValueError(\"only one of max_depth and precision_limit is allowed\")\n\n        limit: Optional[LimitT] = (\n            max_depth if precision_limit is None else precision_limit\n        )\n\n        @expandable(sentinel=self)\n        def _expand(result: HResult) -&gt; HOrOutcomeT:\n            res = expand(result.h, result.outcome)\n\n            return coalesce(_expand(res), result.outcome) if isinstance(res, H) else res\n\n        return _expand(self, limit=limit)\n\n    @beartype\n    def vs(self, other: _OperandT) -&gt; H:\nr\"\"\"\n        Compares the histogram with *other*. -1 represents where *other* is greater. 0\n        represents where they are equal. 1 represents where *other* is less.\n\n        Shorthand for ``#!python self.within(0, 0, other)``.\n\n        ``` python\n        &gt;&gt;&gt; H(6).vs(H(4))\n        H({-1: 6, 0: 4, 1: 14})\n        &gt;&gt;&gt; H(6).vs(H(4)) == H(6).within(0, 0, H(4))\n        True\n\n        ```\n\n        See the [``within`` method][dyce.h.H.within].\n        \"\"\"\n        return self.within(0, 0, other)\n\n    @beartype\n    def within(self, lo: RealLike, hi: RealLike, other: _OperandT = 0) -&gt; H:\nr\"\"\"\n        Computes the difference between the histogram and *other*. -1 represents where that\n        difference is less than *lo*. 0 represents where that difference between *lo*\n        and *hi* (inclusive). 1 represents where that difference is greater than *hi*.\n\n        ``` python\n        &gt;&gt;&gt; d6_2 = 2@H(6)\n        &gt;&gt;&gt; d6_2.within(7, 9)\n        H({-1: 15, 0: 15, 1: 6})\n        &gt;&gt;&gt; print(d6_2.within(7, 9).format())\n        avg |   -0.25\n        std |    0.72\n        var |    0.52\n         -1 |  41.67% |####################\n          0 |  41.67% |####################\n          1 |  16.67% |########\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; d6_3, d8_2 = 3@H(6), 2@H(8)\n        &gt;&gt;&gt; d6_3.within(-1, 1, d8_2)  # 3d6 w/in 1 of 2d8\n        H({-1: 3500, 0: 3412, 1: 6912})\n        &gt;&gt;&gt; print(d6_3.within(-1, 1, d8_2).format())\n        avg |    0.25\n        std |    0.83\n        var |    0.69\n         -1 |  25.32% |############\n          0 |  24.68% |############\n          1 |  50.00% |#########################\n\n        ```\n        \"\"\"\n        return self.map(_within(lo, hi), other)\n\n    @beartype\n    def zero_fill(self, outcomes: Iterable[RealLike]) -&gt; H:\nr\"\"\"\n        Shorthand for ``#!python self.accumulate({outcome: 0 for outcome in\n        outcomes})``.\n\n        ``` python\n        &gt;&gt;&gt; H(4).zero_fill(H(8).outcomes())\n        H({1: 1, 2: 1, 3: 1, 4: 1, 5: 0, 6: 0, 7: 0, 8: 0})\n\n        ```\n        \"\"\"\n        return self.accumulate({outcome: 0 for outcome in outcomes})\n\n    @overload\n    def distribution(\n        self,\n    ) -&gt; Iterator[tuple[RealLike, Fraction]]:\n        ...\n\n    @overload\n    def distribution(\n        self,\n        rational_t: Callable[[int, int], _T],\n    ) -&gt; Iterator[tuple[RealLike, _T]]:\n        ...\n\n    @experimental\n    @beartype\n    def distribution(\n        self,\n        rational_t: Optional[Callable[[int, int], _T]] = None,\n    ) -&gt; Iterator[tuple[RealLike, _T]]:\nr\"\"\"\n        Presentation helper function returning an iterator for each outcome/count or\n        outcome/probability pair.\n\n        ``` python\n        &gt;&gt;&gt; h = H((1, 2, 3, 3, 4, 4, 5, 6))\n        &gt;&gt;&gt; list(h.distribution())\n        [(1, Fraction(1, 8)), (2, Fraction(1, 8)), (3, Fraction(1, 4)), (4, Fraction(1, 4)), (5, Fraction(1, 8)), (6, Fraction(1, 8))]\n        &gt;&gt;&gt; list(h.ge(3).distribution())\n        [(False, Fraction(1, 4)), (True, Fraction(3, 4))]\n\n        ```\n\n        !!! warning \"Experimental\"\n\n            The *rational_t* argument to this method should be considered experimental\n            and may change or disappear in future versions.\n\n        If provided, *rational_t* must be a callable that takes two ``#!python int``s (a\n        numerator and denominator) and returns an instance of a desired (but otherwise\n        arbitrary) type.\n\n        ``` python\n        &gt;&gt;&gt; list(h.distribution(rational_t=lambda n, d: f\"{n}/{d}\"))\n        [(1, '1/8'), (2, '1/8'), (3, '2/8'), (4, '2/8'), (5, '1/8'), (6, '1/8')]\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; import sympy\n        &gt;&gt;&gt; list(h.distribution(rational_t=sympy.Rational))\n        [(1, 1/8), (2, 1/8), (3, 1/4), (4, 1/4), (5, 1/8), (6, 1/8)]\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; import sage.rings.rational  # doctest: +SKIP\n        &gt;&gt;&gt; list(h.distribution(rational_t=lambda n, d: sage.rings.rational.Rational((n, d))))  # doctest: +SKIP\n        [(1, 1/8), (2, 1/8), (3, 1/4), (4, 1/4), (5, 1/8), (6, 1/8)]\n\n        ```\n\n        !!! note\n\n            The arguments passed to *rational_t* are not reduced to the lowest terms.\n\n        The *rational_t* argument is a convenience. Iteration or comprehension can be\n        used to accomplish something similar.\n\n        ``` python\n        &gt;&gt;&gt; [(outcome, f\"{probability.numerator}/{probability.denominator}\") for outcome, probability in (h).distribution()]\n        [(1, '1/8'), (2, '1/8'), (3, '1/4'), (4, '1/4'), (5, '1/8'), (6, '1/8')]\n\n        ```\n\n        Many number implementations can convert directly from ``#!python\n        fractions.Fraction``s.\n\n        ``` python\n        &gt;&gt;&gt; import sympy.abc\n        &gt;&gt;&gt; [(outcome, sympy.Rational(probability)) for outcome, probability in (h + sympy.abc.x).distribution()]\n        [(x + 1, 1/8), (x + 2, 1/8), (x + 3, 1/4), (x + 4, 1/4), (x + 5, 1/8), (x + 6, 1/8)]\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; import sage.rings.rational  # doctest: +SKIP\n        &gt;&gt;&gt; [(outcome, sage.rings.rational.Rational(probability)) for outcome, probability in h.distribution()]  # doctest: +SKIP\n        [(1, 1/6), (2, 1/6), (3, 1/3), (4, 1/3), (5, 1/6), (6, 1/6)]\n\n        ```\n        \"\"\"\n        if rational_t is None:\n            # TODO(posita): See &lt;https://github.com/python/mypy/issues/10854#issuecomment-1663057450&gt;\n            rational_t = Fraction  # type: ignore [assignment]\n            assert rational_t is not None\n\n        total = sum(self.values()) or 1\n\n        return (\n            (outcome, rational_t(self[outcome], total))\n            for outcome in sorted_outcomes(self)\n        )\n\n    @beartype\n    def distribution_xy(\n        self,\n    ) -&gt; tuple[tuple[RealLike, ...], tuple[float, ...]]:\nr\"\"\"\n        Presentation helper function returning an iterator for a \u201czipped\u201d arrangement of the\n        output from the [``distribution`` method][dyce.h.H.distribution] and ensures the\n        values are ``#!python float``s.\n\n        ``` python\n        &gt;&gt;&gt; list(H(6).distribution())\n        [(1, Fraction(1, 6)), (2, Fraction(1, 6)), (3, Fraction(1, 6)), (4, Fraction(1, 6)), (5, Fraction(1, 6)), (6, Fraction(1, 6))]\n        &gt;&gt;&gt; H(6).distribution_xy()\n        ((1, 2, 3, 4, 5, 6), (0.16666666, 0.16666666, 0.16666666, 0.16666666, 0.16666666, 0.16666666))\n\n        ```\n        \"\"\"\n        # TODO(posita): See &lt;https://github.com/python/typing/issues/193&gt;\n        return tuple(  # type: ignore [return-value]\n            zip(\n                *(\n                    (outcome, float(probability))\n                    for outcome, probability in self.distribution()\n                )\n            )\n        )\n\n    @beartype\n    def format(\n        self,\n        width: SupportsInt = _ROW_WIDTH,\n        scaled: bool = False,\n        tick: str = \"#\",\n        sep: str = os.linesep,\n    ) -&gt; str:\nr\"\"\"\n        Returns a formatted string representation of the histogram. If *width* is\n        greater than zero, a horizontal bar ASCII graph is printed using *tick* and\n        *sep* (which are otherwise ignored if *width* is zero or less).\n\n        ``` python\n        &gt;&gt;&gt; print(H(6).format(width=0))\n        {avg: 3.50, 1: 16.67%, 2: 16.67%, 3: 16.67%, 4: 16.67%, 5: 16.67%, 6: 16.67%}\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; print((2@H(6)).zero_fill(range(1, 21)).format(tick=\"@\"))\n        avg |    7.00\n        std |    2.42\n        var |    5.83\n          1 |   0.00% |\n          2 |   2.78% |@\n          3 |   5.56% |@@\n          4 |   8.33% |@@@@\n          5 |  11.11% |@@@@@\n          6 |  13.89% |@@@@@@\n          7 |  16.67% |@@@@@@@@\n          8 |  13.89% |@@@@@@\n          9 |  11.11% |@@@@@\n         10 |   8.33% |@@@@\n         11 |   5.56% |@@\n         12 |   2.78% |@\n         13 |   0.00% |\n         14 |   0.00% |\n         15 |   0.00% |\n         16 |   0.00% |\n         17 |   0.00% |\n         18 |   0.00% |\n         19 |   0.00% |\n         20 |   0.00% |\n\n        ```\n\n        If *scaled* is ``#!python True``, horizontal bars are scaled to *width*.\n\n        ``` python\n        &gt;&gt;&gt; h = (2@H(6)).ge(7)\n        &gt;&gt;&gt; print(f\"{' 65 chars wide --&gt;|':-&gt;65}\")\n        ---------------------------------------------- 65 chars wide --&gt;|\n        &gt;&gt;&gt; print(h.format(scaled=False))\n        avg |    0.58\n        std |    0.49\n        var |    0.24\n          0 |  41.67% |####################\n          1 |  58.33% |#############################\n        &gt;&gt;&gt; print(h.format(scaled=True))\n        avg |    0.58\n        std |    0.49\n        var |    0.24\n          0 |  41.67% |###################################\n          1 |  58.33% |##################################################\n\n        ```\n        \"\"\"\n        width = as_int(width)\n\n        # We convert various values herein to native ints and floats because number\n        # tower implementations sometimes neglect to implement __format__ properly (or\n        # at all). (I'm looking at you, sage.rings.\u2026!)\n        try:\n            mu: RealLike = float(self.mean())\n        except (OverflowError, TypeError):\n            mu = self.mean()\n\n        if width &lt;= 0:\n\n            def _parts() -&gt; Iterator[str]:\n                yield f\"avg: {mu:.2f}\"\n\n                for (\n                    outcome,\n                    probability,\n                ) in self.distribution():\n                    probability_f = float(probability)\n                    yield f\"{outcome}:{probability_f:7.2%}\"\n\n            return \"{\" + \", \".join(_parts()) + \"}\"\n        else:\n            w = width - 15\n\n            def _lines() -&gt; Iterator[str]:\n                try:\n                    yield f\"avg | {mu:7.2f}\"\n                    std = float(self.stdev(mu))\n                    var = float(self.variance(mu))\n                    yield f\"std | {std:7.2f}\"\n                    yield f\"var | {var:7.2f}\"\n                except (OverflowError, TypeError) as exc:\n                    warnings.warn(f\"{str(exc)}; mu: {mu}\")\n\n                if self:\n                    outcomes, probabilities = self.distribution_xy()\n                    tick_scale = max(probabilities) if scaled else 1.0\n\n                    for outcome, probability in zip(outcomes, probabilities):\n                        try:\n                            outcome_str = f\"{outcome: 3}\"\n                        except (TypeError, ValueError):\n                            outcome_str = str(outcome)\n                            outcome_str = f\"{outcome_str: &gt;3}\"\n\n                        ticks = tick * int(w * probability / tick_scale)\n                        probability_f = float(probability)\n                        yield f\"{outcome_str} | {probability_f:7.2%} |{ticks}\"\n\n            return sep.join(_lines())\n\n    @beartype\n    def mean(self) -&gt; RealLike:\nr\"\"\"\n        Returns the mean of the weighted outcomes (or 0.0 if there are no outcomes).\n        \"\"\"\n        numerator: float\n        denominator: float\n        numerator = denominator = 0\n\n        for outcome, count in self.items():\n            numerator += outcome * count\n            denominator += count\n\n        return numerator / (denominator or 1)\n\n    @beartype\n    def stdev(self, mu: Optional[RealLike] = None) -&gt; RealLike:\nr\"\"\"\n        Shorthand for ``#!python math.sqrt(self.variance(mu))``.\n        \"\"\"\n        return sqrt(self.variance(mu))\n\n    @beartype\n    def variance(self, mu: Optional[RealLike] = None) -&gt; RealLike:\nr\"\"\"\n        Returns the variance of the weighted outcomes. If provided, *mu* is used as the mean\n        (to avoid duplicate computation).\n        \"\"\"\n        mu = mu if mu else self.mean()\n        numerator: float\n        denominator: float\n        numerator = denominator = 0\n\n        for outcome, count in self.items():\n            numerator += outcome**2 * count\n            denominator += count\n\n        # While floating point overflow is impossible to eliminate, we avoid it under\n        # some circumstances by exploiting the equivalence of E[(X - E[X])**2] and the\n        # more efficient E[X**2] - E[X]**2. See\n        # &lt;https://dlsun.github.io/probability/variance.html&gt;.\n        return numerator / (denominator or 1) - mu**2\n\n    @beartype\n    def roll(self) -&gt; RealLike:\nr\"\"\"\n        Returns a (weighted) random outcome, sorted.\n        \"\"\"\n        return (\n            rng.RNG.choices(\n                population=tuple(self.outcomes()),\n                weights=tuple(self.counts()),\n                k=1,\n            )[0]\n            if self\n            else 0\n        )\n\n    def _order_stat_func_for_n(self, n: int) -&gt; Callable[[int], H]:\n        betas_by_outcome: dict[RealLike, tuple[H, H]] = {}\n\n        for outcome in self.outcomes():\n            betas_by_outcome[outcome] = (\n                n @ self.le(outcome),\n                n @ self.lt(outcome),\n            )\n\n        def _gen_h_items_at_pos(pos: int) -&gt; Iterator[_OutcomeCountT]:\n            for outcome, (h_le, h_lt) in betas_by_outcome.items():\n                yield (\n                    outcome,\n                    h_le.gt(pos).get(True, 0) - h_lt.gt(pos).get(True, 0),\n                )\n\n        @beartype\n        def order_stat_for_n_at_pos(pos: int) -&gt; H:\n            return type(self)(_gen_h_items_at_pos(pos))\n\n        return order_stat_for_n_at_pos\n</code></pre>"},{"location":"dyce/#dyce.h.H.__slots__","title":"<code>__slots__: Any = ('_h', '_hash', '_lowest_terms', '_order_stat_funcs_by_n', '_total')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce/#dyce.h.H.total","title":"<code>total: int</code>  <code>property</code>","text":"<p>Experimental</p> <p>This property should be considered experimental and may change or disappear in future versions.</p> <p>Equivalent to <code>sum(self.counts())</code>.</p>"},{"location":"dyce/#dyce.h.H.__abs__","title":"<code>__abs__() -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __abs__(self) -&gt; H:\n    return self.umap(__abs__)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__add__","title":"<code>__add__(other: _OperandT) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __add__(self, other: _OperandT) -&gt; H:\n    try:\n        return self.map(__add__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__and__","title":"<code>__and__(other: Union[SupportsInt, 'H', 'HableT']) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\n# TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\ndef __and__(self, other: Union[SupportsInt, \"H\", \"HableT\"]) -&gt; H:\n    try:\n        if isinstance(other, SupportsInt):\n            other = as_int(other)\n\n        return self.map(__and__, other)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__bool__","title":"<code>__bool__() -&gt; int</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __bool__(self) -&gt; int:\n    return bool(self.total)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__contains__","title":"<code>__contains__(key: RealLike) -&gt; bool</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __contains__(self, key: RealLike) -&gt; bool:  # type: ignore [override]\n    return key in self._h\n</code></pre>"},{"location":"dyce/#dyce.h.H.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    if isinstance(other, HableT):\n        return __eq__(self, other.h())\n    elif isinstance(other, H):\n        return __eq__(self.lowest_terms()._h, other.lowest_terms()._h)\n    else:\n        return super().__eq__(other)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__floordiv__","title":"<code>__floordiv__(other: _OperandT) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __floordiv__(self, other: _OperandT) -&gt; H:\n    try:\n        return self.map(__floordiv__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__getitem__","title":"<code>__getitem__(key: RealLike) -&gt; int</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __getitem__(self, key: RealLike) -&gt; int:\n    return __getitem__(self._h, key)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __hash__(self) -&gt; int:\n    if self._hash is None:\n        self._hash = hash(frozenset(self.lowest_terms().items()))\n\n    return self._hash\n</code></pre>"},{"location":"dyce/#dyce.h.H.__init__","title":"<code>__init__(items: _SourceT) -&gt; None</code>","text":"<p>Initializer.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __init__(self, items: _SourceT) -&gt; None:\n    r\"Initializer.\"\n    super().__init__()\n    self._h: _MappingT\n\n    if isinstance(items, H):\n        self._h = items._h\n    elif isinstance(items, Mapping):\n        self._h = dict(\n            (outcome, as_int(count)) for outcome, count in sorted(items.items())\n        )\n    elif isinstance(items, SupportsInt):\n        if items == 0:\n            self._h = {}\n        else:\n            simple_init = as_int(items)\n            outcome_range = range(\n                simple_init if simple_init &lt; 0 else 1,\n                0 if simple_init &lt; 0 else simple_init + 1,\n            )\n\n            # if isinstance(items, RealLike):\n            #     outcome_type = type(items)\n            #     self._h = {outcome_type(i): 1 for i in outcome_range}\n            # else:\n            #     self._h = {i: 1 for i in outcome_range}\n            assert isinstance(items, RealLike)\n            outcome_type = type(items)\n            self._h = {outcome_type(i): 1 for i in outcome_range}\n    elif isinstance(items, HableT):\n        self._h = items.h()._h\n    elif isinstance(items, IterableC):\n        # items is either an Iterable[RealLike] or an Iterable[tuple[RealLike,\n        # SupportsInt]] (although this technically supports Iterable[RealLike |\n        # tuple[RealLike, SupportsInt]])\n        self._h = {}\n        sorted_items = list(items)\n\n        try:\n            sorted_items.sort()\n        except TypeError:\n            sorted_items.sort(key=natural_key)\n\n        # As of Python 3.7, insertion order of keys is preserved\n        for item in sorted_items:\n            if isinstance(item, tuple):\n                outcome, count = item\n                count = as_int(count)\n            else:\n                outcome = item\n                count = 1\n\n            if outcome not in self._h:\n                self._h[outcome] = 0\n\n            self._h[outcome] += count\n    else:\n        raise TypeError(f\"unrecognized initializer type {items!r}\")\n\n    # We can't use something like functools.lru_cache for these values because those\n    # mechanisms call this object's __hash__ method which relies on both of these\n    # and we don't want a circular dependency when computing this object's hash.\n    self._hash: Optional[int] = None\n    self._total: int = sum(self._h.values())\n    self._lowest_terms: Optional[H] = None\n\n    # We don't use functools' caching mechanisms generally because they don't\n    # present a good mechanism for scoping the cache to object instances such that\n    # the cache will be purged when the object is deleted. functools.cached_property\n    # is an exception, but it requires that objects have proper __dict__ values,\n    # which Hs do not. So we basically do what functools.cached_property does, but\n    # without a __dict__.\n    self._order_stat_funcs_by_n: dict[int, Callable[[int], H]] = {}\n</code></pre>"},{"location":"dyce/#dyce.h.H.__invert__","title":"<code>__invert__() -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __invert__(self) -&gt; H:\n    return self.umap(__invert__)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__iter__","title":"<code>__iter__() -&gt; Iterator[RealLike]</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __iter__(self) -&gt; Iterator[RealLike]:\n    return iter(self._h)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__len__","title":"<code>__len__() -&gt; int</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __len__(self) -&gt; int:\n    return len(self._h)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__matmul__","title":"<code>__matmul__(other: SupportsInt) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __matmul__(self, other: SupportsInt) -&gt; H:\n    try:\n        other = as_int(other)\n    except TypeError:\n        return NotImplemented\n\n    if other &lt; 0:\n        raise ValueError(\"argument cannot be negative\")\n    else:\n        return sum_h(repeat(self, other))\n</code></pre>"},{"location":"dyce/#dyce.h.H.__mod__","title":"<code>__mod__(other: _OperandT) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __mod__(self, other: _OperandT) -&gt; H:\n    try:\n        return self.map(__mod__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__mul__","title":"<code>__mul__(other: _OperandT) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __mul__(self, other: _OperandT) -&gt; H:\n    try:\n        return self.map(__mul__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__ne__","title":"<code>__ne__(other) -&gt; bool</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __ne__(self, other) -&gt; bool:\n    if isinstance(other, HableT):\n        return __ne__(self, other.h())\n    elif isinstance(other, H):\n        return not __eq__(self, other)\n    else:\n        return super().__ne__(other)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__neg__","title":"<code>__neg__() -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __neg__(self) -&gt; H:\n    return self.umap(__neg__)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__or__","title":"<code>__or__(other: Union[SupportsInt, 'H', 'HableT']) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\n# TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\ndef __or__(self, other: Union[SupportsInt, \"H\", \"HableT\"]) -&gt; H:\n    try:\n        if isinstance(other, SupportsInt):\n            other = as_int(other)\n\n        return self.map(__or__, other)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__pos__","title":"<code>__pos__() -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __pos__(self) -&gt; H:\n    return self.umap(__pos__)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__pow__","title":"<code>__pow__(other: _OperandT) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __pow__(self, other: _OperandT) -&gt; H:\n    try:\n        return self.map(__pow__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__radd__","title":"<code>__radd__(other: RealLike) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __radd__(self, other: RealLike) -&gt; H:\n    try:\n        return self.rmap(other, __add__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__rand__","title":"<code>__rand__(other: SupportsInt) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rand__(self, other: SupportsInt) -&gt; H:\n    try:\n        return self.rmap(as_int(other), __and__)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __repr__(self) -&gt; str:\n    return f\"{type(self).__name__}({dict.__repr__(self._h)})\"\n</code></pre>"},{"location":"dyce/#dyce.h.H.__reversed__","title":"<code>__reversed__() -&gt; Iterator[RealLike]</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __reversed__(self) -&gt; Iterator[RealLike]:\n    return reversed(self._h)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__rfloordiv__","title":"<code>__rfloordiv__(other: RealLike) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rfloordiv__(self, other: RealLike) -&gt; H:\n    try:\n        return self.rmap(other, __floordiv__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__rmatmul__","title":"<code>__rmatmul__(other: SupportsInt) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rmatmul__(self, other: SupportsInt) -&gt; H:\n    return self.__matmul__(other)\n</code></pre>"},{"location":"dyce/#dyce.h.H.__rmod__","title":"<code>__rmod__(other: RealLike) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rmod__(self, other: RealLike) -&gt; H:\n    try:\n        return self.rmap(other, __mod__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__rmul__","title":"<code>__rmul__(other: RealLike) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rmul__(self, other: RealLike) -&gt; H:\n    try:\n        return self.rmap(other, __mul__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__ror__","title":"<code>__ror__(other: SupportsInt) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __ror__(self, other: SupportsInt) -&gt; H:\n    try:\n        return self.rmap(as_int(other), __or__)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__rpow__","title":"<code>__rpow__(other: RealLike) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rpow__(self, other: RealLike) -&gt; H:\n    try:\n        return self.rmap(other, __pow__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__rsub__","title":"<code>__rsub__(other: RealLike) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rsub__(self, other: RealLike) -&gt; H:\n    try:\n        return self.rmap(other, __sub__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__rtruediv__","title":"<code>__rtruediv__(other: RealLike) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rtruediv__(self, other: RealLike) -&gt; H:\n    try:\n        return self.rmap(other, __truediv__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__rxor__","title":"<code>__rxor__(other: SupportsInt) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __rxor__(self, other: SupportsInt) -&gt; H:\n    try:\n        return self.rmap(as_int(other), __xor__)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__sub__","title":"<code>__sub__(other: _OperandT) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __sub__(self, other: _OperandT) -&gt; H:\n    try:\n        return self.map(__sub__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__truediv__","title":"<code>__truediv__(other: _OperandT) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef __truediv__(self, other: _OperandT) -&gt; H:\n    try:\n        return self.map(__truediv__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.__xor__","title":"<code>__xor__(other: Union[SupportsInt, 'H', 'HableT']) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\n# TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\ndef __xor__(self, other: Union[SupportsInt, \"H\", \"HableT\"]) -&gt; H:\n    try:\n        if isinstance(other, SupportsInt):\n            other = as_int(other)\n\n        return self.map(__xor__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.h.H.accumulate","title":"<code>accumulate(other: _SourceT) -&gt; H</code>","text":"<p>Accumulates counts.</p> <pre><code>&gt;&gt;&gt; H(4).accumulate(H(6))\nH({1: 2, 2: 2, 3: 2, 4: 2, 5: 1, 6: 1})\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef accumulate(self, other: _SourceT) -&gt; H:\nr\"\"\"\n    Accumulates counts.\n\n    ``` python\n    &gt;&gt;&gt; H(4).accumulate(H(6))\n    H({1: 2, 2: 2, 3: 2, 4: 2, 5: 1, 6: 1})\n\n    ```\n    \"\"\"\n    if not isinstance(other, H):\n        other = H(other)\n\n    return type(self)(cast(_SourceT, chain(self.items(), other.items())))\n</code></pre>"},{"location":"dyce/#dyce.h.H.counts","title":"<code>counts() -&gt; ValuesView[int]</code>","text":"<p>More descriptive synonym for the <code>values</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef counts(self) -&gt; ValuesView[int]:\nr\"\"\"\n    More descriptive synonym for the [``values`` method][dyce.h.H.values].\n    \"\"\"\n    return self._h.values()\n</code></pre>"},{"location":"dyce/#dyce.h.H.distribution","title":"<code>distribution(rational_t: Optional[Callable[[int, int], _T]] = None) -&gt; Iterator[tuple[RealLike, _T]]</code>","text":"<p>Presentation helper function returning an iterator for each outcome/count or outcome/probability pair.</p> <pre><code>&gt;&gt;&gt; h = H((1, 2, 3, 3, 4, 4, 5, 6))\n&gt;&gt;&gt; list(h.distribution())\n[(1, Fraction(1, 8)), (2, Fraction(1, 8)), (3, Fraction(1, 4)), (4, Fraction(1, 4)), (5, Fraction(1, 8)), (6, Fraction(1, 8))]\n&gt;&gt;&gt; list(h.ge(3).distribution())\n[(False, Fraction(1, 4)), (True, Fraction(3, 4))]\n</code></pre> <p>Experimental</p> <p>The rational_t argument to this method should be considered experimental and may change or disappear in future versions.</p> <p>If provided, rational_t must be a callable that takes two <code>int</code>s (a numerator and denominator) and returns an instance of a desired (but otherwise arbitrary) type.</p> <pre><code>&gt;&gt;&gt; list(h.distribution(rational_t=lambda n, d: f\"{n}/{d}\"))\n[(1, '1/8'), (2, '1/8'), (3, '2/8'), (4, '2/8'), (5, '1/8'), (6, '1/8')]\n</code></pre> <pre><code>&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; list(h.distribution(rational_t=sympy.Rational))\n[(1, 1/8), (2, 1/8), (3, 1/4), (4, 1/4), (5, 1/8), (6, 1/8)]\n</code></pre> <pre><code>&gt;&gt;&gt; import sage.rings.rational  # doctest: +SKIP\n&gt;&gt;&gt; list(h.distribution(rational_t=lambda n, d: sage.rings.rational.Rational((n, d))))  # doctest: +SKIP\n[(1, 1/8), (2, 1/8), (3, 1/4), (4, 1/4), (5, 1/8), (6, 1/8)]\n</code></pre> <p>Note</p> <p>The arguments passed to rational_t are not reduced to the lowest terms.</p> <p>The rational_t argument is a convenience. Iteration or comprehension can be used to accomplish something similar.</p> <pre><code>&gt;&gt;&gt; [(outcome, f\"{probability.numerator}/{probability.denominator}\") for outcome, probability in (h).distribution()]\n[(1, '1/8'), (2, '1/8'), (3, '1/4'), (4, '1/4'), (5, '1/8'), (6, '1/8')]\n</code></pre> <p>Many number implementations can convert directly from <code>fractions.Fraction</code>s.</p> <pre><code>&gt;&gt;&gt; import sympy.abc\n&gt;&gt;&gt; [(outcome, sympy.Rational(probability)) for outcome, probability in (h + sympy.abc.x).distribution()]\n[(x + 1, 1/8), (x + 2, 1/8), (x + 3, 1/4), (x + 4, 1/4), (x + 5, 1/8), (x + 6, 1/8)]\n</code></pre> <pre><code>&gt;&gt;&gt; import sage.rings.rational  # doctest: +SKIP\n&gt;&gt;&gt; [(outcome, sage.rings.rational.Rational(probability)) for outcome, probability in h.distribution()]  # doctest: +SKIP\n[(1, 1/6), (2, 1/6), (3, 1/3), (4, 1/3), (5, 1/6), (6, 1/6)]\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>@experimental\n@beartype\ndef distribution(\n    self,\n    rational_t: Optional[Callable[[int, int], _T]] = None,\n) -&gt; Iterator[tuple[RealLike, _T]]:\nr\"\"\"\n    Presentation helper function returning an iterator for each outcome/count or\n    outcome/probability pair.\n\n    ``` python\n    &gt;&gt;&gt; h = H((1, 2, 3, 3, 4, 4, 5, 6))\n    &gt;&gt;&gt; list(h.distribution())\n    [(1, Fraction(1, 8)), (2, Fraction(1, 8)), (3, Fraction(1, 4)), (4, Fraction(1, 4)), (5, Fraction(1, 8)), (6, Fraction(1, 8))]\n    &gt;&gt;&gt; list(h.ge(3).distribution())\n    [(False, Fraction(1, 4)), (True, Fraction(3, 4))]\n\n    ```\n\n    !!! warning \"Experimental\"\n\n        The *rational_t* argument to this method should be considered experimental\n        and may change or disappear in future versions.\n\n    If provided, *rational_t* must be a callable that takes two ``#!python int``s (a\n    numerator and denominator) and returns an instance of a desired (but otherwise\n    arbitrary) type.\n\n    ``` python\n    &gt;&gt;&gt; list(h.distribution(rational_t=lambda n, d: f\"{n}/{d}\"))\n    [(1, '1/8'), (2, '1/8'), (3, '2/8'), (4, '2/8'), (5, '1/8'), (6, '1/8')]\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; import sympy\n    &gt;&gt;&gt; list(h.distribution(rational_t=sympy.Rational))\n    [(1, 1/8), (2, 1/8), (3, 1/4), (4, 1/4), (5, 1/8), (6, 1/8)]\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; import sage.rings.rational  # doctest: +SKIP\n    &gt;&gt;&gt; list(h.distribution(rational_t=lambda n, d: sage.rings.rational.Rational((n, d))))  # doctest: +SKIP\n    [(1, 1/8), (2, 1/8), (3, 1/4), (4, 1/4), (5, 1/8), (6, 1/8)]\n\n    ```\n\n    !!! note\n\n        The arguments passed to *rational_t* are not reduced to the lowest terms.\n\n    The *rational_t* argument is a convenience. Iteration or comprehension can be\n    used to accomplish something similar.\n\n    ``` python\n    &gt;&gt;&gt; [(outcome, f\"{probability.numerator}/{probability.denominator}\") for outcome, probability in (h).distribution()]\n    [(1, '1/8'), (2, '1/8'), (3, '1/4'), (4, '1/4'), (5, '1/8'), (6, '1/8')]\n\n    ```\n\n    Many number implementations can convert directly from ``#!python\n    fractions.Fraction``s.\n\n    ``` python\n    &gt;&gt;&gt; import sympy.abc\n    &gt;&gt;&gt; [(outcome, sympy.Rational(probability)) for outcome, probability in (h + sympy.abc.x).distribution()]\n    [(x + 1, 1/8), (x + 2, 1/8), (x + 3, 1/4), (x + 4, 1/4), (x + 5, 1/8), (x + 6, 1/8)]\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; import sage.rings.rational  # doctest: +SKIP\n    &gt;&gt;&gt; [(outcome, sage.rings.rational.Rational(probability)) for outcome, probability in h.distribution()]  # doctest: +SKIP\n    [(1, 1/6), (2, 1/6), (3, 1/3), (4, 1/3), (5, 1/6), (6, 1/6)]\n\n    ```\n    \"\"\"\n    if rational_t is None:\n        # TODO(posita): See &lt;https://github.com/python/mypy/issues/10854#issuecomment-1663057450&gt;\n        rational_t = Fraction  # type: ignore [assignment]\n        assert rational_t is not None\n\n    total = sum(self.values()) or 1\n\n    return (\n        (outcome, rational_t(self[outcome], total))\n        for outcome in sorted_outcomes(self)\n    )\n</code></pre>"},{"location":"dyce/#dyce.h.H.distribution_xy","title":"<code>distribution_xy() -&gt; tuple[tuple[RealLike, ...], tuple[float, ...]]</code>","text":"<p>Presentation helper function returning an iterator for a \u201czipped\u201d arrangement of the output from the <code>distribution</code> method and ensures the values are <code>float</code>s.</p> <pre><code>&gt;&gt;&gt; list(H(6).distribution())\n[(1, Fraction(1, 6)), (2, Fraction(1, 6)), (3, Fraction(1, 6)), (4, Fraction(1, 6)), (5, Fraction(1, 6)), (6, Fraction(1, 6))]\n&gt;&gt;&gt; H(6).distribution_xy()\n((1, 2, 3, 4, 5, 6), (0.16666666, 0.16666666, 0.16666666, 0.16666666, 0.16666666, 0.16666666))\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef distribution_xy(\n    self,\n) -&gt; tuple[tuple[RealLike, ...], tuple[float, ...]]:\nr\"\"\"\n    Presentation helper function returning an iterator for a \u201czipped\u201d arrangement of the\n    output from the [``distribution`` method][dyce.h.H.distribution] and ensures the\n    values are ``#!python float``s.\n\n    ``` python\n    &gt;&gt;&gt; list(H(6).distribution())\n    [(1, Fraction(1, 6)), (2, Fraction(1, 6)), (3, Fraction(1, 6)), (4, Fraction(1, 6)), (5, Fraction(1, 6)), (6, Fraction(1, 6))]\n    &gt;&gt;&gt; H(6).distribution_xy()\n    ((1, 2, 3, 4, 5, 6), (0.16666666, 0.16666666, 0.16666666, 0.16666666, 0.16666666, 0.16666666))\n\n    ```\n    \"\"\"\n    # TODO(posita): See &lt;https://github.com/python/typing/issues/193&gt;\n    return tuple(  # type: ignore [return-value]\n        zip(\n            *(\n                (outcome, float(probability))\n                for outcome, probability in self.distribution()\n            )\n        )\n    )\n</code></pre>"},{"location":"dyce/#dyce.h.H.eq","title":"<code>eq(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.map(operator.__eq__, other).umap(bool)</code>.</p> <pre><code>&gt;&gt;&gt; H(6).eq(3)\nH({False: 5, True: 1})\n</code></pre> <p>See the <code>map</code> and <code>umap</code> methods.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef eq(self, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.map(operator.__eq__, other).umap(bool)``.\n\n    ``` python\n    &gt;&gt;&gt; H(6).eq(3)\n    H({False: 5, True: 1})\n\n    ```\n\n    See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n    \"\"\"\n    return self.map(__eq__, other).umap(bool)\n</code></pre>"},{"location":"dyce/#dyce.h.H.exactly_k_times_in_n","title":"<code>exactly_k_times_in_n(outcome: RealLike, n: SupportsInt, k: SupportsInt) -&gt; int</code>","text":"<p>Experimental</p> <p>This method should be considered experimental and may change or disappear in future versions.</p> <p>Computes (in constant time) and returns the number of times outcome appears exactly k times among <code>n@self</code>. This is a more efficient alternative to <code>(n@(self.eq(outcome)))[k]</code>.</p> <pre><code>&gt;&gt;&gt; H(6).exactly_k_times_in_n(outcome=5, n=4, k=2)\n150\n&gt;&gt;&gt; H((2, 3, 3, 4, 4, 5)).exactly_k_times_in_n(outcome=2, n=3, k=3)\n1\n&gt;&gt;&gt; H((2, 3, 3, 4, 4, 5)).exactly_k_times_in_n(outcome=4, n=3, k=3)\n8\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>@experimental\n@beartype\ndef exactly_k_times_in_n(\n    self,\n    outcome: RealLike,\n    n: SupportsInt,\n    k: SupportsInt,\n) -&gt; int:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This method should be considered experimental and may change or disappear in\n        future versions.\n\n    Computes (in constant time) and returns the number of times *outcome* appears\n    exactly *k* times among ``#!python n@self``. This is a more efficient\n    alternative to ``#!python (n@(self.eq(outcome)))[k]``.\n\n    ``` python\n    &gt;&gt;&gt; H(6).exactly_k_times_in_n(outcome=5, n=4, k=2)\n    150\n    &gt;&gt;&gt; H((2, 3, 3, 4, 4, 5)).exactly_k_times_in_n(outcome=2, n=3, k=3)\n    1\n    &gt;&gt;&gt; H((2, 3, 3, 4, 4, 5)).exactly_k_times_in_n(outcome=4, n=3, k=3)\n    8\n\n    ```\n    \"\"\"\n    n = as_int(n)\n    k = as_int(k)\n    assert k &lt;= n\n    c_outcome = self.get(outcome, 0)\n\n    return comb(n, k) * c_outcome**k * (self.total - c_outcome) ** (n - k)\n</code></pre>"},{"location":"dyce/#dyce.h.H.explode","title":"<code>explode(max_depth: Optional[IntegralLike] = None, precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None) -&gt; H</code>","text":"<p>Deprecated</p> <p>This method has been deprecated and will be removed in a future release. See the <code>explode</code> function for a more flexible alternative.</p> <p>Shorthand for <code>self.substitute(lambda h, outcome: outcome if len(h) == 1else h if outcome == max(h) else outcome, operator.__add__, max_depth,precision_limit)</code>.</p> <pre><code>&gt;&gt;&gt; H(6).explode(max_depth=2)\nH({1: 36, 2: 36, 3: 36, 4: 36, 5: 36, 7: 6, 8: 6, 9: 6, 10: 6, 11: 6, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1})\n</code></pre> <p>This method guards against excessive recursion by returning <code>outcome</code> if the passed histogram has only one face. See the <code>substitute</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@deprecated\n@beartype\ndef explode(\n    self,\n    max_depth: Optional[IntegralLike] = None,\n    precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None,\n) -&gt; H:\nr\"\"\"\n    !!! warning \"Deprecated\"\n\n        This method has been deprecated and will be removed in a future release. See\n        the [``explode`` function][dyce.evaluation.explode] for a more flexible\n        alternative.\n\n    Shorthand for ``#!python self.substitute(lambda h, outcome: outcome if len(h) == 1\n    else h if outcome == max(h) else outcome, operator.__add__, max_depth,\n    precision_limit)``.\n\n    ``` python\n    &gt;&gt;&gt; H(6).explode(max_depth=2)\n    H({1: 36, 2: 36, 3: 36, 4: 36, 5: 36, 7: 6, 8: 6, 9: 6, 10: 6, 11: 6, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1})\n\n    ```\n\n    This method guards against excessive recursion by returning ``#!python outcome``\n    if the passed histogram has only one face. See the [``substitute``\n    method][dyce.h.H.substitute].\n    \"\"\"\n\n    def _explode(h: H, outcome: RealLike) -&gt; HOrOutcomeT:\n        return outcome if len(h) == 1 else h if outcome == max(h) else outcome\n\n    if max_depth is not None and precision_limit is not None:\n        raise ValueError(\"only one of max_depth and precision_limit is allowed\")\n    elif max_depth is not None:\n        return self.substitute(_explode, __add__, max_depth)\n    elif precision_limit is not None:\n        return self.substitute(_explode, __add__, precision_limit=precision_limit)\n    else:\n        return self.substitute(_explode, __add__)\n</code></pre>"},{"location":"dyce/#dyce.h.H.foreach","title":"<code>foreach(dependent_term: Callable[..., HOrOutcomeT], **independent_sources: _SourceT) -&gt; H</code>  <code>classmethod</code>","text":"<p>Deprecated</p> <p>This method has been deprecated and will be removed in a future release. See the <code>expandable</code> decorator and <code>foreach</code> function for more flexible alternatives.</p> <p>Calls <code>dependent_term</code> for each set of outcomes from the product of <code>independent_sources</code> and accumulates the results. This is useful for resolving dependent probabilities. Returned histograms are always reduced to their lowest terms.</p> <p>For example rolling a d20, re-rolling a <code>1</code> if it comes up, and keeping the result might be expressed as1:</p> <pre><code>&gt;&gt;&gt; d20 = H(20)\n\n&gt;&gt;&gt; def reroll_one_dependent_term(d20_outcome):\n...   if d20_outcome == 1:\n...     return d20\n...   else:\n...     return d20_outcome\n\n&gt;&gt;&gt; H.foreach(reroll_one_dependent_term, d20_outcome=d20)\nH({1: 1, 2: 21, 3: 21, ..., 19: 21, 20: 21})\n</code></pre> <p>The <code>foreach</code> class method merely wraps dependent_term and calls <code>P.foreach</code>. In doing so, it imposes a very modest overhead that is negligible in most cases.</p> <pre><code>%timeit P.foreach(dependent_term_p, roll_1=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), roll_2=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}), roll_3=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1}), roll_n=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1, 19: 1, 20: 1}))\n104 ms \u00b1 500 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\n%timeit H.foreach(dependent_term_h, outcome_1=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), outcome_2=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}), outcome_3=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1}), outcome_n=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1, 19: 1, 20: 1}))\n113 ms \u00b1 575 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</code></pre> Source: <code>perf_foreach.ipy</code> <pre><code>from dyce import H, P\n\ndef dependent_term(\n  val_1,\n  val_2,\n  val_3,\n  val_n,\n):\n  import math ; math.gcd(456**123, 123**456)  # emulate an expensive calculation\n  return (\n    (val_1 == val_2) +\n    (val_2 == val_3) +\n    (val_1 == val_3) +\n    (\n      val_n &gt; val_1\n      and val_n &gt; val_2\n      and val_n &gt; val_3\n    )\n  )\n\ndef dependent_term_h(\n  outcome_1,\n  outcome_2,\n  outcome_3,\n  outcome_n,\n):\n  return dependent_term(outcome_1, outcome_2, outcome_3, outcome_n)\n\ndef dependent_term_p(\n  roll_1,\n  roll_2,\n  roll_3,\n  roll_n,\n):\n  return dependent_term(roll_1, roll_2, roll_3, roll_n)\n\nsource_1 = H(6)\nsource_2 = H(8)\nsource_3 = H(10)\nsource_n = H(20)\n\nprint(f\"%timeit P.foreach({dependent_term_p.__name__}, roll_1={source_1}, roll_2={source_2}, roll_3={source_3}, roll_n={source_n})\")\n%timeit P.foreach(dependent_term_p, roll_1=source_1, roll_2=source_2, roll_3=source_3, roll_n=source_n)\nprint()\n\nprint(f\"%timeit H.foreach({dependent_term_h.__name__}, outcome_1={source_1}, outcome_2={source_2}, outcome_3={source_3}, outcome_n={source_n})\")\n%timeit H.foreach(dependent_term_h, outcome_1=source_1, outcome_2=source_2, outcome_3=source_3, outcome_n=source_n)\nprint()\n</code></pre> <ol> <li> <p>This is primarily for illustration. <code>H.substitute</code> is often better suited to cases involving re-rolling a single independent term such as this one.\u00a0\u21a9</p> </li> </ol> Source code in <code>dyce/h.py</code> <pre><code>@classmethod\n@deprecated\n@beartype\ndef foreach(\n    cls,\n    dependent_term: Callable[..., HOrOutcomeT],\n    **independent_sources: _SourceT,\n) -&gt; H:\nr\"\"\"\n    !!! warning \"Deprecated\"\n\n        This method has been deprecated and will be removed in a future release. See\n        the [``expandable`` decorator][dyce.evaluation.expandable] and\n        [``foreach`` function][dyce.evaluation.foreach] for more flexible\n        alternatives.\n\n    Calls ``#!python dependent_term`` for each set of outcomes from the product of\n    ``independent_sources`` and accumulates the results. This is useful for\n    resolving dependent probabilities. Returned histograms are always reduced to\n    their lowest terms.\n\n    For example rolling a d20, re-rolling a ``#!python 1`` if it comes up, and\n    keeping the result might be expressed as[^1]:\n\n    [^1]:\n\n        This is primarily for illustration. [``H.substitute``][dyce.h.H.substitute]\n        is often better suited to cases involving re-rolling a single independent\n        term such as this one.\n\n    ``` python\n    &gt;&gt;&gt; d20 = H(20)\n\n    &gt;&gt;&gt; def reroll_one_dependent_term(d20_outcome):\n    ...   if d20_outcome == 1:\n    ...     return d20\n    ...   else:\n    ...     return d20_outcome\n\n    &gt;&gt;&gt; H.foreach(reroll_one_dependent_term, d20_outcome=d20)\n    H({1: 1, 2: 21, 3: 21, ..., 19: 21, 20: 21})\n\n    ```\n\n    The ``#!python foreach`` class method merely wraps *dependent_term* and calls\n    [``P.foreach``][dyce.p.P.foreach]. In doing so, it imposes a very modest\n    overhead that is negligible in most cases.\n\n    ``` python\n    --8&lt;-- \"docs/assets/perf_foreach.txt\"\n    ```\n\n    &lt;details&gt;\n    &lt;summary&gt;Source: &lt;a href=\"https://github.com/posita/dyce/blob/latest/docs/assets/perf_foreach.ipy\"&gt;&lt;code&gt;perf_foreach.ipy&lt;/code&gt;&lt;/a&gt;&lt;/summary&gt;\n\n    ``` python\n    --8&lt;-- \"docs/assets/perf_foreach.ipy\"\n    ```\n    &lt;/details&gt;\n    \"\"\"\n    from dyce import P\n\n    def _dependent_term(**roll_kw):\n        outcome_kw: dict[str, RealLike] = {}\n\n        for key, roll in roll_kw.items():\n            assert isinstance(roll, tuple)\n            assert len(roll) == 1\n            outcome_kw[key] = roll[0]\n\n        return dependent_term(**outcome_kw)\n\n    return P.foreach(_dependent_term, **independent_sources)\n</code></pre>"},{"location":"dyce/#dyce.h.H.format","title":"<code>format(width: SupportsInt = _ROW_WIDTH, scaled: bool = False, tick: str = '#', sep: str = os.linesep) -&gt; str</code>","text":"<p>Returns a formatted string representation of the histogram. If width is greater than zero, a horizontal bar ASCII graph is printed using tick and sep (which are otherwise ignored if width is zero or less).</p> <pre><code>&gt;&gt;&gt; print(H(6).format(width=0))\n{avg: 3.50, 1: 16.67%, 2: 16.67%, 3: 16.67%, 4: 16.67%, 5: 16.67%, 6: 16.67%}\n</code></pre> <pre><code>&gt;&gt;&gt; print((2@H(6)).zero_fill(range(1, 21)).format(tick=\"@\"))\navg |    7.00\nstd |    2.42\nvar |    5.83\n  1 |   0.00% |\n  2 |   2.78% |@\n  3 |   5.56% |@@\n  4 |   8.33% |@@@@\n  5 |  11.11% |@@@@@\n  6 |  13.89% |@@@@@@\n  7 |  16.67% |@@@@@@@@\n  8 |  13.89% |@@@@@@\n  9 |  11.11% |@@@@@\n 10 |   8.33% |@@@@\n 11 |   5.56% |@@\n 12 |   2.78% |@\n 13 |   0.00% |\n 14 |   0.00% |\n 15 |   0.00% |\n 16 |   0.00% |\n 17 |   0.00% |\n 18 |   0.00% |\n 19 |   0.00% |\n 20 |   0.00% |\n</code></pre> <p>If scaled is <code>True</code>, horizontal bars are scaled to width.</p> <pre><code>&gt;&gt;&gt; h = (2@H(6)).ge(7)\n&gt;&gt;&gt; print(f\"{' 65 chars wide --&gt;|':-&gt;65}\")\n---------------------------------------------- 65 chars wide --&gt;|\n&gt;&gt;&gt; print(h.format(scaled=False))\navg |    0.58\nstd |    0.49\nvar |    0.24\n  0 |  41.67% |####################\n  1 |  58.33% |#############################\n&gt;&gt;&gt; print(h.format(scaled=True))\navg |    0.58\nstd |    0.49\nvar |    0.24\n  0 |  41.67% |###################################\n  1 |  58.33% |##################################################\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef format(\n    self,\n    width: SupportsInt = _ROW_WIDTH,\n    scaled: bool = False,\n    tick: str = \"#\",\n    sep: str = os.linesep,\n) -&gt; str:\nr\"\"\"\n    Returns a formatted string representation of the histogram. If *width* is\n    greater than zero, a horizontal bar ASCII graph is printed using *tick* and\n    *sep* (which are otherwise ignored if *width* is zero or less).\n\n    ``` python\n    &gt;&gt;&gt; print(H(6).format(width=0))\n    {avg: 3.50, 1: 16.67%, 2: 16.67%, 3: 16.67%, 4: 16.67%, 5: 16.67%, 6: 16.67%}\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; print((2@H(6)).zero_fill(range(1, 21)).format(tick=\"@\"))\n    avg |    7.00\n    std |    2.42\n    var |    5.83\n      1 |   0.00% |\n      2 |   2.78% |@\n      3 |   5.56% |@@\n      4 |   8.33% |@@@@\n      5 |  11.11% |@@@@@\n      6 |  13.89% |@@@@@@\n      7 |  16.67% |@@@@@@@@\n      8 |  13.89% |@@@@@@\n      9 |  11.11% |@@@@@\n     10 |   8.33% |@@@@\n     11 |   5.56% |@@\n     12 |   2.78% |@\n     13 |   0.00% |\n     14 |   0.00% |\n     15 |   0.00% |\n     16 |   0.00% |\n     17 |   0.00% |\n     18 |   0.00% |\n     19 |   0.00% |\n     20 |   0.00% |\n\n    ```\n\n    If *scaled* is ``#!python True``, horizontal bars are scaled to *width*.\n\n    ``` python\n    &gt;&gt;&gt; h = (2@H(6)).ge(7)\n    &gt;&gt;&gt; print(f\"{' 65 chars wide --&gt;|':-&gt;65}\")\n    ---------------------------------------------- 65 chars wide --&gt;|\n    &gt;&gt;&gt; print(h.format(scaled=False))\n    avg |    0.58\n    std |    0.49\n    var |    0.24\n      0 |  41.67% |####################\n      1 |  58.33% |#############################\n    &gt;&gt;&gt; print(h.format(scaled=True))\n    avg |    0.58\n    std |    0.49\n    var |    0.24\n      0 |  41.67% |###################################\n      1 |  58.33% |##################################################\n\n    ```\n    \"\"\"\n    width = as_int(width)\n\n    # We convert various values herein to native ints and floats because number\n    # tower implementations sometimes neglect to implement __format__ properly (or\n    # at all). (I'm looking at you, sage.rings.\u2026!)\n    try:\n        mu: RealLike = float(self.mean())\n    except (OverflowError, TypeError):\n        mu = self.mean()\n\n    if width &lt;= 0:\n\n        def _parts() -&gt; Iterator[str]:\n            yield f\"avg: {mu:.2f}\"\n\n            for (\n                outcome,\n                probability,\n            ) in self.distribution():\n                probability_f = float(probability)\n                yield f\"{outcome}:{probability_f:7.2%}\"\n\n        return \"{\" + \", \".join(_parts()) + \"}\"\n    else:\n        w = width - 15\n\n        def _lines() -&gt; Iterator[str]:\n            try:\n                yield f\"avg | {mu:7.2f}\"\n                std = float(self.stdev(mu))\n                var = float(self.variance(mu))\n                yield f\"std | {std:7.2f}\"\n                yield f\"var | {var:7.2f}\"\n            except (OverflowError, TypeError) as exc:\n                warnings.warn(f\"{str(exc)}; mu: {mu}\")\n\n            if self:\n                outcomes, probabilities = self.distribution_xy()\n                tick_scale = max(probabilities) if scaled else 1.0\n\n                for outcome, probability in zip(outcomes, probabilities):\n                    try:\n                        outcome_str = f\"{outcome: 3}\"\n                    except (TypeError, ValueError):\n                        outcome_str = str(outcome)\n                        outcome_str = f\"{outcome_str: &gt;3}\"\n\n                    ticks = tick * int(w * probability / tick_scale)\n                    probability_f = float(probability)\n                    yield f\"{outcome_str} | {probability_f:7.2%} |{ticks}\"\n\n        return sep.join(_lines())\n</code></pre>"},{"location":"dyce/#dyce.h.H.ge","title":"<code>ge(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.map(operator.__ge__, other).umap(bool)</code>.</p> <pre><code>&gt;&gt;&gt; H(6).ge(3)\nH({False: 2, True: 4})\n</code></pre> <p>See the <code>map</code> and <code>umap</code> methods.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef ge(self, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.map(operator.__ge__, other).umap(bool)``.\n\n    ``` python\n    &gt;&gt;&gt; H(6).ge(3)\n    H({False: 2, True: 4})\n\n    ```\n\n    See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n    \"\"\"\n    return self.map(__ge__, other).umap(bool)\n</code></pre>"},{"location":"dyce/#dyce.h.H.gt","title":"<code>gt(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.map(operator.__gt__, other).umap(bool)</code>.</p> <pre><code>&gt;&gt;&gt; H(6).gt(3)\nH({False: 3, True: 3})\n</code></pre> <p>See the <code>map</code> and <code>umap</code> methods.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef gt(self, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.map(operator.__gt__, other).umap(bool)``.\n\n    ``` python\n    &gt;&gt;&gt; H(6).gt(3)\n    H({False: 3, True: 3})\n\n    ```\n\n    See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n    \"\"\"\n    return self.map(__gt__, other).umap(bool)\n</code></pre>"},{"location":"dyce/#dyce.h.H.is_even","title":"<code>is_even() -&gt; H</code>","text":"<p>Equivalent to <code>self.umap(dyce.types.is_even)</code>.</p> <pre><code>&gt;&gt;&gt; H((-4, -2, 0, 1, 2, 3)).is_even()\nH({False: 2, True: 4})\n</code></pre> <p>See the <code>umap</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef is_even(self) -&gt; H:\nr\"\"\"\n    Equivalent to ``#!python self.umap(dyce.types.is_even)``.\n\n    ``` python\n    &gt;&gt;&gt; H((-4, -2, 0, 1, 2, 3)).is_even()\n    H({False: 2, True: 4})\n\n    ```\n\n    See the [``umap`` method][dyce.h.H.umap].\n    \"\"\"\n    return self.umap(is_even)\n</code></pre>"},{"location":"dyce/#dyce.h.H.is_odd","title":"<code>is_odd() -&gt; H</code>","text":"<p>Equivalent to <code>self.umap(dyce.types.is_odd)</code>.</p> <pre><code>&gt;&gt;&gt; H((-4, -2, 0, 1, 2, 3)).is_odd()\nH({False: 4, True: 2})\n</code></pre> <p>See the <code>umap</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef is_odd(self) -&gt; H:\nr\"\"\"\n    Equivalent to ``#!python self.umap(dyce.types.is_odd)``.\n\n    ``` python\n    &gt;&gt;&gt; H((-4, -2, 0, 1, 2, 3)).is_odd()\n    H({False: 4, True: 2})\n\n    ```\n\n    See the [``umap`` method][dyce.h.H.umap].\n    \"\"\"\n    return self.umap(is_odd)\n</code></pre>"},{"location":"dyce/#dyce.h.H.items","title":"<code>items() -&gt; ItemsView[RealLike, int]</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef items(self) -&gt; ItemsView[RealLike, int]:\n    return self._h.items()\n</code></pre>"},{"location":"dyce/#dyce.h.H.keys","title":"<code>keys() -&gt; KeysView[RealLike]</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef keys(self) -&gt; KeysView[RealLike]:\n    return self.outcomes()\n</code></pre>"},{"location":"dyce/#dyce.h.H.le","title":"<code>le(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.map(operator.__le__, other).umap(bool)</code>.</p> <pre><code>&gt;&gt;&gt; H(6).le(3)\nH({False: 3, True: 3})\n</code></pre> <p>See the <code>map</code> and <code>umap</code> methods.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef le(self, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.map(operator.__le__, other).umap(bool)``.\n\n    ``` python\n    &gt;&gt;&gt; H(6).le(3)\n    H({False: 3, True: 3})\n\n    ```\n\n    See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n    \"\"\"\n    return self.map(__le__, other).umap(bool)\n</code></pre>"},{"location":"dyce/#dyce.h.H.lowest_terms","title":"<code>lowest_terms() -&gt; H</code>","text":"<p>Computes and returns a histogram whose nonzero counts share a greatest common divisor of 1.</p> <pre><code>&gt;&gt;&gt; df_obscured = H({-2: 0, -1: 2, 0: 2, 1: 2, 2: 0})\n&gt;&gt;&gt; df_obscured.lowest_terms()\nH({-1: 1, 0: 1, 1: 1})\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef lowest_terms(self) -&gt; H:\nr\"\"\"\n    Computes and returns a histogram whose nonzero counts share a greatest\n    common divisor of 1.\n\n    ``` python\n    &gt;&gt;&gt; df_obscured = H({-2: 0, -1: 2, 0: 2, 1: 2, 2: 0})\n    &gt;&gt;&gt; df_obscured.lowest_terms()\n    H({-1: 1, 0: 1, 1: 1})\n\n    ```\n    \"\"\"\n    if self._lowest_terms is None:\n        counts_gcd = gcd(*self.counts())\n\n        if counts_gcd in (0, 1) and 0 not in self.counts():\n            self._lowest_terms = self\n        else:\n            self._lowest_terms = type(self)(\n                (outcome, count // counts_gcd)\n                for outcome, count in self.items()\n                if count != 0\n            )\n\n    return self._lowest_terms\n</code></pre>"},{"location":"dyce/#dyce.h.H.lt","title":"<code>lt(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.map(operator.__lt__, other).umap(bool)</code>.</p> <pre><code>&gt;&gt;&gt; H(6).lt(3)\nH({False: 4, True: 2})\n</code></pre> <p>See the <code>map</code> and <code>umap</code> methods.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef lt(self, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.map(operator.__lt__, other).umap(bool)``.\n\n    ``` python\n    &gt;&gt;&gt; H(6).lt(3)\n    H({False: 4, True: 2})\n\n    ```\n\n    See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n    \"\"\"\n    return self.map(__lt__, other).umap(bool)\n</code></pre>"},{"location":"dyce/#dyce.h.H.map","title":"<code>map(bin_op: _BinaryOperatorT, right_operand: _OperandT) -&gt; H</code>","text":"<p>Applies bin_op to each outcome of the histogram as the left operand and right_operand as the right. Shorthands exist for many arithmetic operators and comparators.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; d6 = H(6)\n&gt;&gt;&gt; d6.map(operator.__add__, d6)\nH({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n&gt;&gt;&gt; d6.map(operator.__add__, d6) == d6 + d6\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; d6.map(operator.__pow__, 2)\nH({1: 1, 4: 1, 9: 1, 16: 1, 25: 1, 36: 1})\n&gt;&gt;&gt; d6.map(operator.__pow__, 2) == d6 ** 2\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; d6.map(operator.__gt__, 3)\nH({False: 3, True: 3})\n&gt;&gt;&gt; d6.map(operator.__gt__, 3) == d6.gt(3)\nTrue\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef map(self, bin_op: _BinaryOperatorT, right_operand: _OperandT) -&gt; H:\nr\"\"\"\n    Applies *bin_op* to each outcome of the histogram as the left operand and\n    *right_operand* as the right. Shorthands exist for many arithmetic operators and\n    comparators.\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; d6 = H(6)\n    &gt;&gt;&gt; d6.map(operator.__add__, d6)\n    H({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n    &gt;&gt;&gt; d6.map(operator.__add__, d6) == d6 + d6\n    True\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; d6.map(operator.__pow__, 2)\n    H({1: 1, 4: 1, 9: 1, 16: 1, 25: 1, 36: 1})\n    &gt;&gt;&gt; d6.map(operator.__pow__, 2) == d6 ** 2\n    True\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; d6.map(operator.__gt__, 3)\n    H({False: 3, True: 3})\n    &gt;&gt;&gt; d6.map(operator.__gt__, 3) == d6.gt(3)\n    True\n\n    ```\n    \"\"\"\n    if isinstance(right_operand, HableT):\n        right_operand = right_operand.h()\n\n    if isinstance(right_operand, H):\n        return type(self)(\n            (bin_op(s, o), self[s] * right_operand[o])\n            for s, o in product(self, right_operand)\n        )\n    else:\n        return type(self)(\n            (bin_op(outcome, right_operand), count)\n            for outcome, count in self.items()\n        )\n</code></pre>"},{"location":"dyce/#dyce.h.H.mean","title":"<code>mean() -&gt; RealLike</code>","text":"<p>Returns the mean of the weighted outcomes (or 0.0 if there are no outcomes).</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef mean(self) -&gt; RealLike:\nr\"\"\"\n    Returns the mean of the weighted outcomes (or 0.0 if there are no outcomes).\n    \"\"\"\n    numerator: float\n    denominator: float\n    numerator = denominator = 0\n\n    for outcome, count in self.items():\n        numerator += outcome * count\n        denominator += count\n\n    return numerator / (denominator or 1)\n</code></pre>"},{"location":"dyce/#dyce.h.H.ne","title":"<code>ne(other: _OperandT) -&gt; H</code>","text":"<p>Shorthand for <code>self.map(operator.__ne__, other).umap(bool)</code>.</p> <pre><code>&gt;&gt;&gt; H(6).ne(3)\nH({False: 1, True: 5})\n</code></pre> <p>See the <code>map</code> and <code>umap</code> methods.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef ne(self, other: _OperandT) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.map(operator.__ne__, other).umap(bool)``.\n\n    ``` python\n    &gt;&gt;&gt; H(6).ne(3)\n    H({False: 1, True: 5})\n\n    ```\n\n    See the [``map``][dyce.h.H.map] and [``umap``][dyce.h.H.umap] methods.\n    \"\"\"\n    return self.map(__ne__, other).umap(bool)\n</code></pre>"},{"location":"dyce/#dyce.h.H.order_stat_for_n_at_pos","title":"<code>order_stat_for_n_at_pos(n: SupportsInt, pos: SupportsInt) -&gt; H</code>","text":"<p>Experimental</p> <p>This method should be considered experimental and may change or disappear in future versions.</p> <p>Computes the probability distribution for each outcome appearing in at pos for n histograms. pos is a zero-based index.</p> <pre><code>&gt;&gt;&gt; d6avg = H((2, 3, 3, 4, 4, 5))\n&gt;&gt;&gt; d6avg.order_stat_for_n_at_pos(5, 3)  # counts where outcome appears in the fourth of five positions\nH({2: 26, 3: 1432, 4: 4792, 5: 1526})\n</code></pre> <p>The results show that, when rolling five six-sided \u201caveraging\u201d dice and sorting each roll, there are 26 ways where <code>2</code> appears at the fourth (index <code>3</code>) position, 1432 ways where <code>3</code> appears at the fourth position, etc. This can be verified independently using the computationally expensive method of enumerating rolls and counting those that meet the criteria.</p> <pre><code>&gt;&gt;&gt; from dyce import P\n&gt;&gt;&gt; p_5d6avg = 5@P(d6avg)\n&gt;&gt;&gt; sum(count for roll, count in p_5d6avg.rolls_with_counts() if roll[3] == 5)\n1526\n</code></pre> <p>Negative values for pos follow Python index semantics:</p> <pre><code>&gt;&gt;&gt; d6 = H(6)\n&gt;&gt;&gt; d6.order_stat_for_n_at_pos(6, 0) == d6.order_stat_for_n_at_pos(6, -6)\nTrue\n&gt;&gt;&gt; d6.order_stat_for_n_at_pos(6, 5) == d6.order_stat_for_n_at_pos(6, -1)\nTrue\n</code></pre> <p>This method caches computing the betas for n so they can be reused for varying values of pos in subsequent calls.</p> Source code in <code>dyce/h.py</code> <pre><code>@experimental\n@beartype\ndef order_stat_for_n_at_pos(self, n: SupportsInt, pos: SupportsInt) -&gt; H:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This method should be considered experimental and may change or disappear in\n        future versions.\n\n    Computes the probability distribution for each outcome appearing in at *pos* for\n    *n* histograms. *pos* is a zero-based index.\n\n    ``` python\n    &gt;&gt;&gt; d6avg = H((2, 3, 3, 4, 4, 5))\n    &gt;&gt;&gt; d6avg.order_stat_for_n_at_pos(5, 3)  # counts where outcome appears in the fourth of five positions\n    H({2: 26, 3: 1432, 4: 4792, 5: 1526})\n\n    ```\n\n    The results show that, when rolling five six-sided \u201caveraging\u201d dice and sorting\n    each roll, there are 26 ways where ``#!python 2`` appears at the fourth (index\n    ``#!python 3``) position, 1432 ways where ``#!python 3`` appears at the fourth\n    position, etc. This can be verified independently using the computationally\n    expensive method of enumerating rolls and counting those that meet the criteria.\n\n    ``` python\n    &gt;&gt;&gt; from dyce import P\n    &gt;&gt;&gt; p_5d6avg = 5@P(d6avg)\n    &gt;&gt;&gt; sum(count for roll, count in p_5d6avg.rolls_with_counts() if roll[3] == 5)\n    1526\n\n    ```\n\n    Negative values for *pos* follow Python index semantics:\n\n    ``` python\n    &gt;&gt;&gt; d6 = H(6)\n    &gt;&gt;&gt; d6.order_stat_for_n_at_pos(6, 0) == d6.order_stat_for_n_at_pos(6, -6)\n    True\n    &gt;&gt;&gt; d6.order_stat_for_n_at_pos(6, 5) == d6.order_stat_for_n_at_pos(6, -1)\n    True\n\n    ```\n\n    This method caches computing the betas for *n* so they can be reused for varying\n    values of *pos* in subsequent calls.\n    \"\"\"\n    # See &lt;https://math.stackexchange.com/q/4173084/226394&gt; for motivation\n    n = as_int(n)\n    pos = as_int(pos)\n\n    if n not in self._order_stat_funcs_by_n:\n        self._order_stat_funcs_by_n[n] = self._order_stat_func_for_n(n)\n\n    if pos &lt; 0:\n        pos = n + pos\n\n    return self._order_stat_funcs_by_n[n](pos)\n</code></pre>"},{"location":"dyce/#dyce.h.H.outcomes","title":"<code>outcomes() -&gt; KeysView[RealLike]</code>","text":"<p>More descriptive synonym for the <code>keys</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef outcomes(self) -&gt; KeysView[RealLike]:\nr\"\"\"\n    More descriptive synonym for the [``keys`` method][dyce.h.H.keys].\n    \"\"\"\n    return self._h.keys()\n</code></pre>"},{"location":"dyce/#dyce.h.H.remove","title":"<code>remove(outcome: RealLike) -&gt; H</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef remove(self, outcome: RealLike) -&gt; H:\n    if outcome not in self:\n        return self\n\n    return type(self)(\n        (orig_outcome, count)\n        for orig_outcome, count in self.items()\n        if orig_outcome != outcome\n    )\n</code></pre>"},{"location":"dyce/#dyce.h.H.reversed","title":"<code>reversed() -&gt; Iterator[RealLike]</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef reversed(self) -&gt; Iterator[RealLike]:\n    return reversed(self)\n</code></pre>"},{"location":"dyce/#dyce.h.H.rmap","title":"<code>rmap(left_operand: RealLike, bin_op: _BinaryOperatorT) -&gt; H</code>","text":"<p>Analogous to the <code>map</code> method, but where the caller supplies left_operand.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; d6 = H(6)\n&gt;&gt;&gt; d6.rmap(2, operator.__pow__)\nH({2: 1, 4: 1, 8: 1, 16: 1, 32: 1, 64: 1})\n&gt;&gt;&gt; d6.rmap(2, operator.__pow__) == 2 ** d6\nTrue\n</code></pre> <p>Note</p> <p>The positions of left_operand and bin_op are different from <code>map</code> method. This is intentional and serves as a reminder of operand ordering.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef rmap(self, left_operand: RealLike, bin_op: _BinaryOperatorT) -&gt; H:\nr\"\"\"\n    Analogous to the [``map`` method][dyce.h.H.map], but where the caller supplies\n    *left_operand*.\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; d6 = H(6)\n    &gt;&gt;&gt; d6.rmap(2, operator.__pow__)\n    H({2: 1, 4: 1, 8: 1, 16: 1, 32: 1, 64: 1})\n    &gt;&gt;&gt; d6.rmap(2, operator.__pow__) == 2 ** d6\n    True\n\n    ```\n\n    !!! note\n\n        The positions of *left_operand* and *bin_op* are different from\n        [``map`` method][dyce.h.H.map]. This is intentional and serves as a reminder\n        of operand ordering.\n    \"\"\"\n    return type(self)(\n        (bin_op(left_operand, outcome), count) for outcome, count in self.items()\n    )\n</code></pre>"},{"location":"dyce/#dyce.h.H.roll","title":"<code>roll() -&gt; RealLike</code>","text":"<p>Returns a (weighted) random outcome, sorted.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef roll(self) -&gt; RealLike:\nr\"\"\"\n    Returns a (weighted) random outcome, sorted.\n    \"\"\"\n    return (\n        rng.RNG.choices(\n            population=tuple(self.outcomes()),\n            weights=tuple(self.counts()),\n            k=1,\n        )[0]\n        if self\n        else 0\n    )\n</code></pre>"},{"location":"dyce/#dyce.h.H.stdev","title":"<code>stdev(mu: Optional[RealLike] = None) -&gt; RealLike</code>","text":"<p>Shorthand for <code>math.sqrt(self.variance(mu))</code>.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef stdev(self, mu: Optional[RealLike] = None) -&gt; RealLike:\nr\"\"\"\n    Shorthand for ``#!python math.sqrt(self.variance(mu))``.\n    \"\"\"\n    return sqrt(self.variance(mu))\n</code></pre>"},{"location":"dyce/#dyce.h.H.substitute","title":"<code>substitute(expand: _SubstituteExpandCallbackT, coalesce: _SubstituteCoalesceCallbackT = coalesce_replace, max_depth: Optional[IntegralLike] = None, precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None) -&gt; H</code>","text":"<p>Deprecated</p> <p>This method has been deprecated and will be removed in a future release. See the <code>expandable</code> decorator and <code>foreach</code> function for more flexible alternatives.</p> <p>Calls expand on each outcome. If expand returns a single outcome, it replaces the existing outcome. If it returns an <code>H</code> object, evaluation is performed again (recursively) on that object until a limit (either max_depth or precision_limit) is exhausted. coalesce is called on the original outcome and the expanded histogram or outcome and the returned histogram is \u201cfolded\u201d into result. The default behavior for coalesce is to replace the outcome with the expanded histogram. Returned histograms are always reduced to their lowest terms.</p> <p>coalesce is not called unless expand returns a histogram</p> <p>If expand returns a single outcome, it always replaces the existing outcome. This is intentional. To return a single outcome, but trigger coalesce, characterize that outcome as a single-sided die (e.g., <code>H({outcome: 1})</code>.</p> <p>See the <code>coalesce_replace</code> and <code>lowest_terms</code> methods.</p> <p>Precision limits</p> <p>The max_depth parameter is similar to an <code>expandable</code>-decorated function\u2019s limit argument when given a whole number. The precision_limit parameter is similar to an <code>expandable</code>-decorated function\u2019s limit argument being provided a fractional value. It is an error to provide values for both max_depth and precision_limit.</p> Source code in <code>dyce/h.py</code> <pre><code>@deprecated\n@beartype\ndef substitute(\n    self,\n    expand: _SubstituteExpandCallbackT,\n    coalesce: _SubstituteCoalesceCallbackT = coalesce_replace,\n    max_depth: Optional[IntegralLike] = None,\n    precision_limit: Optional[Union[RationalLikeMixedU, RealLike]] = None,\n) -&gt; H:\nr\"\"\"\n    !!! warning \"Deprecated\"\n\n        This method has been deprecated and will be removed in a future release. See\n        the [``expandable`` decorator][dyce.evaluation.expandable] and\n        [``foreach`` function][dyce.evaluation.foreach] for more flexible\n        alternatives.\n\n    Calls *expand* on each outcome. If *expand* returns a single outcome, it\n    replaces the existing outcome. If it returns an [``H`` object][dyce.h.H],\n    evaluation is performed again (recursively) on that object until a limit (either\n    *max_depth* or *precision_limit*) is exhausted. *coalesce* is called on the\n    original outcome and the expanded histogram or outcome and the returned\n    histogram is \u201cfolded\u201d into result. The default behavior for *coalesce* is to\n    replace the outcome with the expanded histogram. Returned histograms are always\n    reduced to their lowest terms.\n\n    !!! note \"*coalesce* is not called unless *expand* returns a histogram\"\n\n        If *expand* returns a single outcome, it *always* replaces the existing\n        outcome. This is intentional. To return a single outcome, but trigger\n        *coalesce*, characterize that outcome as a single-sided die (e.g.,\n        ``#!python H({outcome: 1})``.\n\n    See the [``coalesce_replace``][dyce.h.coalesce_replace] and\n    [``lowest_terms``][dyce.h.H.lowest_terms] methods.\n\n    !!! tip \"Precision limits\"\n\n        The *max_depth* parameter is similar to an\n        [``expandable``][dyce.evaluation.expandable]-decorated function\u2019s limit\n        argument when given a whole number. The *precision_limit* parameter is\n        similar to an [``expandable``][dyce.evaluation.expandable]-decorated\n        function\u2019s limit argument being provided a fractional value. It is an error\n        to provide values for both *max_depth* and *precision_limit*.\n    \"\"\"\n    from .evaluation import HResult, LimitT, expandable\n\n    if max_depth is not None and precision_limit is not None:\n        raise ValueError(\"only one of max_depth and precision_limit is allowed\")\n\n    limit: Optional[LimitT] = (\n        max_depth if precision_limit is None else precision_limit\n    )\n\n    @expandable(sentinel=self)\n    def _expand(result: HResult) -&gt; HOrOutcomeT:\n        res = expand(result.h, result.outcome)\n\n        return coalesce(_expand(res), result.outcome) if isinstance(res, H) else res\n\n    return _expand(self, limit=limit)\n</code></pre>"},{"location":"dyce/#dyce.h.H.umap","title":"<code>umap(un_op: _UnaryOperatorT) -&gt; H</code>","text":"<p>Applies un_op to each outcome of the histogram.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; H(6).umap(operator.__neg__)\nH({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1})\n</code></pre> <pre><code>&gt;&gt;&gt; H(4).umap(lambda outcome: (-outcome) ** outcome)\nH({-27: 1, -1: 1, 4: 1, 256: 1})\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef umap(self, un_op: _UnaryOperatorT) -&gt; H:\nr\"\"\"\n    Applies *un_op* to each outcome of the histogram.\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; H(6).umap(operator.__neg__)\n    H({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1})\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; H(4).umap(lambda outcome: (-outcome) ** outcome)\n    H({-27: 1, -1: 1, 4: 1, 256: 1})\n\n    ```\n    \"\"\"\n    return type(self)((un_op(outcome), count) for outcome, count in self.items())\n</code></pre>"},{"location":"dyce/#dyce.h.H.values","title":"<code>values() -&gt; ValuesView[int]</code>","text":"Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef values(self) -&gt; ValuesView[int]:\n    return self.counts()\n</code></pre>"},{"location":"dyce/#dyce.h.H.variance","title":"<code>variance(mu: Optional[RealLike] = None) -&gt; RealLike</code>","text":"<p>Returns the variance of the weighted outcomes. If provided, mu is used as the mean (to avoid duplicate computation).</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef variance(self, mu: Optional[RealLike] = None) -&gt; RealLike:\nr\"\"\"\n    Returns the variance of the weighted outcomes. If provided, *mu* is used as the mean\n    (to avoid duplicate computation).\n    \"\"\"\n    mu = mu if mu else self.mean()\n    numerator: float\n    denominator: float\n    numerator = denominator = 0\n\n    for outcome, count in self.items():\n        numerator += outcome**2 * count\n        denominator += count\n\n    # While floating point overflow is impossible to eliminate, we avoid it under\n    # some circumstances by exploiting the equivalence of E[(X - E[X])**2] and the\n    # more efficient E[X**2] - E[X]**2. See\n    # &lt;https://dlsun.github.io/probability/variance.html&gt;.\n    return numerator / (denominator or 1) - mu**2\n</code></pre>"},{"location":"dyce/#dyce.h.H.vs","title":"<code>vs(other: _OperandT) -&gt; H</code>","text":"<p>Compares the histogram with other. -1 represents where other is greater. 0 represents where they are equal. 1 represents where other is less.</p> <p>Shorthand for <code>self.within(0, 0, other)</code>.</p> <pre><code>&gt;&gt;&gt; H(6).vs(H(4))\nH({-1: 6, 0: 4, 1: 14})\n&gt;&gt;&gt; H(6).vs(H(4)) == H(6).within(0, 0, H(4))\nTrue\n</code></pre> <p>See the <code>within</code> method.</p> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef vs(self, other: _OperandT) -&gt; H:\nr\"\"\"\n    Compares the histogram with *other*. -1 represents where *other* is greater. 0\n    represents where they are equal. 1 represents where *other* is less.\n\n    Shorthand for ``#!python self.within(0, 0, other)``.\n\n    ``` python\n    &gt;&gt;&gt; H(6).vs(H(4))\n    H({-1: 6, 0: 4, 1: 14})\n    &gt;&gt;&gt; H(6).vs(H(4)) == H(6).within(0, 0, H(4))\n    True\n\n    ```\n\n    See the [``within`` method][dyce.h.H.within].\n    \"\"\"\n    return self.within(0, 0, other)\n</code></pre>"},{"location":"dyce/#dyce.h.H.within","title":"<code>within(lo: RealLike, hi: RealLike, other: _OperandT = 0) -&gt; H</code>","text":"<p>Computes the difference between the histogram and other. -1 represents where that difference is less than lo. 0 represents where that difference between lo and hi (inclusive). 1 represents where that difference is greater than hi.</p> <pre><code>&gt;&gt;&gt; d6_2 = 2@H(6)\n&gt;&gt;&gt; d6_2.within(7, 9)\nH({-1: 15, 0: 15, 1: 6})\n&gt;&gt;&gt; print(d6_2.within(7, 9).format())\navg |   -0.25\nstd |    0.72\nvar |    0.52\n -1 |  41.67% |####################\n  0 |  41.67% |####################\n  1 |  16.67% |########\n</code></pre> <pre><code>&gt;&gt;&gt; d6_3, d8_2 = 3@H(6), 2@H(8)\n&gt;&gt;&gt; d6_3.within(-1, 1, d8_2)  # 3d6 w/in 1 of 2d8\nH({-1: 3500, 0: 3412, 1: 6912})\n&gt;&gt;&gt; print(d6_3.within(-1, 1, d8_2).format())\navg |    0.25\nstd |    0.83\nvar |    0.69\n -1 |  25.32% |############\n  0 |  24.68% |############\n  1 |  50.00% |#########################\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef within(self, lo: RealLike, hi: RealLike, other: _OperandT = 0) -&gt; H:\nr\"\"\"\n    Computes the difference between the histogram and *other*. -1 represents where that\n    difference is less than *lo*. 0 represents where that difference between *lo*\n    and *hi* (inclusive). 1 represents where that difference is greater than *hi*.\n\n    ``` python\n    &gt;&gt;&gt; d6_2 = 2@H(6)\n    &gt;&gt;&gt; d6_2.within(7, 9)\n    H({-1: 15, 0: 15, 1: 6})\n    &gt;&gt;&gt; print(d6_2.within(7, 9).format())\n    avg |   -0.25\n    std |    0.72\n    var |    0.52\n     -1 |  41.67% |####################\n      0 |  41.67% |####################\n      1 |  16.67% |########\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; d6_3, d8_2 = 3@H(6), 2@H(8)\n    &gt;&gt;&gt; d6_3.within(-1, 1, d8_2)  # 3d6 w/in 1 of 2d8\n    H({-1: 3500, 0: 3412, 1: 6912})\n    &gt;&gt;&gt; print(d6_3.within(-1, 1, d8_2).format())\n    avg |    0.25\n    std |    0.83\n    var |    0.69\n     -1 |  25.32% |############\n      0 |  24.68% |############\n      1 |  50.00% |#########################\n\n    ```\n    \"\"\"\n    return self.map(_within(lo, hi), other)\n</code></pre>"},{"location":"dyce/#dyce.h.H.zero_fill","title":"<code>zero_fill(outcomes: Iterable[RealLike]) -&gt; H</code>","text":"<p>Shorthand for <code>self.accumulate({outcome: 0 for outcome inoutcomes})</code>.</p> <pre><code>&gt;&gt;&gt; H(4).zero_fill(H(8).outcomes())\nH({1: 1, 2: 1, 3: 1, 4: 1, 5: 0, 6: 0, 7: 0, 8: 0})\n</code></pre> Source code in <code>dyce/h.py</code> <pre><code>@beartype\ndef zero_fill(self, outcomes: Iterable[RealLike]) -&gt; H:\nr\"\"\"\n    Shorthand for ``#!python self.accumulate({outcome: 0 for outcome in\n    outcomes})``.\n\n    ``` python\n    &gt;&gt;&gt; H(4).zero_fill(H(8).outcomes())\n    H({1: 1, 2: 1, 3: 1, 4: 1, 5: 0, 6: 0, 7: 0, 8: 0})\n\n    ```\n    \"\"\"\n    return self.accumulate({outcome: 0 for outcome in outcomes})\n</code></pre>"},{"location":"dyce/#dyce.p.P","title":"<code>P</code>","text":"<p>             Bases: <code>Sequence[H]</code>, <code>HableOpsMixin</code></p> <p>An immutable pool (ordered sequence) supporting group operations for zero or more <code>H</code> objects (provided or created from the initializer\u2019s args parameter).</p> <pre><code>&gt;&gt;&gt; from dyce import P\n&gt;&gt;&gt; p_d6 = P(6) ; p_d6  # shorthand for P(H(6))\nP(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))\n</code></pre> <pre><code>&gt;&gt;&gt; P(p_d6, p_d6)  # 2d6\n2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))\n&gt;&gt;&gt; 2@p_d6  # also 2d6\n2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))\n&gt;&gt;&gt; 2@(2@p_d6) == 4@p_d6\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; p = P(4, P(6, P(8, P(10, P(12, P(20)))))) ; p\nP(H({1: 1, 2: 1, 3: 1, 4: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1, 19: 1, 20: 1}))\n&gt;&gt;&gt; sum(p.roll()) in p.h()\nTrue\n</code></pre> <p>This class implements the <code>HableT</code> protocol and derives from the <code>HableOpsMixin</code> class, which means it can be \u201cflattened\u201d into a single histogram, either explicitly via the <code>h</code> method, or implicitly by using arithmetic operations.</p> <pre><code>&gt;&gt;&gt; -p_d6\nH({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1})\n</code></pre> <pre><code>&gt;&gt;&gt; p_d6 + p_d6\nH({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n</code></pre> <pre><code>&gt;&gt;&gt; 2 * P(8) - 1\nH({1: 1, 3: 1, 5: 1, 7: 1, 9: 1, 11: 1, 13: 1, 15: 1})\n</code></pre> <p>To perform arithmetic on individual <code>H</code> objects in a pool without flattening, use the <code>map</code>, <code>rmap</code>, and <code>umap</code> methods.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; P(4, 6, 8).umap(operator.__neg__)\nP(H({-8: 1, -7: 1, -6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1}), H({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1}), H({-4: 1, -3: 1, -2: 1, -1: 1}))\n</code></pre> <pre><code>&gt;&gt;&gt; P(4, 6).map(operator.__pow__, 2)\nP(H({1: 1, 4: 1, 9: 1, 16: 1}), H({1: 1, 4: 1, 9: 1, 16: 1, 25: 1, 36: 1}))\n</code></pre> <pre><code>&gt;&gt;&gt; P(4, 6).rmap(2, operator.__pow__)\nP(H({2: 1, 4: 1, 8: 1, 16: 1}), H({2: 1, 4: 1, 8: 1, 16: 1, 32: 1, 64: 1}))\n</code></pre> <p>Comparisons with <code>H</code> objects work as expected.</p> <pre><code>&gt;&gt;&gt; from dyce import H\n&gt;&gt;&gt; 3@p_d6 == H(6) + H(6) + H(6)\nTrue\n</code></pre> <p>Indexing selects a contained histogram.</p> <pre><code>&gt;&gt;&gt; P(4, 6, 8)[0]\nH({1: 1, 2: 1, 3: 1, 4: 1})\n</code></pre> <p>Note that pools are opinionated about ordering.</p> <pre><code>&gt;&gt;&gt; P(8, 6, 4)\nP(H({1: 1, 2: 1, 3: 1, 4: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}))\n&gt;&gt;&gt; P(8, 6, 4)[0] == P(8, 4, 6)[0] == H(4)\nTrue\n</code></pre> <p>In an extension to (departure from) the <code>HableT</code> protocol, the <code>h</code> method\u2019s implementation also affords subsets of outcomes to be \u201ctaken\u201d (selected) by passing in selection criteria. Values are indexed from least to greatest. Negative indexes are supported and retain their idiomatic meaning. Modeling the sum of the greatest two faces of three six-sided dice (<code>3d6</code>) can be expressed as:</p> <pre><code>&gt;&gt;&gt; p_3d6 = 3@p_d6\n&gt;&gt;&gt; p_3d6.h(-2, -1)\nH({2: 1, 3: 3, 4: 7, 5: 12, 6: 19, 7: 27, 8: 34, 9: 36, 10: 34, 11: 27, 12: 16})\n&gt;&gt;&gt; print(p_3d6.h(-2, -1).format())\navg |    8.46\nstd |    2.21\nvar |    4.91\n  2 |   0.46% |\n  3 |   1.39% |\n  4 |   3.24% |#\n  5 |   5.56% |##\n  6 |   8.80% |####\n  7 |  12.50% |######\n  8 |  15.74% |#######\n  9 |  16.67% |########\n 10 |  15.74% |#######\n 11 |  12.50% |######\n 12 |   7.41% |###\n</code></pre> Source code in <code>dyce/p.py</code> <pre><code>class P(Sequence[H], HableOpsMixin):\nr\"\"\"\n    An immutable pool (ordered sequence) supporting group operations for zero or more\n    [``H`` objects][dyce.h.H] (provided or created from the\n    [initializer][dyce.p.P.__init__]\u2019s *args* parameter).\n\n    ``` python\n    &gt;&gt;&gt; from dyce import P\n    &gt;&gt;&gt; p_d6 = P(6) ; p_d6  # shorthand for P(H(6))\n    P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; P(p_d6, p_d6)  # 2d6\n    2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))\n    &gt;&gt;&gt; 2@p_d6  # also 2d6\n    2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))\n    &gt;&gt;&gt; 2@(2@p_d6) == 4@p_d6\n    True\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; p = P(4, P(6, P(8, P(10, P(12, P(20)))))) ; p\n    P(H({1: 1, 2: 1, 3: 1, 4: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1, 19: 1, 20: 1}))\n    &gt;&gt;&gt; sum(p.roll()) in p.h()\n    True\n\n    ```\n\n    This class implements the [``HableT`` protocol][dyce.h.HableT] and derives from the\n    [``HableOpsMixin`` class][dyce.h.HableOpsMixin], which means it can be\n    \u201cflattened\u201d into a single histogram, either explicitly via the\n    [``h`` method][dyce.p.P.h], or implicitly by using arithmetic operations.\n\n    ``` python\n    &gt;&gt;&gt; -p_d6\n    H({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1})\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; p_d6 + p_d6\n    H({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; 2 * P(8) - 1\n    H({1: 1, 3: 1, 5: 1, 7: 1, 9: 1, 11: 1, 13: 1, 15: 1})\n\n    ```\n\n    To perform arithmetic on individual [``H`` objects][dyce.h.H] in a pool without\n    flattening, use the [``map``][dyce.p.P.map], [``rmap``][dyce.p.P.rmap], and\n    [``umap``][dyce.p.P.umap] methods.\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; P(4, 6, 8).umap(operator.__neg__)\n    P(H({-8: 1, -7: 1, -6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1}), H({-6: 1, -5: 1, -4: 1, -3: 1, -2: 1, -1: 1}), H({-4: 1, -3: 1, -2: 1, -1: 1}))\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; P(4, 6).map(operator.__pow__, 2)\n    P(H({1: 1, 4: 1, 9: 1, 16: 1}), H({1: 1, 4: 1, 9: 1, 16: 1, 25: 1, 36: 1}))\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; P(4, 6).rmap(2, operator.__pow__)\n    P(H({2: 1, 4: 1, 8: 1, 16: 1}), H({2: 1, 4: 1, 8: 1, 16: 1, 32: 1, 64: 1}))\n\n    ```\n\n    Comparisons with [``H`` objects][dyce.h.H] work as expected.\n\n    ``` python\n    &gt;&gt;&gt; from dyce import H\n    &gt;&gt;&gt; 3@p_d6 == H(6) + H(6) + H(6)\n    True\n\n    ```\n\n    Indexing selects a contained histogram.\n\n    ``` python\n    &gt;&gt;&gt; P(4, 6, 8)[0]\n    H({1: 1, 2: 1, 3: 1, 4: 1})\n\n    ```\n\n    Note that pools are opinionated about ordering.\n\n    ``` python\n    &gt;&gt;&gt; P(8, 6, 4)\n    P(H({1: 1, 2: 1, 3: 1, 4: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}))\n    &gt;&gt;&gt; P(8, 6, 4)[0] == P(8, 4, 6)[0] == H(4)\n    True\n\n    ```\n\n    In an extension to (departure from) the [``HableT`` protocol][dyce.h.HableT], the\n    [``h`` method][dyce.p.P.h]\u2019s implementation also affords subsets of outcomes to be\n    \u201ctaken\u201d (selected) by passing in selection criteria. Values are indexed from least\n    to greatest. Negative indexes are supported and retain their idiomatic meaning.\n    Modeling the sum of the greatest two faces of three six-sided dice (``3d6``) can be\n    expressed as:\n\n    ``` python\n    &gt;&gt;&gt; p_3d6 = 3@p_d6\n    &gt;&gt;&gt; p_3d6.h(-2, -1)\n    H({2: 1, 3: 3, 4: 7, 5: 12, 6: 19, 7: 27, 8: 34, 9: 36, 10: 34, 11: 27, 12: 16})\n    &gt;&gt;&gt; print(p_3d6.h(-2, -1).format())\n    avg |    8.46\n    std |    2.21\n    var |    4.91\n      2 |   0.46% |\n      3 |   1.39% |\n      4 |   3.24% |#\n      5 |   5.56% |##\n      6 |   8.80% |####\n      7 |  12.50% |######\n      8 |  15.74% |#######\n      9 |  16.67% |########\n     10 |  15.74% |#######\n     11 |  12.50% |######\n     12 |   7.41% |###\n\n    ```\n    \"\"\"\n    __slots__: Any = (\n        \"_hs\",\n        \"_total\",\n    )\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @beartype\n    # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n    def __init__(self, *args: Union[SupportsInt, \"P\", H]) -&gt; None:\n        r\"Initializer.\"\n        super().__init__()\n\n        def _gen_hs() -&gt; Iterator[H]:\n            for a in args:\n                if isinstance(a, H):\n                    yield a\n                elif isinstance(a, P):\n                    for h in a._hs:\n                        yield h\n                elif isinstance(a, SupportsInt):\n                    yield H(a)\n                else:\n                    raise TypeError(f\"unrecognized initializer type {a!r}\")\n\n        hs = list(h for h in _gen_hs() if h)\n\n        try:\n            hs.sort(key=lambda h: tuple(h.items()))\n        except TypeError:\n            # This is for outcomes that don't support direct comparisons, like symbolic\n            # representations\n            hs.sort(key=lambda h: str(tuple(h.items())))\n\n        self._hs = tuple(hs)\n        self._total: int = prod(h.total for h in self._hs)\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def total(self) -&gt; int:\nr\"\"\"\n        !!! warning \"Experimental\"\n\n            This method should be considered experimental and may change or disappear in\n            future versions.\n\n        Equivalent to ``#!python prod(h.total for h in self)``. Note that\u2014consistent\n        with the empty product\u2014this is ``#!python 1`` for an empty pool.\n        \"\"\"\n        return self._total\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        group_counters: dict[H, int] = {}\n\n        for h, hs in groupby(self):\n            n = sum(1 for _ in hs)\n            group_counters[h] = n\n\n        def _n_at(h: H, n: int) -&gt; str:\n            if n == 1:\n                return repr(h)\n            else:\n                return f\"{n}@{type(self).__name__}({repr(h)})\"\n\n        if len(group_counters) == 1:\n            h = next(iter(group_counters))\n\n            if group_counters[h] == 1:\n                return f\"{type(self).__name__}({_n_at(h, 1)})\"\n            else:\n                return _n_at(h, group_counters[h])\n        else:\n            args = \", \".join(_n_at(h, n) for h, n in group_counters.items())\n\n            return f\"{type(self).__name__}({args})\"\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        if isinstance(other, P):\n            return __eq__(self._hs, other._hs)\n        else:\n            return NotImplemented\n\n    @beartype\n    def __ne__(self, other) -&gt; bool:\n        if isinstance(other, P):\n            return __ne__(self._hs, other._hs)\n        else:\n            return NotImplemented\n\n    @beartype\n    def __len__(self) -&gt; int:\n        return len(self._hs)\n\n    @overload\n    def __getitem__(self, key: SupportsIndex) -&gt; H:\n        ...\n\n    @overload\n    def __getitem__(self, key: slice) -&gt; P:\n        ...\n\n    @beartype\n    def __getitem__(self, key: _GetItemT) -&gt; Union[H, \"P\"]:\n        if isinstance(key, slice):\n            return P(*self._hs[key])\n        else:\n            return self._hs[__index__(key)]\n\n    @beartype\n    def __iter__(self) -&gt; Iterator[H]:\n        return iter(self._hs)\n\n    @beartype\n    def __matmul__(self, other: SupportsInt) -&gt; P:\n        try:\n            other = as_int(other)\n        except TypeError:\n            return NotImplemented\n\n        if other &lt; 0:\n            raise ValueError(\"argument cannot be negative\")\n        else:\n            return P(*chain.from_iterable(repeat(self, other)))\n\n    @beartype\n    def __rmatmul__(self, other: SupportsInt) -&gt; P:\n        return self.__matmul__(other)\n\n    @beartype\n    def h(self, *which: _GetItemT) -&gt; H:\nr\"\"\"\n        Roughly equivalent to ``#!python H((sum(roll), count) for roll, count in\n        self.rolls_with_counts(*which))`` with some short-circuit optimizations.\n\n        When provided no arguments, ``#!python h`` combines (or \u201cflattens\u201d) contained\n        histograms in accordance with the [``HableT`` protocol][dyce.h.HableT].\n\n        ``` python\n        &gt;&gt;&gt; (2@P(6)).h()\n        H({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n\n        ```\n\n        If one or more arguments are provided, this method sums subsets of outcomes\n        those arguments identify for each roll. Outcomes are ordered from least (index\n        ``#!python 0``) to greatest (index ``#!python -1`` or ``#!python len(self) -\n        1``). Identifiers can be ``#!python int``s or ``#!python slice``s, and can be\n        mixed.\n\n        Taking the greatest of two six-sided dice can be modeled as:\n\n        ``` python\n        &gt;&gt;&gt; p_2d6 = 2@P(6)\n        &gt;&gt;&gt; p_2d6.h(-1)\n        H({1: 1, 2: 3, 3: 5, 4: 7, 5: 9, 6: 11})\n        &gt;&gt;&gt; print(p_2d6.h(-1).format())\n        avg |    4.47\n        std |    1.40\n        var |    1.97\n          1 |   2.78% |#\n          2 |   8.33% |####\n          3 |  13.89% |######\n          4 |  19.44% |#########\n          5 |  25.00% |############\n          6 |  30.56% |###############\n\n        ```\n\n        Taking the greatest two and least two faces of ten four-sided dice (``10d4``)\n        can be modeled as:\n\n        ``` python\n        &gt;&gt;&gt; p_10d4 = 10@P(4)\n        &gt;&gt;&gt; p_10d4.h(slice(2), slice(-2, None))\n        H({4: 1, 5: 10, 6: 1012, 7: 5030, 8: 51973, 9: 168760, 10: 595004, 11: 168760, 12: 51973, 13: 5030, 14: 1012, 15: 10, 16: 1})\n        &gt;&gt;&gt; print(p_10d4.h(slice(2), slice(-2, None)).format(scaled=True))\n        avg |   10.00\n        std |    0.91\n        var |    0.84\n          4 |   0.00% |\n          5 |   0.00% |\n          6 |   0.10% |\n          7 |   0.48% |\n          8 |   4.96% |####\n          9 |  16.09% |##############\n         10 |  56.74% |##################################################\n         11 |  16.09% |##############\n         12 |   4.96% |####\n         13 |   0.48% |\n         14 |   0.10% |\n         15 |   0.00% |\n         16 |   0.00% |\n\n        ```\n\n        Taking all outcomes exactly once is equivalent to summing the histograms in the\n        pool.\n\n        ``` python\n        &gt;&gt;&gt; d6 = H(6)\n        &gt;&gt;&gt; d6avg = H((2, 3, 3, 4, 4, 5))\n        &gt;&gt;&gt; p = 2@P(d6, d6avg)\n        &gt;&gt;&gt; p.h(slice(None)) == p.h() == d6 + d6 + d6avg + d6avg\n        True\n\n        ```\n        \"\"\"\n        if which:\n            n = len(self)\n            i = _analyze_selection(n, which)\n\n            if i and i &gt;= n:\n                # The caller selected all dice in the pool exactly i // n times, so we\n                # can short-circuit roll enumeration\n                assert i % n == 0\n\n                return self.h() * (i // n)\n            else:\n                return H(\n                    (sum(roll), count) for roll, count in self.rolls_with_counts(*which)\n                )\n        else:\n            # The caller offered no selection\n            return sum_h(self)\n\n    # ---- Methods ---------------------------------------------------------------------\n\n    @classmethod\n    @deprecated\n    @beartype\n    def foreach(\n        cls,\n        dependent_term: Callable[..., Union[H, RealLike]],\n        # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n        **independent_sources: Union[\"P\", H, HableT, _SourceT],\n    ) -&gt; H:\nr\"\"\"\n        !!! warning \"Deprecated\"\n\n            This method has been deprecated and will be removed in a future release. See\n            the [``expandable`` decorator][dyce.evaluation.expandable] and\n            [``foreach`` function][dyce.evaluation.foreach] for more flexible\n            alternatives.\n\n        Calls ``#!python dependent_term`` for each unique set of rolls from the product\n        of ``independent_sources`` and accumulates the results. This is useful for\n        resolving dependent probabilities. Rolls are sorted least to greatest. Returned\n        histograms are always reduced to their lowest terms.\n\n        ``` python\n        &gt;&gt;&gt; from dyce.p import RollT\n\n        &gt;&gt;&gt; def three_way_vs(first: RollT, second: RollT, third: RollT):\n        ...   first_reversed = first[::-1]\n        ...   second_reversed = second[::-1]\n        ...   third_reversed = third[::-1]\n        ...   if first_reversed &gt; second_reversed and first_reversed &gt; third_reversed:\n        ...     return 1  # first is the clear winner\n        ...   elif second_reversed &gt; first_reversed and second_reversed &gt; third_reversed:\n        ...     return 2  # second is the clear winner\n        ...   elif third_reversed &gt; first_reversed and third_reversed &gt; second_reversed:\n        ...     return 3  # third is the clear winner\n        ...   else:\n        ...     return 0  # there was a tie somewhere\n\n        &gt;&gt;&gt; P.foreach(\n        ...   three_way_vs,\n        ...   first=P(6, 6),  # first has pool of two d6s\n        ...   second=P(6, 6),  # second has pool of two d6s\n        ...   third=P(4, 8),  # third has pool of one d4 and one d8\n        ... )\n        H({0: 1103, 1: 5783, 2: 5783, 3: 8067})\n\n        ```\n\n        When all of ``#!python foreach``\u2019s arguments are [``P`` objects][dyce.p.P] of\n        size 1 or anything other than a ``P`` object, this function behaves similarly to\n        [``H.foreach``][dyce.h.H] (although the signature of the *dependent_term*\n        callback function differs slightly between the two interfaces).\n\n        ``` python\n        &gt;&gt;&gt; from itertools import chain\n        &gt;&gt;&gt; P.foreach(\n        ...   lambda **kw: sum(chain(*kw.values())),  # receives single-element rolls\n        ...   src1=P(6),  # pool of size 1\n        ...   src2=H(6),  # histogram\n        ...   src3=range(6, 0, -1),  # histogram source\n        ... ) == H.foreach(\n        ...   lambda **kw: sum(kw.values()),  # receives outcomes\n        ...   src1=P(6).h(),  # histogram\n        ...   src2=H(6),  # histogram\n        ...   src3={1, 2, 3, 4, 5, 6},  # histogram source\n        ... )\n        True\n\n        ```\n\n        The ``#!python foreach`` class method is equivalent to nesting loops iterating\n        over [``P.rolls_with_counts``][dyce.p.P.rolls_with_counts] for each independent\n        term and then aggregating the results.\n\n        ``` python\n        &gt;&gt;&gt; def dependent_term(\n        ...   *,\n        ...   roll_1,\n        ...   roll_2,\n        ...   # ...\n        ...   roll_n,\n        ... ):\n        ...   return (\n        ...     (roll_2[-1] &gt; roll_1[-1])\n        ...     + (roll_n[-1] &gt; roll_2[-1])\n        ...     # ...\n        ...   )\n\n        &gt;&gt;&gt; source_1 = P(8)\n        &gt;&gt;&gt; source_2 = P(6, 6)\n        &gt;&gt;&gt; # ...\n        &gt;&gt;&gt; source_n = P(4, 4, 4)\n\n        &gt;&gt;&gt; h = P.foreach(\n        ...   dependent_term,\n        ...   roll_1=source_1,\n        ...   roll_2=source_2,\n        ...   # ...\n        ...   roll_n=source_n,\n        ... ) ; h\n        H({0: 3821, 1: 5126, 2: 269})\n\n        &gt;&gt;&gt; def resolve():\n        ...   for roll_1, count_1 in source_1.rolls_with_counts():\n        ...     for roll_2, count_2 in source_2.rolls_with_counts():\n        ...       # ...\n        ...       for roll_n, count_n in source_n.rolls_with_counts():\n        ...         # ...\n        ...           yield dependent_term(\n        ...             roll_1=roll_1,\n        ...             roll_2=roll_2,\n        ...             # ...\n        ...             roll_n=roll_n,\n        ...         ), (\n        ...           count_1\n        ...           * count_2\n        ...           # * ...\n        ...           * count_n\n        ...         )\n\n        &gt;&gt;&gt; from dyce.evaluation import aggregate_weighted\n        &gt;&gt;&gt; aggregate_weighted(resolve()) == h\n        True\n\n        ```\n        \"\"\"\n        from dyce.evaluation import aggregate_weighted\n\n        pools_by_kw: dict[str, P] = {}\n\n        for source_name, source in independent_sources.items():\n            if isinstance(source, H):\n                pools_by_kw[source_name] = P(source)\n            elif isinstance(source, P):\n                pools_by_kw[source_name] = source\n            elif isinstance(source, HableT):\n                pools_by_kw[source_name] = P(source.h())\n            else:\n                pools_by_kw[source_name] = P(H(source))\n\n        def _kw_roll_count_tuples(\n            pool_name: str,\n        ) -&gt; Iterator[tuple[str, RollT, int]]:\n            for roll, count in pools_by_kw[pool_name].rolls_with_counts():\n                yield pool_name, roll, count\n\n        def _resolve_dependent_term_for_rolls() -&gt; (\n            Iterator[tuple[Union[H, RealLike], int]]\n        ):\n            for kw_roll_count_tuples in product(\n                *(_kw_roll_count_tuples(pool_name) for pool_name in pools_by_kw)\n            ):\n                combined_count = prod(count for _, _, count in kw_roll_count_tuples)\n                rolls_by_name = {name: roll for name, roll, _ in kw_roll_count_tuples}\n                yield dependent_term(**rolls_by_name), combined_count\n\n        return aggregate_weighted(_resolve_dependent_term_for_rolls()).lowest_terms()\n\n    @experimental\n    @beartype\n    def is_homogeneous(self) -&gt; bool:\nr\"\"\"\n        !!! warning \"Experimental\"\n\n            This property should be considered experimental and may change or disappear\n            in future versions.\n\n        Returns whether the pool\u2019s population of histograms is homogeneous.\n\n        ``` python\n        &gt;&gt;&gt; P(6, 6).is_homogeneous()\n        True\n        &gt;&gt;&gt; P(4, 6, 8).is_homogeneous()\n        False\n\n        ```\n        \"\"\"\n        return len(set(self._hs)) &lt;= 1\n\n    @experimental\n    @beartype\n    def appearances_in_rolls(self, outcome: RealLike) -&gt; H:\nr\"\"\"\n        !!! warning \"Experimental\"\n\n            This method should be considered experimental and may change or disappear in\n            future versions. While it does provide a performance improvement over other\n            techniques, it is not significant for most applications, and rarely\n            justifies the corresponding reduction in readability.\n\n        Returns a histogram where the outcomes (keys) are the number of times *outcome*\n        appears, and the counts are the number of rolls where *outcome* appears\n        precisely that number of times. Equivalent to ``#!python H((sum(1 for v in roll\n        if v == outcome), count) for roll, count in self.rolls_with_counts())``, but\n        much more efficient.\n\n        ``` python\n        &gt;&gt;&gt; p_2d6 = P(6, 6)\n        &gt;&gt;&gt; sorted(p_2d6.rolls_with_counts())\n        [((1, 1), 1), ((1, 2), 2), ((1, 3), 2), ((1, 4), 2), ((1, 5), 2), ((1, 6), 2), ...]\n        &gt;&gt;&gt; p_2d6.appearances_in_rolls(1)\n        H({0: 25, 1: 10, 2: 1})\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; # Least efficient, by far\n        &gt;&gt;&gt; d4, d6 = H(4), H(6)\n        &gt;&gt;&gt; p_3d4_2d6 = P(d4, d4, d4, d6, d6)\n        &gt;&gt;&gt; H((sum(1 for v in roll if v == 3), count) for roll, count in p_3d4_2d6.rolls_with_counts())\n        H({0: 675, 1: 945, 2: 522, 3: 142, 4: 19, 5: 1})\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; # Pretty darned efficient, generalizable to other boolean inquiries, and\n        &gt;&gt;&gt; # arguably the most readable\n        &gt;&gt;&gt; d4_eq3, d6_eq3 = d4.eq(3), d6.eq(3)\n        &gt;&gt;&gt; 3@d4_eq3 + 2@d6_eq3\n        H({0: 675, 1: 945, 2: 522, 3: 142, 4: 19, 5: 1})\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; # Most efficient for large sets of dice\n        &gt;&gt;&gt; p_3d4_2d6.appearances_in_rolls(3)\n        H({0: 675, 1: 945, 2: 522, 3: 142, 4: 19, 5: 1})\n\n        ```\n\n        Based on some rudimentary testing, this method appears to converge on being\n        about twice as fast as the boolean accumulation technique for larger sets.\n\n        ``` python\n        --8&lt;-- \"docs/assets/perf_appearances_in_rolls.txt\"\n        ```\n\n        &lt;details&gt;\n        &lt;summary&gt;Source: &lt;a href=\"https://github.com/posita/dyce/blob/latest/docs/assets/perf_appearances_in_rolls.ipy\"&gt;&lt;code&gt;perf_appearances_in_rolls.ipy&lt;/code&gt;&lt;/a&gt;&lt;/summary&gt;\n\n        ``` python\n        --8&lt;-- \"docs/assets/perf_appearances_in_rolls.ipy\"\n        ```\n        &lt;/details&gt;\n        \"\"\"\n        group_counters: list[Counter[RealLike]] = []\n\n        for h, hs in groupby(self):\n            group_counter: Counter[RealLike] = Counter()\n            n = sum(1 for _ in hs)\n\n            for k in range(0, n + 1):\n                group_counter[k] = h.exactly_k_times_in_n(outcome, n, k) * (\n                    group_counter[k] if group_counter[k] else 1\n                )\n\n            group_counters.append(group_counter)\n\n        return sum_h(H(group_counter) for group_counter in group_counters)\n\n    @beartype\n    def roll(self) -&gt; RollT:\nr\"\"\"\n        Returns (weighted) random outcomes from contained histograms.\n\n        !!! note \"On ordering\"\n\n            This method \u201cworks\u201d (i.e., falls back to a \u201cnatural\u201d ordering of string\n            representations) for outcomes whose relative values cannot be known (e.g.,\n            symbolic expressions). This is deliberate to allow random roll functionality\n            where symbolic resolution is not needed or will happen later.\n        \"\"\"\n        return tuple(sorted_outcomes(h.roll() for h in self))\n\n    @beartype\n    def rolls_with_counts(self, *which: _GetItemT) -&gt; Iterator[_RollCountT]:\nr\"\"\"\n        Returns an iterator yielding two-tuples (pairs) that, collectively, enumerate all\n        possible outcomes for the pool. The first item in the two-tuple is a sorted\n        sequence of the outcomes for a distinct roll. The second is the count for that\n        roll. Outcomes in each roll are ordered least to greatest.\n\n        If one or more arguments are provided, this methods selects subsets of outcomes\n        for each roll. Outcomes in each roll are ordered from least (index ``#!python\n        0``) to greatest (index ``#!python -1`` or ``#!python len(self) - 1``).\n        Identifiers can be ``#!python int``s or ``#!python slice``s, and can be mixed\n        for more flexible selections.\n\n        ``` python\n        &gt;&gt;&gt; from collections import Counter\n\n        &gt;&gt;&gt; def accumulate_roll_counts(counter, roll_counts):\n        ...   for roll, count in roll_counts:\n        ...     counter[roll] += count\n        ...   return counter\n\n        &gt;&gt;&gt; p_6d6 = 6@P(6)\n        &gt;&gt;&gt; every_other_d6 = accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(slice(None, None, -2))) ; every_other_d6\n        Counter({(6, 4, 2): 4110, (6, 5, 3): 3390, (6, 4, 3): 3330, ..., (3, 3, 3): 13, (2, 2, 2): 7, (1, 1, 1): 1})\n        &gt;&gt;&gt; accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(5, 3, 1)) == every_other_d6\n        True\n        &gt;&gt;&gt; accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(*range(5, 0, -2))) == every_other_d6\n        True\n        &gt;&gt;&gt; accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(*(i for i in range(6, 0, -1) if i % 2 == 1))) == every_other_d6\n        True\n\n        ```\n\n        One way to model the likelihood of achieving a \u201cYhatzee\u201d (i.e., where five\n        six-sided dice show the same face) on a single roll by checking rolls for where\n        the least and greatest outcomes are the same.\n\n        ``` python\n        &gt;&gt;&gt; p_5d6 = 5@P(6)\n        &gt;&gt;&gt; yhatzee_on_single_roll = H(\n        ...   (1 if roll[0] == roll[-1] else 0, count)\n        ...   for roll, count\n        ...   in p_5d6.rolls_with_counts()\n        ... )\n        &gt;&gt;&gt; print(yhatzee_on_single_roll.format(width=0))\n        {..., 0: 99.92%, 1:  0.08%}\n\n        ```\n\n        !!! note \"In the general case, rolls may appear more than once.\"\n\n            ``` python\n            &gt;&gt;&gt; sorted(P(H(2), H(3)).rolls_with_counts())\n            [((1, 1), 1), ((1, 2), 1), ((1, 2), 1), ((1, 3), 1), ((2, 2), 1), ((2, 3), 1)]\n\n            ```\n\n            In the above, ``#!python (1, 2)`` appears a total of two times, each with\n            counts of one.\n\n            However, if the pool is homogeneous (meaning it only contains identical\n            histograms), rolls (before selection) are not repeated. (See the note on\n            implementation below.)\n\n            ``` python\n            &gt;&gt;&gt; sorted((2@P(H((-1, 0, 1)))).rolls_with_counts())\n            [((-1, -1), 1), ((-1, 0), 2), ((-1, 1), 2), ((0, 0), 1), ((0, 1), 2), ((1, 1), 1)]\n\n            ```\n\n            Either way, by summing and counting all rolls, we can confirm identity.\n\n            ``` python\n            &gt;&gt;&gt; d6 = H(6)\n            &gt;&gt;&gt; d6avg = H((2, 3, 3, 4, 4, 5))\n            &gt;&gt;&gt; p = 2@P(d6, d6avg)\n            &gt;&gt;&gt; H((sum(roll), count) for roll, count in p.rolls_with_counts()) == p.h() == d6 + d6 + d6avg + d6avg\n            True\n\n            ```\n\n        This method does not try to outsmart callers by (mis)interpreting selection\n        arguments. It honors selection identifier order and any redundancy.\n\n        ``` python\n        &gt;&gt;&gt; p_d3_d4 = P(H(3), H(4))\n        &gt;&gt;&gt; # Select the second, first, then second (again) elements\n        &gt;&gt;&gt; sorted(p_d3_d4.rolls_with_counts(-1, 0, 1))\n        [((1, 1, 1), 1), ((2, 1, 2), 1), ((2, 1, 2), 1), ..., ((4, 1, 4), 1), ((4, 2, 4), 1), ((4, 3, 4), 1)]\n\n        ```\n\n        Selecting the same outcomes, but in a different order is not immediately\n        comparable.\n\n        ``` python\n        &gt;&gt;&gt; select_0_1 = sorted(p_d3_d4.rolls_with_counts(0, 1))\n        &gt;&gt;&gt; select_1_0 = sorted(p_d3_d4.rolls_with_counts(1, 0))\n        &gt;&gt;&gt; select_0_1 == select_1_0\n        False\n\n        ```\n\n        Equivalence can be tested when selected outcomes are sorted.\n\n        ``` python\n        &gt;&gt;&gt; sorted_0_1 = sorted((sorted(roll), count) for roll, count in select_0_1)\n        &gt;&gt;&gt; sorted_1_0 = sorted((sorted(roll), count) for roll, count in select_1_0)\n        &gt;&gt;&gt; sorted_0_1 == sorted_1_0\n        True\n\n        ```\n\n        They can also be summed and counted which is equivalent to calling the\n        [``h`` method][dyce.p.P.h] with identical selection arguments.\n\n        ``` python\n        &gt;&gt;&gt; summed_0_1 = H((sum(roll), count) for roll, count in select_0_1)\n        &gt;&gt;&gt; summed_1_0 = H((sum(roll), count) for roll, count in select_1_0)\n        &gt;&gt;&gt; summed_0_1 == summed_1_0 == p_d3_d4.h(0, 1) == p_d3_d4.h(1, 0)\n        True\n\n        ```\n\n        !!! info \"About the implementation\"\n\n            Enumeration is substantially more efficient for homogeneous pools than\n            heterogeneous ones, because we are able to avoid the expensive enumeration\n            of the Cartesian product using several techniques.\n\n            Taking $k$ outcomes, where $k$ selects fewer than all $n$ outcomes a\n            homogeneous pool benefits from [Ilmari Karonen\u2019s\n            optimization](https://rpg.stackexchange.com/a/166663/71245), which appears\n            to scale geometrically with $k$ times some factor of $n$ (e.g., $\\log n$,\n            but I haven\u2019t bothered to figure that out yet), such that\u2014in observed\n            testing, at least\u2014it is generally the fastest approach for $k &lt; n$.\n\n            Where $k = n$, we leverage the [*multinomial\n            coefficient*](https://en.wikipedia.org/wiki/Permutation#Permutations_of_multisets),\n            which appears to scale generally with $n$.\n\n            $$\n            {{n} \\choose {{{k}_{1}},{{k}_{2}},\\ldots,{{k}_{m}}}}\n            = {\\frac {{n}!} {{{k}_{1}}! {{k}_{2}}! \\cdots {{k}_{m}}!}}\n            $$\n\n            We enumerate combinations with replacements, and then the compute the number\n            of permutations with repetitions for each combination. Consider ``#!python\n            n@P(H(m))``. Enumerating combinations with replacements would yield all\n            unique rolls.\n\n            ``#!python ((1, 1, \u2026, 1), (1, 1, \u2026, 2), \u2026, (1, 1, \u2026, m), \u2026, (m - 1, m, \u2026,\n            m), (m, m, \u2026, m))``\n\n            To determine the count for a particular roll ``#!python (a, b, \u2026, n)``, we\n            compute the multinomial coefficient for that roll and multiply by the scalar\n            ``#!python H(m)[a] * H(m)[b] * \u2026 * H(m)[n]``. (See\n            [this](https://www.lucamoroni.it/the-dice-roll-sum-problem/) for an in-depth\n            exploration of the topic.)\n\n            Further, this implementation attempts to optimize heterogeneous pools by\n            breaking them into homogeneous groups before computing the Cartesian product\n            of those sub-results. This approach allows homogeneous pools to be ordered\n            without duplicates, where heterogeneous ones offer no such guarantees.\n\n            As expected, this optimization allows the performance of arbitrary selection\n            from mixed pools to sit between that of purely homogeneous and purely\n            heterogeneous ones. Note, however, that all three appear to scale\n            geometrically in some way.\n\n            ``` python\n            --8&lt;-- \"docs/assets/perf_rolls_with_counts.txt\"\n            ```\n\n            &lt;details&gt;\n            &lt;summary&gt;Source: &lt;a href=\"https://github.com/posita/dyce/blob/latest/docs/assets/perf_rolls_with_counts.ipy\"&gt;&lt;code&gt;perf_rolls_with_counts.ipy&lt;/code&gt;&lt;/a&gt;&lt;/summary&gt;\n\n            ``` python\n            --8&lt;-- \"docs/assets/perf_rolls_with_counts.ipy\"\n            ```\n            &lt;/details&gt;\n        \"\"\"\n        n = len(self)\n\n        if not which:\n            i: Optional[int] = n\n        else:\n            i = _analyze_selection(n, which)\n\n        if i == 0 or n == 0:\n            rolls_with_counts_iter: Iterable[_RollCountT] = iter(())\n        else:\n            groups = tuple((h, sum(1 for _ in hs)) for h, hs in groupby(self))\n\n            if len(groups) == 1:\n                # Based on cursory performance analysis, calling the homogeneous\n                # implementation directly provides about a 15% performance savings over\n                # merely falling through to _rwc_heterogeneous_h_groups. Maybe\n                # itertools.product adds significant overhead?\n                h, hn = groups[0]\n                assert hn == n\n\n                # Still in search of a better (i.e., more efficient) way:\n                # &lt;https://math.stackexchange.com/questions/4173084/probability-distribution-of-k-1-k-2-cdots-k-m-selections-of-arbitrary-posi&gt;\n                if i and abs(i) &lt; n:\n                    rolls_with_counts_iter = _rwc_homogeneous_n_h_using_partial_selection(\n                        n,\n                        h,\n                        i,\n                        # This is just padding to allow for consistent indexing. They\n                        # are deselected (i.e., not returned) below.\n                        fill=0,\n                    )\n                else:\n                    rolls_with_counts_iter = (\n                        _rwc_homogeneous_n_h_using_partial_selection(n, h, n)\n                    )\n            else:\n                rolls_with_counts_iter = _rwc_heterogeneous_h_groups(groups, i)\n\n        for sorted_outcomes_for_roll, roll_count in rolls_with_counts_iter:\n            if which:\n                taken_outcomes = tuple(getitems(sorted_outcomes_for_roll, which))\n            else:\n                taken_outcomes = sorted_outcomes_for_roll\n\n            yield taken_outcomes, roll_count\n\n    @beartype\n    def map(self, op: _BinaryOperatorT, right_operand: _OperandT) -&gt; P:\nr\"\"\"\n        Shorthand for ``#!python P(*(h.map(op, right_operand) for h in self))``. See the\n        [``H.map`` method][dyce.h.H.map].\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; p_3d6 = 3@P(H((-3, -1, 2, 4)))\n        &gt;&gt;&gt; p_3d6.map(operator.__mul__, -1)\n        3@P(H({-4: 1, -2: 1, 1: 1, 3: 1}))\n\n        ```\n        \"\"\"\n        return P(*(h.map(op, right_operand) for h in self))\n\n    @beartype\n    def rmap(self, left_operand: RealLike, op: _BinaryOperatorT) -&gt; P:\nr\"\"\"\n        Shorthand for ``#!python P(*(h.rmap(left_operand, op) for h in self))``. See the\n        [``H.rmap`` method][dyce.h.H.rmap].\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; from fractions import Fraction\n        &gt;&gt;&gt; p_3d6 = 2@P(H((-3, -1, 2, 4)))\n        &gt;&gt;&gt; p_3d6.umap(Fraction).rmap(1, operator.__truediv__)\n        2@P(H({Fraction(-1, 1): 1, Fraction(-1, 3): 1, Fraction(1, 4): 1, Fraction(1, 2): 1}))\n\n        ```\n        \"\"\"\n        return P(*(h.rmap(left_operand, op) for h in self))\n\n    @beartype\n    def umap(self, op: _UnaryOperatorT) -&gt; P:\nr\"\"\"\n        Shorthand for ``#!python P(*(h.umap(op) for h in self))``. See the\n        [``H.umap`` method][dyce.h.H.umap].\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; p_3d6 = 3@P(H((-3, -1, 2, 4)))\n        &gt;&gt;&gt; p_3d6.umap(operator.__neg__)\n        3@P(H({-4: 1, -2: 1, 1: 1, 3: 1}))\n        &gt;&gt;&gt; p_3d6.umap(operator.__abs__)\n        3@P(H({1: 1, 2: 1, 3: 1, 4: 1}))\n\n        ```\n        \"\"\"\n        return P(*(h.umap(op) for h in self))\n</code></pre>"},{"location":"dyce/#dyce.p.P.__slots__","title":"<code>__slots__: Any = ('_hs', '_total')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce/#dyce.p.P.total","title":"<code>total: int</code>  <code>property</code>","text":"<p>Experimental</p> <p>This method should be considered experimental and may change or disappear in future versions.</p> <p>Equivalent to <code>prod(h.total for h in self)</code>. Note that\u2014consistent with the empty product\u2014this is <code>1</code> for an empty pool.</p>"},{"location":"dyce/#dyce.p.P.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    if isinstance(other, P):\n        return __eq__(self._hs, other._hs)\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.p.P.__getitem__","title":"<code>__getitem__(key: _GetItemT) -&gt; Union[H, 'P']</code>","text":"Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef __getitem__(self, key: _GetItemT) -&gt; Union[H, \"P\"]:\n    if isinstance(key, slice):\n        return P(*self._hs[key])\n    else:\n        return self._hs[__index__(key)]\n</code></pre>"},{"location":"dyce/#dyce.p.P.__init__","title":"<code>__init__(*args: Union[SupportsInt, 'P', H]) -&gt; None</code>","text":"<p>Initializer.</p> Source code in <code>dyce/p.py</code> <pre><code>@beartype\n# TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\ndef __init__(self, *args: Union[SupportsInt, \"P\", H]) -&gt; None:\n    r\"Initializer.\"\n    super().__init__()\n\n    def _gen_hs() -&gt; Iterator[H]:\n        for a in args:\n            if isinstance(a, H):\n                yield a\n            elif isinstance(a, P):\n                for h in a._hs:\n                    yield h\n            elif isinstance(a, SupportsInt):\n                yield H(a)\n            else:\n                raise TypeError(f\"unrecognized initializer type {a!r}\")\n\n    hs = list(h for h in _gen_hs() if h)\n\n    try:\n        hs.sort(key=lambda h: tuple(h.items()))\n    except TypeError:\n        # This is for outcomes that don't support direct comparisons, like symbolic\n        # representations\n        hs.sort(key=lambda h: str(tuple(h.items())))\n\n    self._hs = tuple(hs)\n    self._total: int = prod(h.total for h in self._hs)\n</code></pre>"},{"location":"dyce/#dyce.p.P.__iter__","title":"<code>__iter__() -&gt; Iterator[H]</code>","text":"Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef __iter__(self) -&gt; Iterator[H]:\n    return iter(self._hs)\n</code></pre>"},{"location":"dyce/#dyce.p.P.__len__","title":"<code>__len__() -&gt; int</code>","text":"Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef __len__(self) -&gt; int:\n    return len(self._hs)\n</code></pre>"},{"location":"dyce/#dyce.p.P.__matmul__","title":"<code>__matmul__(other: SupportsInt) -&gt; P</code>","text":"Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef __matmul__(self, other: SupportsInt) -&gt; P:\n    try:\n        other = as_int(other)\n    except TypeError:\n        return NotImplemented\n\n    if other &lt; 0:\n        raise ValueError(\"argument cannot be negative\")\n    else:\n        return P(*chain.from_iterable(repeat(self, other)))\n</code></pre>"},{"location":"dyce/#dyce.p.P.__ne__","title":"<code>__ne__(other) -&gt; bool</code>","text":"Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef __ne__(self, other) -&gt; bool:\n    if isinstance(other, P):\n        return __ne__(self._hs, other._hs)\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"dyce/#dyce.p.P.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef __repr__(self) -&gt; str:\n    group_counters: dict[H, int] = {}\n\n    for h, hs in groupby(self):\n        n = sum(1 for _ in hs)\n        group_counters[h] = n\n\n    def _n_at(h: H, n: int) -&gt; str:\n        if n == 1:\n            return repr(h)\n        else:\n            return f\"{n}@{type(self).__name__}({repr(h)})\"\n\n    if len(group_counters) == 1:\n        h = next(iter(group_counters))\n\n        if group_counters[h] == 1:\n            return f\"{type(self).__name__}({_n_at(h, 1)})\"\n        else:\n            return _n_at(h, group_counters[h])\n    else:\n        args = \", \".join(_n_at(h, n) for h, n in group_counters.items())\n\n        return f\"{type(self).__name__}({args})\"\n</code></pre>"},{"location":"dyce/#dyce.p.P.__rmatmul__","title":"<code>__rmatmul__(other: SupportsInt) -&gt; P</code>","text":"Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef __rmatmul__(self, other: SupportsInt) -&gt; P:\n    return self.__matmul__(other)\n</code></pre>"},{"location":"dyce/#dyce.p.P.appearances_in_rolls","title":"<code>appearances_in_rolls(outcome: RealLike) -&gt; H</code>","text":"<p>Experimental</p> <p>This method should be considered experimental and may change or disappear in future versions. While it does provide a performance improvement over other techniques, it is not significant for most applications, and rarely justifies the corresponding reduction in readability.</p> <p>Returns a histogram where the outcomes (keys) are the number of times outcome appears, and the counts are the number of rolls where outcome appears precisely that number of times. Equivalent to <code>H((sum(1 for v in rollif v == outcome), count) for roll, count in self.rolls_with_counts())</code>, but much more efficient.</p> <pre><code>&gt;&gt;&gt; p_2d6 = P(6, 6)\n&gt;&gt;&gt; sorted(p_2d6.rolls_with_counts())\n[((1, 1), 1), ((1, 2), 2), ((1, 3), 2), ((1, 4), 2), ((1, 5), 2), ((1, 6), 2), ...]\n&gt;&gt;&gt; p_2d6.appearances_in_rolls(1)\nH({0: 25, 1: 10, 2: 1})\n</code></pre> <pre><code>&gt;&gt;&gt; # Least efficient, by far\n&gt;&gt;&gt; d4, d6 = H(4), H(6)\n&gt;&gt;&gt; p_3d4_2d6 = P(d4, d4, d4, d6, d6)\n&gt;&gt;&gt; H((sum(1 for v in roll if v == 3), count) for roll, count in p_3d4_2d6.rolls_with_counts())\nH({0: 675, 1: 945, 2: 522, 3: 142, 4: 19, 5: 1})\n</code></pre> <pre><code>&gt;&gt;&gt; # Pretty darned efficient, generalizable to other boolean inquiries, and\n&gt;&gt;&gt; # arguably the most readable\n&gt;&gt;&gt; d4_eq3, d6_eq3 = d4.eq(3), d6.eq(3)\n&gt;&gt;&gt; 3@d4_eq3 + 2@d6_eq3\nH({0: 675, 1: 945, 2: 522, 3: 142, 4: 19, 5: 1})\n</code></pre> <pre><code>&gt;&gt;&gt; # Most efficient for large sets of dice\n&gt;&gt;&gt; p_3d4_2d6.appearances_in_rolls(3)\nH({0: 675, 1: 945, 2: 522, 3: 142, 4: 19, 5: 1})\n</code></pre> <p>Based on some rudimentary testing, this method appears to converge on being about twice as fast as the boolean accumulation technique for larger sets.</p> <pre><code>%timeit 3@d4_eq3 + 2@d6_eq3\n32.2 \u00b5s \u00b1 369 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n%timeit P(3@P(4), 2@P(6)).appearances_in_rolls(3)\n66.7 \u00b5s \u00b1 244 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n%timeit 9@d4_eq3 + 6@d6_eq3\n137 \u00b5s \u00b1 2.24 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n%timeit P(9@P(4), 6@P(6)).appearances_in_rolls(3)\n124 \u00b5s \u00b1 374 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n%timeit 27@d4_eq3 + 18@d6_eq3\n830 \u00b5s \u00b1 3.94 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n\n%timeit P(27@P(4), 18@P(6)).appearances_in_rolls(3)\n437 \u00b5s \u00b1 1.03 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n\n%timeit 81@d4_eq3 + 54@d6_eq3\n6.54 ms \u00b1 24.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n\n%timeit P(81@P(4), 54@P(6)).appearances_in_rolls(3)\n2.69 ms \u00b1 16.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n</code></pre> Source: <code>perf_appearances_in_rolls.ipy</code> <pre><code>from dyce import H, P\n\np_2d6 = P(6, 6)\nd4, d6 = H(4), H(6)\np_3d4_2d6 = P(d4, d4, d4, d6, d6)\nd4_eq3, d6_eq3 = d4.eq(2), d6.eq(2)\n\nprint(f\"%timeit 3@d4_eq3 + 2@d6_eq3\")\n%timeit 3@d4_eq3 + 2@d6_eq3\nprint()\n\nprint(f\"%timeit P(3@P(4), 2@P(6)).appearances_in_rolls(3)\")\n%timeit P(3@P(4), 2@P(6)).appearances_in_rolls(3)\nprint()\n\nprint(f\"%timeit 9@d4_eq3 + 6@d6_eq3\")\n%timeit 9@d4_eq3 + 6@d6_eq3\nprint()\n\nprint(f\"%timeit P(9@P(4), 6@P(6)).appearances_in_rolls(3)\")\n%timeit P(9@P(4), 6@P(6)).appearances_in_rolls(3)\nprint()\n\nprint(f\"%timeit 27@d4_eq3 + 18@d6_eq3\")\n%timeit 27@d4_eq3 + 18@d6_eq3\nprint()\n\nprint(f\"%timeit P(27@P(4), 18@P(6)).appearances_in_rolls(3)\")\n%timeit P(27@P(4), 18@P(6)).appearances_in_rolls(3)\nprint()\n\nprint(f\"%timeit 81@d4_eq3 + 54@d6_eq3\")\n%timeit 81@d4_eq3 + 54@d6_eq3\nprint()\n\nprint(f\"%timeit P(81@P(4), 54@P(6)).appearances_in_rolls(3)\")\n%timeit P(81@P(4), 54@P(6)).appearances_in_rolls(3)\nprint()\n</code></pre> Source code in <code>dyce/p.py</code> <pre><code>@experimental\n@beartype\ndef appearances_in_rolls(self, outcome: RealLike) -&gt; H:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This method should be considered experimental and may change or disappear in\n        future versions. While it does provide a performance improvement over other\n        techniques, it is not significant for most applications, and rarely\n        justifies the corresponding reduction in readability.\n\n    Returns a histogram where the outcomes (keys) are the number of times *outcome*\n    appears, and the counts are the number of rolls where *outcome* appears\n    precisely that number of times. Equivalent to ``#!python H((sum(1 for v in roll\n    if v == outcome), count) for roll, count in self.rolls_with_counts())``, but\n    much more efficient.\n\n    ``` python\n    &gt;&gt;&gt; p_2d6 = P(6, 6)\n    &gt;&gt;&gt; sorted(p_2d6.rolls_with_counts())\n    [((1, 1), 1), ((1, 2), 2), ((1, 3), 2), ((1, 4), 2), ((1, 5), 2), ((1, 6), 2), ...]\n    &gt;&gt;&gt; p_2d6.appearances_in_rolls(1)\n    H({0: 25, 1: 10, 2: 1})\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; # Least efficient, by far\n    &gt;&gt;&gt; d4, d6 = H(4), H(6)\n    &gt;&gt;&gt; p_3d4_2d6 = P(d4, d4, d4, d6, d6)\n    &gt;&gt;&gt; H((sum(1 for v in roll if v == 3), count) for roll, count in p_3d4_2d6.rolls_with_counts())\n    H({0: 675, 1: 945, 2: 522, 3: 142, 4: 19, 5: 1})\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; # Pretty darned efficient, generalizable to other boolean inquiries, and\n    &gt;&gt;&gt; # arguably the most readable\n    &gt;&gt;&gt; d4_eq3, d6_eq3 = d4.eq(3), d6.eq(3)\n    &gt;&gt;&gt; 3@d4_eq3 + 2@d6_eq3\n    H({0: 675, 1: 945, 2: 522, 3: 142, 4: 19, 5: 1})\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; # Most efficient for large sets of dice\n    &gt;&gt;&gt; p_3d4_2d6.appearances_in_rolls(3)\n    H({0: 675, 1: 945, 2: 522, 3: 142, 4: 19, 5: 1})\n\n    ```\n\n    Based on some rudimentary testing, this method appears to converge on being\n    about twice as fast as the boolean accumulation technique for larger sets.\n\n    ``` python\n    --8&lt;-- \"docs/assets/perf_appearances_in_rolls.txt\"\n    ```\n\n    &lt;details&gt;\n    &lt;summary&gt;Source: &lt;a href=\"https://github.com/posita/dyce/blob/latest/docs/assets/perf_appearances_in_rolls.ipy\"&gt;&lt;code&gt;perf_appearances_in_rolls.ipy&lt;/code&gt;&lt;/a&gt;&lt;/summary&gt;\n\n    ``` python\n    --8&lt;-- \"docs/assets/perf_appearances_in_rolls.ipy\"\n    ```\n    &lt;/details&gt;\n    \"\"\"\n    group_counters: list[Counter[RealLike]] = []\n\n    for h, hs in groupby(self):\n        group_counter: Counter[RealLike] = Counter()\n        n = sum(1 for _ in hs)\n\n        for k in range(0, n + 1):\n            group_counter[k] = h.exactly_k_times_in_n(outcome, n, k) * (\n                group_counter[k] if group_counter[k] else 1\n            )\n\n        group_counters.append(group_counter)\n\n    return sum_h(H(group_counter) for group_counter in group_counters)\n</code></pre>"},{"location":"dyce/#dyce.p.P.foreach","title":"<code>foreach(dependent_term: Callable[..., Union[H, RealLike]], **independent_sources: Union['P', H, HableT, _SourceT]) -&gt; H</code>  <code>classmethod</code>","text":"<p>Deprecated</p> <p>This method has been deprecated and will be removed in a future release. See the <code>expandable</code> decorator and <code>foreach</code> function for more flexible alternatives.</p> <p>Calls <code>dependent_term</code> for each unique set of rolls from the product of <code>independent_sources</code> and accumulates the results. This is useful for resolving dependent probabilities. Rolls are sorted least to greatest. Returned histograms are always reduced to their lowest terms.</p> <pre><code>&gt;&gt;&gt; from dyce.p import RollT\n\n&gt;&gt;&gt; def three_way_vs(first: RollT, second: RollT, third: RollT):\n...   first_reversed = first[::-1]\n...   second_reversed = second[::-1]\n...   third_reversed = third[::-1]\n...   if first_reversed &gt; second_reversed and first_reversed &gt; third_reversed:\n...     return 1  # first is the clear winner\n...   elif second_reversed &gt; first_reversed and second_reversed &gt; third_reversed:\n...     return 2  # second is the clear winner\n...   elif third_reversed &gt; first_reversed and third_reversed &gt; second_reversed:\n...     return 3  # third is the clear winner\n...   else:\n...     return 0  # there was a tie somewhere\n\n&gt;&gt;&gt; P.foreach(\n...   three_way_vs,\n...   first=P(6, 6),  # first has pool of two d6s\n...   second=P(6, 6),  # second has pool of two d6s\n...   third=P(4, 8),  # third has pool of one d4 and one d8\n... )\nH({0: 1103, 1: 5783, 2: 5783, 3: 8067})\n</code></pre> <p>When all of <code>foreach</code>\u2019s arguments are <code>P</code> objects of size 1 or anything other than a <code>P</code> object, this function behaves similarly to <code>H.foreach</code> (although the signature of the dependent_term callback function differs slightly between the two interfaces).</p> <pre><code>&gt;&gt;&gt; from itertools import chain\n&gt;&gt;&gt; P.foreach(\n...   lambda **kw: sum(chain(*kw.values())),  # receives single-element rolls\n...   src1=P(6),  # pool of size 1\n...   src2=H(6),  # histogram\n...   src3=range(6, 0, -1),  # histogram source\n... ) == H.foreach(\n...   lambda **kw: sum(kw.values()),  # receives outcomes\n...   src1=P(6).h(),  # histogram\n...   src2=H(6),  # histogram\n...   src3={1, 2, 3, 4, 5, 6},  # histogram source\n... )\nTrue\n</code></pre> <p>The <code>foreach</code> class method is equivalent to nesting loops iterating over <code>P.rolls_with_counts</code> for each independent term and then aggregating the results.</p> <pre><code>&gt;&gt;&gt; def dependent_term(\n...   *,\n...   roll_1,\n...   roll_2,\n...   # ...\n...   roll_n,\n... ):\n...   return (\n...     (roll_2[-1] &gt; roll_1[-1])\n...     + (roll_n[-1] &gt; roll_2[-1])\n...     # ...\n...   )\n\n&gt;&gt;&gt; source_1 = P(8)\n&gt;&gt;&gt; source_2 = P(6, 6)\n&gt;&gt;&gt; # ...\n&gt;&gt;&gt; source_n = P(4, 4, 4)\n\n&gt;&gt;&gt; h = P.foreach(\n...   dependent_term,\n...   roll_1=source_1,\n...   roll_2=source_2,\n...   # ...\n...   roll_n=source_n,\n... ) ; h\nH({0: 3821, 1: 5126, 2: 269})\n\n&gt;&gt;&gt; def resolve():\n...   for roll_1, count_1 in source_1.rolls_with_counts():\n...     for roll_2, count_2 in source_2.rolls_with_counts():\n...       # ...\n...       for roll_n, count_n in source_n.rolls_with_counts():\n...         # ...\n...           yield dependent_term(\n...             roll_1=roll_1,\n...             roll_2=roll_2,\n...             # ...\n...             roll_n=roll_n,\n...         ), (\n...           count_1\n...           * count_2\n...           # * ...\n...           * count_n\n...         )\n\n&gt;&gt;&gt; from dyce.evaluation import aggregate_weighted\n&gt;&gt;&gt; aggregate_weighted(resolve()) == h\nTrue\n</code></pre> Source code in <code>dyce/p.py</code> <pre><code>@classmethod\n@deprecated\n@beartype\ndef foreach(\n    cls,\n    dependent_term: Callable[..., Union[H, RealLike]],\n    # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n    **independent_sources: Union[\"P\", H, HableT, _SourceT],\n) -&gt; H:\nr\"\"\"\n    !!! warning \"Deprecated\"\n\n        This method has been deprecated and will be removed in a future release. See\n        the [``expandable`` decorator][dyce.evaluation.expandable] and\n        [``foreach`` function][dyce.evaluation.foreach] for more flexible\n        alternatives.\n\n    Calls ``#!python dependent_term`` for each unique set of rolls from the product\n    of ``independent_sources`` and accumulates the results. This is useful for\n    resolving dependent probabilities. Rolls are sorted least to greatest. Returned\n    histograms are always reduced to their lowest terms.\n\n    ``` python\n    &gt;&gt;&gt; from dyce.p import RollT\n\n    &gt;&gt;&gt; def three_way_vs(first: RollT, second: RollT, third: RollT):\n    ...   first_reversed = first[::-1]\n    ...   second_reversed = second[::-1]\n    ...   third_reversed = third[::-1]\n    ...   if first_reversed &gt; second_reversed and first_reversed &gt; third_reversed:\n    ...     return 1  # first is the clear winner\n    ...   elif second_reversed &gt; first_reversed and second_reversed &gt; third_reversed:\n    ...     return 2  # second is the clear winner\n    ...   elif third_reversed &gt; first_reversed and third_reversed &gt; second_reversed:\n    ...     return 3  # third is the clear winner\n    ...   else:\n    ...     return 0  # there was a tie somewhere\n\n    &gt;&gt;&gt; P.foreach(\n    ...   three_way_vs,\n    ...   first=P(6, 6),  # first has pool of two d6s\n    ...   second=P(6, 6),  # second has pool of two d6s\n    ...   third=P(4, 8),  # third has pool of one d4 and one d8\n    ... )\n    H({0: 1103, 1: 5783, 2: 5783, 3: 8067})\n\n    ```\n\n    When all of ``#!python foreach``\u2019s arguments are [``P`` objects][dyce.p.P] of\n    size 1 or anything other than a ``P`` object, this function behaves similarly to\n    [``H.foreach``][dyce.h.H] (although the signature of the *dependent_term*\n    callback function differs slightly between the two interfaces).\n\n    ``` python\n    &gt;&gt;&gt; from itertools import chain\n    &gt;&gt;&gt; P.foreach(\n    ...   lambda **kw: sum(chain(*kw.values())),  # receives single-element rolls\n    ...   src1=P(6),  # pool of size 1\n    ...   src2=H(6),  # histogram\n    ...   src3=range(6, 0, -1),  # histogram source\n    ... ) == H.foreach(\n    ...   lambda **kw: sum(kw.values()),  # receives outcomes\n    ...   src1=P(6).h(),  # histogram\n    ...   src2=H(6),  # histogram\n    ...   src3={1, 2, 3, 4, 5, 6},  # histogram source\n    ... )\n    True\n\n    ```\n\n    The ``#!python foreach`` class method is equivalent to nesting loops iterating\n    over [``P.rolls_with_counts``][dyce.p.P.rolls_with_counts] for each independent\n    term and then aggregating the results.\n\n    ``` python\n    &gt;&gt;&gt; def dependent_term(\n    ...   *,\n    ...   roll_1,\n    ...   roll_2,\n    ...   # ...\n    ...   roll_n,\n    ... ):\n    ...   return (\n    ...     (roll_2[-1] &gt; roll_1[-1])\n    ...     + (roll_n[-1] &gt; roll_2[-1])\n    ...     # ...\n    ...   )\n\n    &gt;&gt;&gt; source_1 = P(8)\n    &gt;&gt;&gt; source_2 = P(6, 6)\n    &gt;&gt;&gt; # ...\n    &gt;&gt;&gt; source_n = P(4, 4, 4)\n\n    &gt;&gt;&gt; h = P.foreach(\n    ...   dependent_term,\n    ...   roll_1=source_1,\n    ...   roll_2=source_2,\n    ...   # ...\n    ...   roll_n=source_n,\n    ... ) ; h\n    H({0: 3821, 1: 5126, 2: 269})\n\n    &gt;&gt;&gt; def resolve():\n    ...   for roll_1, count_1 in source_1.rolls_with_counts():\n    ...     for roll_2, count_2 in source_2.rolls_with_counts():\n    ...       # ...\n    ...       for roll_n, count_n in source_n.rolls_with_counts():\n    ...         # ...\n    ...           yield dependent_term(\n    ...             roll_1=roll_1,\n    ...             roll_2=roll_2,\n    ...             # ...\n    ...             roll_n=roll_n,\n    ...         ), (\n    ...           count_1\n    ...           * count_2\n    ...           # * ...\n    ...           * count_n\n    ...         )\n\n    &gt;&gt;&gt; from dyce.evaluation import aggregate_weighted\n    &gt;&gt;&gt; aggregate_weighted(resolve()) == h\n    True\n\n    ```\n    \"\"\"\n    from dyce.evaluation import aggregate_weighted\n\n    pools_by_kw: dict[str, P] = {}\n\n    for source_name, source in independent_sources.items():\n        if isinstance(source, H):\n            pools_by_kw[source_name] = P(source)\n        elif isinstance(source, P):\n            pools_by_kw[source_name] = source\n        elif isinstance(source, HableT):\n            pools_by_kw[source_name] = P(source.h())\n        else:\n            pools_by_kw[source_name] = P(H(source))\n\n    def _kw_roll_count_tuples(\n        pool_name: str,\n    ) -&gt; Iterator[tuple[str, RollT, int]]:\n        for roll, count in pools_by_kw[pool_name].rolls_with_counts():\n            yield pool_name, roll, count\n\n    def _resolve_dependent_term_for_rolls() -&gt; (\n        Iterator[tuple[Union[H, RealLike], int]]\n    ):\n        for kw_roll_count_tuples in product(\n            *(_kw_roll_count_tuples(pool_name) for pool_name in pools_by_kw)\n        ):\n            combined_count = prod(count for _, _, count in kw_roll_count_tuples)\n            rolls_by_name = {name: roll for name, roll, _ in kw_roll_count_tuples}\n            yield dependent_term(**rolls_by_name), combined_count\n\n    return aggregate_weighted(_resolve_dependent_term_for_rolls()).lowest_terms()\n</code></pre>"},{"location":"dyce/#dyce.p.P.h","title":"<code>h(*which: _GetItemT) -&gt; H</code>","text":"<p>Roughly equivalent to <code>H((sum(roll), count) for roll, count inself.rolls_with_counts(*which))</code> with some short-circuit optimizations.</p> <p>When provided no arguments, <code>h</code> combines (or \u201cflattens\u201d) contained histograms in accordance with the <code>HableT</code> protocol.</p> <pre><code>&gt;&gt;&gt; (2@P(6)).h()\nH({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n</code></pre> <p>If one or more arguments are provided, this method sums subsets of outcomes those arguments identify for each roll. Outcomes are ordered from least (index <code>0</code>) to greatest (index <code>-1</code> or <code>len(self) -1</code>). Identifiers can be <code>int</code>s or <code>slice</code>s, and can be mixed.</p> <p>Taking the greatest of two six-sided dice can be modeled as:</p> <pre><code>&gt;&gt;&gt; p_2d6 = 2@P(6)\n&gt;&gt;&gt; p_2d6.h(-1)\nH({1: 1, 2: 3, 3: 5, 4: 7, 5: 9, 6: 11})\n&gt;&gt;&gt; print(p_2d6.h(-1).format())\navg |    4.47\nstd |    1.40\nvar |    1.97\n  1 |   2.78% |#\n  2 |   8.33% |####\n  3 |  13.89% |######\n  4 |  19.44% |#########\n  5 |  25.00% |############\n  6 |  30.56% |###############\n</code></pre> <p>Taking the greatest two and least two faces of ten four-sided dice (<code>10d4</code>) can be modeled as:</p> <pre><code>&gt;&gt;&gt; p_10d4 = 10@P(4)\n&gt;&gt;&gt; p_10d4.h(slice(2), slice(-2, None))\nH({4: 1, 5: 10, 6: 1012, 7: 5030, 8: 51973, 9: 168760, 10: 595004, 11: 168760, 12: 51973, 13: 5030, 14: 1012, 15: 10, 16: 1})\n&gt;&gt;&gt; print(p_10d4.h(slice(2), slice(-2, None)).format(scaled=True))\navg |   10.00\nstd |    0.91\nvar |    0.84\n  4 |   0.00% |\n  5 |   0.00% |\n  6 |   0.10% |\n  7 |   0.48% |\n  8 |   4.96% |####\n  9 |  16.09% |##############\n 10 |  56.74% |##################################################\n 11 |  16.09% |##############\n 12 |   4.96% |####\n 13 |   0.48% |\n 14 |   0.10% |\n 15 |   0.00% |\n 16 |   0.00% |\n</code></pre> <p>Taking all outcomes exactly once is equivalent to summing the histograms in the pool.</p> <pre><code>&gt;&gt;&gt; d6 = H(6)\n&gt;&gt;&gt; d6avg = H((2, 3, 3, 4, 4, 5))\n&gt;&gt;&gt; p = 2@P(d6, d6avg)\n&gt;&gt;&gt; p.h(slice(None)) == p.h() == d6 + d6 + d6avg + d6avg\nTrue\n</code></pre> Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef h(self, *which: _GetItemT) -&gt; H:\nr\"\"\"\n    Roughly equivalent to ``#!python H((sum(roll), count) for roll, count in\n    self.rolls_with_counts(*which))`` with some short-circuit optimizations.\n\n    When provided no arguments, ``#!python h`` combines (or \u201cflattens\u201d) contained\n    histograms in accordance with the [``HableT`` protocol][dyce.h.HableT].\n\n    ``` python\n    &gt;&gt;&gt; (2@P(6)).h()\n    H({2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 5, 9: 4, 10: 3, 11: 2, 12: 1})\n\n    ```\n\n    If one or more arguments are provided, this method sums subsets of outcomes\n    those arguments identify for each roll. Outcomes are ordered from least (index\n    ``#!python 0``) to greatest (index ``#!python -1`` or ``#!python len(self) -\n    1``). Identifiers can be ``#!python int``s or ``#!python slice``s, and can be\n    mixed.\n\n    Taking the greatest of two six-sided dice can be modeled as:\n\n    ``` python\n    &gt;&gt;&gt; p_2d6 = 2@P(6)\n    &gt;&gt;&gt; p_2d6.h(-1)\n    H({1: 1, 2: 3, 3: 5, 4: 7, 5: 9, 6: 11})\n    &gt;&gt;&gt; print(p_2d6.h(-1).format())\n    avg |    4.47\n    std |    1.40\n    var |    1.97\n      1 |   2.78% |#\n      2 |   8.33% |####\n      3 |  13.89% |######\n      4 |  19.44% |#########\n      5 |  25.00% |############\n      6 |  30.56% |###############\n\n    ```\n\n    Taking the greatest two and least two faces of ten four-sided dice (``10d4``)\n    can be modeled as:\n\n    ``` python\n    &gt;&gt;&gt; p_10d4 = 10@P(4)\n    &gt;&gt;&gt; p_10d4.h(slice(2), slice(-2, None))\n    H({4: 1, 5: 10, 6: 1012, 7: 5030, 8: 51973, 9: 168760, 10: 595004, 11: 168760, 12: 51973, 13: 5030, 14: 1012, 15: 10, 16: 1})\n    &gt;&gt;&gt; print(p_10d4.h(slice(2), slice(-2, None)).format(scaled=True))\n    avg |   10.00\n    std |    0.91\n    var |    0.84\n      4 |   0.00% |\n      5 |   0.00% |\n      6 |   0.10% |\n      7 |   0.48% |\n      8 |   4.96% |####\n      9 |  16.09% |##############\n     10 |  56.74% |##################################################\n     11 |  16.09% |##############\n     12 |   4.96% |####\n     13 |   0.48% |\n     14 |   0.10% |\n     15 |   0.00% |\n     16 |   0.00% |\n\n    ```\n\n    Taking all outcomes exactly once is equivalent to summing the histograms in the\n    pool.\n\n    ``` python\n    &gt;&gt;&gt; d6 = H(6)\n    &gt;&gt;&gt; d6avg = H((2, 3, 3, 4, 4, 5))\n    &gt;&gt;&gt; p = 2@P(d6, d6avg)\n    &gt;&gt;&gt; p.h(slice(None)) == p.h() == d6 + d6 + d6avg + d6avg\n    True\n\n    ```\n    \"\"\"\n    if which:\n        n = len(self)\n        i = _analyze_selection(n, which)\n\n        if i and i &gt;= n:\n            # The caller selected all dice in the pool exactly i // n times, so we\n            # can short-circuit roll enumeration\n            assert i % n == 0\n\n            return self.h() * (i // n)\n        else:\n            return H(\n                (sum(roll), count) for roll, count in self.rolls_with_counts(*which)\n            )\n    else:\n        # The caller offered no selection\n        return sum_h(self)\n</code></pre>"},{"location":"dyce/#dyce.p.P.is_homogeneous","title":"<code>is_homogeneous() -&gt; bool</code>","text":"<p>Experimental</p> <p>This property should be considered experimental and may change or disappear in future versions.</p> <p>Returns whether the pool\u2019s population of histograms is homogeneous.</p> <pre><code>&gt;&gt;&gt; P(6, 6).is_homogeneous()\nTrue\n&gt;&gt;&gt; P(4, 6, 8).is_homogeneous()\nFalse\n</code></pre> Source code in <code>dyce/p.py</code> <pre><code>@experimental\n@beartype\ndef is_homogeneous(self) -&gt; bool:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This property should be considered experimental and may change or disappear\n        in future versions.\n\n    Returns whether the pool\u2019s population of histograms is homogeneous.\n\n    ``` python\n    &gt;&gt;&gt; P(6, 6).is_homogeneous()\n    True\n    &gt;&gt;&gt; P(4, 6, 8).is_homogeneous()\n    False\n\n    ```\n    \"\"\"\n    return len(set(self._hs)) &lt;= 1\n</code></pre>"},{"location":"dyce/#dyce.p.P.map","title":"<code>map(op: _BinaryOperatorT, right_operand: _OperandT) -&gt; P</code>","text":"<p>Shorthand for <code>P(*(h.map(op, right_operand) for h in self))</code>. See the <code>H.map</code> method.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; p_3d6 = 3@P(H((-3, -1, 2, 4)))\n&gt;&gt;&gt; p_3d6.map(operator.__mul__, -1)\n3@P(H({-4: 1, -2: 1, 1: 1, 3: 1}))\n</code></pre> Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef map(self, op: _BinaryOperatorT, right_operand: _OperandT) -&gt; P:\nr\"\"\"\n    Shorthand for ``#!python P(*(h.map(op, right_operand) for h in self))``. See the\n    [``H.map`` method][dyce.h.H.map].\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; p_3d6 = 3@P(H((-3, -1, 2, 4)))\n    &gt;&gt;&gt; p_3d6.map(operator.__mul__, -1)\n    3@P(H({-4: 1, -2: 1, 1: 1, 3: 1}))\n\n    ```\n    \"\"\"\n    return P(*(h.map(op, right_operand) for h in self))\n</code></pre>"},{"location":"dyce/#dyce.p.P.rmap","title":"<code>rmap(left_operand: RealLike, op: _BinaryOperatorT) -&gt; P</code>","text":"<p>Shorthand for <code>P(*(h.rmap(left_operand, op) for h in self))</code>. See the <code>H.rmap</code> method.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; p_3d6 = 2@P(H((-3, -1, 2, 4)))\n&gt;&gt;&gt; p_3d6.umap(Fraction).rmap(1, operator.__truediv__)\n2@P(H({Fraction(-1, 1): 1, Fraction(-1, 3): 1, Fraction(1, 4): 1, Fraction(1, 2): 1}))\n</code></pre> Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef rmap(self, left_operand: RealLike, op: _BinaryOperatorT) -&gt; P:\nr\"\"\"\n    Shorthand for ``#!python P(*(h.rmap(left_operand, op) for h in self))``. See the\n    [``H.rmap`` method][dyce.h.H.rmap].\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; from fractions import Fraction\n    &gt;&gt;&gt; p_3d6 = 2@P(H((-3, -1, 2, 4)))\n    &gt;&gt;&gt; p_3d6.umap(Fraction).rmap(1, operator.__truediv__)\n    2@P(H({Fraction(-1, 1): 1, Fraction(-1, 3): 1, Fraction(1, 4): 1, Fraction(1, 2): 1}))\n\n    ```\n    \"\"\"\n    return P(*(h.rmap(left_operand, op) for h in self))\n</code></pre>"},{"location":"dyce/#dyce.p.P.roll","title":"<code>roll() -&gt; RollT</code>","text":"<p>Returns (weighted) random outcomes from contained histograms.</p> <p>On ordering</p> <p>This method \u201cworks\u201d (i.e., falls back to a \u201cnatural\u201d ordering of string representations) for outcomes whose relative values cannot be known (e.g., symbolic expressions). This is deliberate to allow random roll functionality where symbolic resolution is not needed or will happen later.</p> Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef roll(self) -&gt; RollT:\nr\"\"\"\n    Returns (weighted) random outcomes from contained histograms.\n\n    !!! note \"On ordering\"\n\n        This method \u201cworks\u201d (i.e., falls back to a \u201cnatural\u201d ordering of string\n        representations) for outcomes whose relative values cannot be known (e.g.,\n        symbolic expressions). This is deliberate to allow random roll functionality\n        where symbolic resolution is not needed or will happen later.\n    \"\"\"\n    return tuple(sorted_outcomes(h.roll() for h in self))\n</code></pre>"},{"location":"dyce/#dyce.p.P.rolls_with_counts","title":"<code>rolls_with_counts(*which: _GetItemT) -&gt; Iterator[_RollCountT]</code>","text":"<p>Returns an iterator yielding two-tuples (pairs) that, collectively, enumerate all possible outcomes for the pool. The first item in the two-tuple is a sorted sequence of the outcomes for a distinct roll. The second is the count for that roll. Outcomes in each roll are ordered least to greatest.</p> <p>If one or more arguments are provided, this methods selects subsets of outcomes for each roll. Outcomes in each roll are ordered from least (index <code>0</code>) to greatest (index <code>-1</code> or <code>len(self) - 1</code>). Identifiers can be <code>int</code>s or <code>slice</code>s, and can be mixed for more flexible selections.</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n\n&gt;&gt;&gt; def accumulate_roll_counts(counter, roll_counts):\n...   for roll, count in roll_counts:\n...     counter[roll] += count\n...   return counter\n\n&gt;&gt;&gt; p_6d6 = 6@P(6)\n&gt;&gt;&gt; every_other_d6 = accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(slice(None, None, -2))) ; every_other_d6\nCounter({(6, 4, 2): 4110, (6, 5, 3): 3390, (6, 4, 3): 3330, ..., (3, 3, 3): 13, (2, 2, 2): 7, (1, 1, 1): 1})\n&gt;&gt;&gt; accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(5, 3, 1)) == every_other_d6\nTrue\n&gt;&gt;&gt; accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(*range(5, 0, -2))) == every_other_d6\nTrue\n&gt;&gt;&gt; accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(*(i for i in range(6, 0, -1) if i % 2 == 1))) == every_other_d6\nTrue\n</code></pre> <p>One way to model the likelihood of achieving a \u201cYhatzee\u201d (i.e., where five six-sided dice show the same face) on a single roll by checking rolls for where the least and greatest outcomes are the same.</p> <pre><code>&gt;&gt;&gt; p_5d6 = 5@P(6)\n&gt;&gt;&gt; yhatzee_on_single_roll = H(\n...   (1 if roll[0] == roll[-1] else 0, count)\n...   for roll, count\n...   in p_5d6.rolls_with_counts()\n... )\n&gt;&gt;&gt; print(yhatzee_on_single_roll.format(width=0))\n{..., 0: 99.92%, 1:  0.08%}\n</code></pre> <p>In the general case, rolls may appear more than once.</p> <pre><code>&gt;&gt;&gt; sorted(P(H(2), H(3)).rolls_with_counts())\n[((1, 1), 1), ((1, 2), 1), ((1, 2), 1), ((1, 3), 1), ((2, 2), 1), ((2, 3), 1)]\n</code></pre> <p>In the above, <code>(1, 2)</code> appears a total of two times, each with counts of one.</p> <p>However, if the pool is homogeneous (meaning it only contains identical histograms), rolls (before selection) are not repeated. (See the note on implementation below.)</p> <pre><code>&gt;&gt;&gt; sorted((2@P(H((-1, 0, 1)))).rolls_with_counts())\n[((-1, -1), 1), ((-1, 0), 2), ((-1, 1), 2), ((0, 0), 1), ((0, 1), 2), ((1, 1), 1)]\n</code></pre> <p>Either way, by summing and counting all rolls, we can confirm identity.</p> <pre><code>&gt;&gt;&gt; d6 = H(6)\n&gt;&gt;&gt; d6avg = H((2, 3, 3, 4, 4, 5))\n&gt;&gt;&gt; p = 2@P(d6, d6avg)\n&gt;&gt;&gt; H((sum(roll), count) for roll, count in p.rolls_with_counts()) == p.h() == d6 + d6 + d6avg + d6avg\nTrue\n</code></pre> <p>This method does not try to outsmart callers by (mis)interpreting selection arguments. It honors selection identifier order and any redundancy.</p> <pre><code>&gt;&gt;&gt; p_d3_d4 = P(H(3), H(4))\n&gt;&gt;&gt; # Select the second, first, then second (again) elements\n&gt;&gt;&gt; sorted(p_d3_d4.rolls_with_counts(-1, 0, 1))\n[((1, 1, 1), 1), ((2, 1, 2), 1), ((2, 1, 2), 1), ..., ((4, 1, 4), 1), ((4, 2, 4), 1), ((4, 3, 4), 1)]\n</code></pre> <p>Selecting the same outcomes, but in a different order is not immediately comparable.</p> <pre><code>&gt;&gt;&gt; select_0_1 = sorted(p_d3_d4.rolls_with_counts(0, 1))\n&gt;&gt;&gt; select_1_0 = sorted(p_d3_d4.rolls_with_counts(1, 0))\n&gt;&gt;&gt; select_0_1 == select_1_0\nFalse\n</code></pre> <p>Equivalence can be tested when selected outcomes are sorted.</p> <pre><code>&gt;&gt;&gt; sorted_0_1 = sorted((sorted(roll), count) for roll, count in select_0_1)\n&gt;&gt;&gt; sorted_1_0 = sorted((sorted(roll), count) for roll, count in select_1_0)\n&gt;&gt;&gt; sorted_0_1 == sorted_1_0\nTrue\n</code></pre> <p>They can also be summed and counted which is equivalent to calling the <code>h</code> method with identical selection arguments.</p> <pre><code>&gt;&gt;&gt; summed_0_1 = H((sum(roll), count) for roll, count in select_0_1)\n&gt;&gt;&gt; summed_1_0 = H((sum(roll), count) for roll, count in select_1_0)\n&gt;&gt;&gt; summed_0_1 == summed_1_0 == p_d3_d4.h(0, 1) == p_d3_d4.h(1, 0)\nTrue\n</code></pre> <p>About the implementation</p> <p>Enumeration is substantially more efficient for homogeneous pools than heterogeneous ones, because we are able to avoid the expensive enumeration of the Cartesian product using several techniques.</p> <p>Taking \\(k\\) outcomes, where \\(k\\) selects fewer than all \\(n\\) outcomes a homogeneous pool benefits from Ilmari Karonen\u2019s optimization, which appears to scale geometrically with \\(k\\) times some factor of \\(n\\) (e.g., \\(\\log n\\), but I haven\u2019t bothered to figure that out yet), such that\u2014in observed testing, at least\u2014it is generally the fastest approach for \\(k &lt; n\\).</p> <p>Where \\(k = n\\), we leverage the multinomial coefficient, which appears to scale generally with \\(n\\).</p> \\[ {{n} \\choose {{{k}_{1}},{{k}_{2}},\\ldots,{{k}_{m}}}} = {\\frac {{n}!} {{{k}_{1}}! {{k}_{2}}! \\cdots {{k}_{m}}!}} \\] <p>We enumerate combinations with replacements, and then the compute the number of permutations with repetitions for each combination. Consider <code>n@P(H(m))</code>. Enumerating combinations with replacements would yield all unique rolls.</p> <p><code>((1, 1, \u2026, 1), (1, 1, \u2026, 2), \u2026, (1, 1, \u2026, m), \u2026, (m - 1, m, \u2026,m), (m, m, \u2026, m))</code></p> <p>To determine the count for a particular roll <code>(a, b, \u2026, n)</code>, we compute the multinomial coefficient for that roll and multiply by the scalar <code>H(m)[a] * H(m)[b] * \u2026 * H(m)[n]</code>. (See this for an in-depth exploration of the topic.)</p> <p>Further, this implementation attempts to optimize heterogeneous pools by breaking them into homogeneous groups before computing the Cartesian product of those sub-results. This approach allows homogeneous pools to be ordered without duplicates, where heterogeneous ones offer no such guarantees.</p> <p>As expected, this optimization allows the performance of arbitrary selection from mixed pools to sit between that of purely homogeneous and purely heterogeneous ones. Note, however, that all three appear to scale geometrically in some way.</p> <pre><code>(4@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))).h(slice(0)):\n4.74 \u00b5s \u00b1 37.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n(4@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))).h(slice(1)):\n91.7 \u00b5s \u00b1 411 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n(4@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))).h(slice(2)):\n196 \u00b5s \u00b1 997 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n(4@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))).h(slice(3)):\n341 \u00b5s \u00b1 3.62 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n(6@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))).h(slice(2)):\n199 \u00b5s \u00b1 2.02 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n(6@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))).h(slice(3)):\n349 \u00b5s \u00b1 2.01 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n(6@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))).h(slice(4)):\n569 \u00b5s \u00b1 4.28 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n(6@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}))).h(slice(5)):\n871 \u00b5s \u00b1 8.35 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n\n(P(H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}), 2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})))).h(slice(0)):\n4.63 \u00b5s \u00b1 25.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n(P(H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}), 2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})))).h(slice(1)):\n504 \u00b5s \u00b1 2.33 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n(P(H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}), 2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})))).h(slice(2)):\n1.26 ms \u00b1 17.5 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n(P(H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}), 2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})))).h(slice(3)):\n1.27 ms \u00b1 3.08 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n(P(H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}), 3@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})))).h(slice(2)):\n6.59 ms \u00b1 18.9 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n(P(H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}), 3@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})))).h(slice(3)):\n17.2 ms \u00b1 263 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n(P(H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}), 3@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})))).h(slice(4)):\n17.4 ms \u00b1 278 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n(P(H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}), 3@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})))).h(slice(5)):\n19.9 ms \u00b1 1.42 ms per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n\n(P(H({-3: 1, -2: 1, -1: 1, 0: 1, 1: 1, 2: 1}), H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}))).h(slice(0)):\n4.59 \u00b5s \u00b1 17.6 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n(P(H({-3: 1, -2: 1, -1: 1, 0: 1, 1: 1, 2: 1}), H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}))).h(slice(1)):\n2.64 ms \u00b1 462 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n(P(H({-3: 1, -2: 1, -1: 1, 0: 1, 1: 1, 2: 1}), H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}))).h(slice(2)):\n2.31 ms \u00b1 366 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n(P(H({-3: 1, -2: 1, -1: 1, 0: 1, 1: 1, 2: 1}), H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}))).h(slice(3)):\n2.1 ms \u00b1 8.56 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n(P(H({-5: 1, -4: 1, -3: 1, -2: 1, -1: 1, 0: 1}), H({-4: 1, -3: 1, -2: 1, -1: 1, 0: 1, 1: 1}), H({-3: 1, -2: 1, -1: 1, 0: 1, 1: 1, 2: 1}), H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}))).h(slice(2)):\n65.6 ms \u00b1 489 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n(P(H({-5: 1, -4: 1, -3: 1, -2: 1, -1: 1, 0: 1}), H({-4: 1, -3: 1, -2: 1, -1: 1, 0: 1, 1: 1}), H({-3: 1, -2: 1, -1: 1, 0: 1, 1: 1, 2: 1}), H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}))).h(slice(3)):\n68.4 ms \u00b1 471 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n(P(H({-5: 1, -4: 1, -3: 1, -2: 1, -1: 1, 0: 1}), H({-4: 1, -3: 1, -2: 1, -1: 1, 0: 1, 1: 1}), H({-3: 1, -2: 1, -1: 1, 0: 1, 1: 1, 2: 1}), H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}))).h(slice(4)):\n71.6 ms \u00b1 463 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n(P(H({-5: 1, -4: 1, -3: 1, -2: 1, -1: 1, 0: 1}), H({-4: 1, -3: 1, -2: 1, -1: 1, 0: 1, 1: 1}), H({-3: 1, -2: 1, -1: 1, 0: 1, 1: 1, 2: 1}), H({-2: 1, -1: 1, 0: 1, 1: 1, 2: 1, 3: 1}), H({-1: 1, 0: 1, 1: 1, 2: 1, 3: 1, 4: 1}), H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1}))).h(slice(5)):\n73.3 ms \u00b1 256 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</code></pre> <p> Source: <code>perf_rolls_with_counts.ipy</code> <p><pre><code>from dyce import H, P\n\nfor n in (4, 6):\n  p = n@P(6)\n  for i in range(len(p) - 4, len(p)):\n    print(f\"({p}).h(slice({i})):\")\n    %timeit p.h(slice(i))\n\nprint()\n\nfor n in (2, 3):\n  p = P(n@P(6), *[H(6) - m for m in range(n, 0, -1)])\n  for i in range(len(p) - 4, len(p)):\n    print(f\"({p}).h(slice({i})):\")\n    %timeit p.h(slice(i))\n\nprint()\n\nfor n in (4, 6):\n  p = P(*[H(6) - m for m in range(n, 0, -1)])\n  for i in range(len(p) - 4, len(p)):\n    print(f\"({p}).h(slice({i})):\")\n    %timeit p.h(slice(i))\n\nprint()\n</code></pre> </p> Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef rolls_with_counts(self, *which: _GetItemT) -&gt; Iterator[_RollCountT]:\nr\"\"\"\n    Returns an iterator yielding two-tuples (pairs) that, collectively, enumerate all\n    possible outcomes for the pool. The first item in the two-tuple is a sorted\n    sequence of the outcomes for a distinct roll. The second is the count for that\n    roll. Outcomes in each roll are ordered least to greatest.\n\n    If one or more arguments are provided, this methods selects subsets of outcomes\n    for each roll. Outcomes in each roll are ordered from least (index ``#!python\n    0``) to greatest (index ``#!python -1`` or ``#!python len(self) - 1``).\n    Identifiers can be ``#!python int``s or ``#!python slice``s, and can be mixed\n    for more flexible selections.\n\n    ``` python\n    &gt;&gt;&gt; from collections import Counter\n\n    &gt;&gt;&gt; def accumulate_roll_counts(counter, roll_counts):\n    ...   for roll, count in roll_counts:\n    ...     counter[roll] += count\n    ...   return counter\n\n    &gt;&gt;&gt; p_6d6 = 6@P(6)\n    &gt;&gt;&gt; every_other_d6 = accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(slice(None, None, -2))) ; every_other_d6\n    Counter({(6, 4, 2): 4110, (6, 5, 3): 3390, (6, 4, 3): 3330, ..., (3, 3, 3): 13, (2, 2, 2): 7, (1, 1, 1): 1})\n    &gt;&gt;&gt; accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(5, 3, 1)) == every_other_d6\n    True\n    &gt;&gt;&gt; accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(*range(5, 0, -2))) == every_other_d6\n    True\n    &gt;&gt;&gt; accumulate_roll_counts(Counter(), p_6d6.rolls_with_counts(*(i for i in range(6, 0, -1) if i % 2 == 1))) == every_other_d6\n    True\n\n    ```\n\n    One way to model the likelihood of achieving a \u201cYhatzee\u201d (i.e., where five\n    six-sided dice show the same face) on a single roll by checking rolls for where\n    the least and greatest outcomes are the same.\n\n    ``` python\n    &gt;&gt;&gt; p_5d6 = 5@P(6)\n    &gt;&gt;&gt; yhatzee_on_single_roll = H(\n    ...   (1 if roll[0] == roll[-1] else 0, count)\n    ...   for roll, count\n    ...   in p_5d6.rolls_with_counts()\n    ... )\n    &gt;&gt;&gt; print(yhatzee_on_single_roll.format(width=0))\n    {..., 0: 99.92%, 1:  0.08%}\n\n    ```\n\n    !!! note \"In the general case, rolls may appear more than once.\"\n\n        ``` python\n        &gt;&gt;&gt; sorted(P(H(2), H(3)).rolls_with_counts())\n        [((1, 1), 1), ((1, 2), 1), ((1, 2), 1), ((1, 3), 1), ((2, 2), 1), ((2, 3), 1)]\n\n        ```\n\n        In the above, ``#!python (1, 2)`` appears a total of two times, each with\n        counts of one.\n\n        However, if the pool is homogeneous (meaning it only contains identical\n        histograms), rolls (before selection) are not repeated. (See the note on\n        implementation below.)\n\n        ``` python\n        &gt;&gt;&gt; sorted((2@P(H((-1, 0, 1)))).rolls_with_counts())\n        [((-1, -1), 1), ((-1, 0), 2), ((-1, 1), 2), ((0, 0), 1), ((0, 1), 2), ((1, 1), 1)]\n\n        ```\n\n        Either way, by summing and counting all rolls, we can confirm identity.\n\n        ``` python\n        &gt;&gt;&gt; d6 = H(6)\n        &gt;&gt;&gt; d6avg = H((2, 3, 3, 4, 4, 5))\n        &gt;&gt;&gt; p = 2@P(d6, d6avg)\n        &gt;&gt;&gt; H((sum(roll), count) for roll, count in p.rolls_with_counts()) == p.h() == d6 + d6 + d6avg + d6avg\n        True\n\n        ```\n\n    This method does not try to outsmart callers by (mis)interpreting selection\n    arguments. It honors selection identifier order and any redundancy.\n\n    ``` python\n    &gt;&gt;&gt; p_d3_d4 = P(H(3), H(4))\n    &gt;&gt;&gt; # Select the second, first, then second (again) elements\n    &gt;&gt;&gt; sorted(p_d3_d4.rolls_with_counts(-1, 0, 1))\n    [((1, 1, 1), 1), ((2, 1, 2), 1), ((2, 1, 2), 1), ..., ((4, 1, 4), 1), ((4, 2, 4), 1), ((4, 3, 4), 1)]\n\n    ```\n\n    Selecting the same outcomes, but in a different order is not immediately\n    comparable.\n\n    ``` python\n    &gt;&gt;&gt; select_0_1 = sorted(p_d3_d4.rolls_with_counts(0, 1))\n    &gt;&gt;&gt; select_1_0 = sorted(p_d3_d4.rolls_with_counts(1, 0))\n    &gt;&gt;&gt; select_0_1 == select_1_0\n    False\n\n    ```\n\n    Equivalence can be tested when selected outcomes are sorted.\n\n    ``` python\n    &gt;&gt;&gt; sorted_0_1 = sorted((sorted(roll), count) for roll, count in select_0_1)\n    &gt;&gt;&gt; sorted_1_0 = sorted((sorted(roll), count) for roll, count in select_1_0)\n    &gt;&gt;&gt; sorted_0_1 == sorted_1_0\n    True\n\n    ```\n\n    They can also be summed and counted which is equivalent to calling the\n    [``h`` method][dyce.p.P.h] with identical selection arguments.\n\n    ``` python\n    &gt;&gt;&gt; summed_0_1 = H((sum(roll), count) for roll, count in select_0_1)\n    &gt;&gt;&gt; summed_1_0 = H((sum(roll), count) for roll, count in select_1_0)\n    &gt;&gt;&gt; summed_0_1 == summed_1_0 == p_d3_d4.h(0, 1) == p_d3_d4.h(1, 0)\n    True\n\n    ```\n\n    !!! info \"About the implementation\"\n\n        Enumeration is substantially more efficient for homogeneous pools than\n        heterogeneous ones, because we are able to avoid the expensive enumeration\n        of the Cartesian product using several techniques.\n\n        Taking $k$ outcomes, where $k$ selects fewer than all $n$ outcomes a\n        homogeneous pool benefits from [Ilmari Karonen\u2019s\n        optimization](https://rpg.stackexchange.com/a/166663/71245), which appears\n        to scale geometrically with $k$ times some factor of $n$ (e.g., $\\log n$,\n        but I haven\u2019t bothered to figure that out yet), such that\u2014in observed\n        testing, at least\u2014it is generally the fastest approach for $k &lt; n$.\n\n        Where $k = n$, we leverage the [*multinomial\n        coefficient*](https://en.wikipedia.org/wiki/Permutation#Permutations_of_multisets),\n        which appears to scale generally with $n$.\n\n        $$\n        {{n} \\choose {{{k}_{1}},{{k}_{2}},\\ldots,{{k}_{m}}}}\n        = {\\frac {{n}!} {{{k}_{1}}! {{k}_{2}}! \\cdots {{k}_{m}}!}}\n        $$\n\n        We enumerate combinations with replacements, and then the compute the number\n        of permutations with repetitions for each combination. Consider ``#!python\n        n@P(H(m))``. Enumerating combinations with replacements would yield all\n        unique rolls.\n\n        ``#!python ((1, 1, \u2026, 1), (1, 1, \u2026, 2), \u2026, (1, 1, \u2026, m), \u2026, (m - 1, m, \u2026,\n        m), (m, m, \u2026, m))``\n\n        To determine the count for a particular roll ``#!python (a, b, \u2026, n)``, we\n        compute the multinomial coefficient for that roll and multiply by the scalar\n        ``#!python H(m)[a] * H(m)[b] * \u2026 * H(m)[n]``. (See\n        [this](https://www.lucamoroni.it/the-dice-roll-sum-problem/) for an in-depth\n        exploration of the topic.)\n\n        Further, this implementation attempts to optimize heterogeneous pools by\n        breaking them into homogeneous groups before computing the Cartesian product\n        of those sub-results. This approach allows homogeneous pools to be ordered\n        without duplicates, where heterogeneous ones offer no such guarantees.\n\n        As expected, this optimization allows the performance of arbitrary selection\n        from mixed pools to sit between that of purely homogeneous and purely\n        heterogeneous ones. Note, however, that all three appear to scale\n        geometrically in some way.\n\n        ``` python\n        --8&lt;-- \"docs/assets/perf_rolls_with_counts.txt\"\n        ```\n\n        &lt;details&gt;\n        &lt;summary&gt;Source: &lt;a href=\"https://github.com/posita/dyce/blob/latest/docs/assets/perf_rolls_with_counts.ipy\"&gt;&lt;code&gt;perf_rolls_with_counts.ipy&lt;/code&gt;&lt;/a&gt;&lt;/summary&gt;\n\n        ``` python\n        --8&lt;-- \"docs/assets/perf_rolls_with_counts.ipy\"\n        ```\n        &lt;/details&gt;\n    \"\"\"\n    n = len(self)\n\n    if not which:\n        i: Optional[int] = n\n    else:\n        i = _analyze_selection(n, which)\n\n    if i == 0 or n == 0:\n        rolls_with_counts_iter: Iterable[_RollCountT] = iter(())\n    else:\n        groups = tuple((h, sum(1 for _ in hs)) for h, hs in groupby(self))\n\n        if len(groups) == 1:\n            # Based on cursory performance analysis, calling the homogeneous\n            # implementation directly provides about a 15% performance savings over\n            # merely falling through to _rwc_heterogeneous_h_groups. Maybe\n            # itertools.product adds significant overhead?\n            h, hn = groups[0]\n            assert hn == n\n\n            # Still in search of a better (i.e., more efficient) way:\n            # &lt;https://math.stackexchange.com/questions/4173084/probability-distribution-of-k-1-k-2-cdots-k-m-selections-of-arbitrary-posi&gt;\n            if i and abs(i) &lt; n:\n                rolls_with_counts_iter = _rwc_homogeneous_n_h_using_partial_selection(\n                    n,\n                    h,\n                    i,\n                    # This is just padding to allow for consistent indexing. They\n                    # are deselected (i.e., not returned) below.\n                    fill=0,\n                )\n            else:\n                rolls_with_counts_iter = (\n                    _rwc_homogeneous_n_h_using_partial_selection(n, h, n)\n                )\n        else:\n            rolls_with_counts_iter = _rwc_heterogeneous_h_groups(groups, i)\n\n    for sorted_outcomes_for_roll, roll_count in rolls_with_counts_iter:\n        if which:\n            taken_outcomes = tuple(getitems(sorted_outcomes_for_roll, which))\n        else:\n            taken_outcomes = sorted_outcomes_for_roll\n\n        yield taken_outcomes, roll_count\n</code></pre>"},{"location":"dyce/#dyce.p.P.umap","title":"<code>umap(op: _UnaryOperatorT) -&gt; P</code>","text":"<p>Shorthand for <code>P(*(h.umap(op) for h in self))</code>. See the <code>H.umap</code> method.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; p_3d6 = 3@P(H((-3, -1, 2, 4)))\n&gt;&gt;&gt; p_3d6.umap(operator.__neg__)\n3@P(H({-4: 1, -2: 1, 1: 1, 3: 1}))\n&gt;&gt;&gt; p_3d6.umap(operator.__abs__)\n3@P(H({1: 1, 2: 1, 3: 1, 4: 1}))\n</code></pre> Source code in <code>dyce/p.py</code> <pre><code>@beartype\ndef umap(self, op: _UnaryOperatorT) -&gt; P:\nr\"\"\"\n    Shorthand for ``#!python P(*(h.umap(op) for h in self))``. See the\n    [``H.umap`` method][dyce.h.H.umap].\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; p_3d6 = 3@P(H((-3, -1, 2, 4)))\n    &gt;&gt;&gt; p_3d6.umap(operator.__neg__)\n    3@P(H({-4: 1, -2: 1, 1: 1, 3: 1}))\n    &gt;&gt;&gt; p_3d6.umap(operator.__abs__)\n    3@P(H({1: 1, 2: 1, 3: 1, 4: 1}))\n\n    ```\n    \"\"\"\n    return P(*(h.umap(op) for h in self))\n</code></pre>"},{"location":"dyce.r/","title":"<tt>dyce.r</tt>","text":""},{"location":"dyce.r/#dycer-package-reference","title":"<code>dyce.r</code> package reference","text":"<p>Experimental</p> <p>This package is an attempt to provide primitives for producing weighted randomized rolls without the overhead of enumeration. Rolls can be inspected to understand how specific values are derived. It should be considered experimental. Be warned that future release may introduce incompatibilities or remove this package altogether. Feedback, suggestions, and contributions are welcome and appreciated.</p>"},{"location":"dyce.r/#roller-class-hierarchy","title":"Roller class hierarchy","text":""},{"location":"dyce.r/#dyce.r.R","title":"<code>R</code>","text":"<p>Experimental</p> <p>This class (and its descendants) should be considered experimental and may change or disappear in future versions.</p> <p>Where <code>H</code> objects and <code>P</code> objects are used primarily for enumerating weighted outcomes, <code>R</code> objects represent rollers. More specifically, they are immutable nodes assembled in tree-like structures to represent calculations. Unlike <code>H</code> objects or <code>P</code> objects, rollers generate rolls that conform to weighted outcomes without engaging in computationally expensive enumeration. Roller trees are typically composed from various <code>R</code> class methods and operators as well as arithmetic operations.</p> <pre><code>&gt;&gt;&gt; from dyce import H, P, R\n&gt;&gt;&gt; d6 = H(6)\n&gt;&gt;&gt; r_d6 = R.from_value(d6) ; r_d6\nValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation='')\n&gt;&gt;&gt; ((4 * r_d6 + 3) ** 2 % 5).gt(2)\nBinarySumOpRoller(\n  bin_op=&lt;function R.gt.&lt;locals&gt;._gt at ...&gt;,\n  left_source=BinarySumOpRoller(\n      bin_op=&lt;built-in function mod&gt;,\n      left_source=BinarySumOpRoller(\n          bin_op=&lt;built-in function pow&gt;,\n          left_source=BinarySumOpRoller(\n              bin_op=&lt;built-in function add&gt;,\n              left_source=BinarySumOpRoller(\n                  bin_op=&lt;built-in function mul&gt;,\n                  left_source=ValueRoller(value=4, annotation=''),\n                  right_source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n                  annotation='',\n                ),\n              right_source=ValueRoller(value=3, annotation=''),\n              annotation='',\n            ),\n          right_source=ValueRoller(value=2, annotation=''),\n          annotation='',\n        ),\n      right_source=ValueRoller(value=5, annotation=''),\n      annotation='',\n    ),\n  right_source=ValueRoller(value=2, annotation=''),\n  annotation='',\n)\n</code></pre> <p>Info</p> <p>No optimizations are made when initializing roller trees. They retain their exact structure, even where such structures could be trivially reduced.</p> <pre><code>&gt;&gt;&gt; r_6 = R.from_value(6)\n&gt;&gt;&gt; r_6_abs_3 = 3@abs(r_6)\n&gt;&gt;&gt; r_6_abs_6_abs_6_abs = R.from_sources(abs(r_6), abs(r_6), abs(r_6))\n&gt;&gt;&gt; tuple(r_6_abs_3.roll().outcomes()), tuple(r_6_abs_6_abs_6_abs.roll().outcomes())  # they generate the same rolls\n((6, 6, 6), (6, 6, 6))\n&gt;&gt;&gt; r_6_abs_3 == r_6_abs_6_abs_6_abs  # and yet, they're different animals\nFalse\n</code></pre> <p>This is because the structure itself contains information that might be required by certain contexts. If such information loss is permissible and reduction is desirable, consider using histograms instead.</p> <p>Roller trees can can be queried via the <code>roll</code> method, which produces <code>Roll</code> objects.</p> <pre><code>&gt;&gt;&gt; roll = r_d6.roll()\n&gt;&gt;&gt; tuple(roll.outcomes())\n(4,)\n&gt;&gt;&gt; roll.total()\n4\n</code></pre> <pre><code>&gt;&gt;&gt; d6 + 3\nH({4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1})\n&gt;&gt;&gt; (r_d6 + 3).roll().total() in (d6 + 3)\nTrue\n</code></pre> <p><code>Roll</code> objects are much richer than mere sequences of outcomes. They are also tree-like structures that mirror the roller trees used to produce them, capturing references to rollers and the outcomes generated at each node.</p> <pre><code>&gt;&gt;&gt; roll = (r_d6 + 3).roll()\n&gt;&gt;&gt; roll.total()\n8\n&gt;&gt;&gt; roll\nRoll(\n  r=...,\n  roll_outcomes=(\n    RollOutcome(\n      value=8,\n      sources=(\n        RollOutcome(\n          value=5,\n          sources=(),\n        ),\n        RollOutcome(\n          value=3,\n          sources=(),\n        ),\n      ),\n    ),\n  ),\n  source_rolls=(\n    Roll(\n      r=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n      roll_outcomes=(\n        RollOutcome(\n          value=5,\n          sources=(),\n        ),\n      ),\n      source_rolls=(),\n    ),\n    Roll(\n      r=ValueRoller(value=3, annotation=''),\n      roll_outcomes=(\n        RollOutcome(\n          value=3,\n          sources=(),\n        ),\n      ),\n      source_rolls=(),\n    ),\n  ),\n)\n</code></pre> <p>Rollers afford optional annotations as a convenience to callers. They are taken into account when comparing roller trees, but otherwise ignored, internally. One use is to capture references to nodes in an abstract syntax tree generated from parsing a proprietary grammar. Any provided annotation can be retrieved using the <code>annotation</code> property. The <code>annotate</code> method can be used to apply an annotation to existing roller.</p> <p>The <code>R</code> class itself acts as a base from which several computation-specific implementations derive (such as expressing operands like outcomes or histograms, unary operations, binary operations, pools, etc.).</p> Source code in <code>dyce/r.py</code> <pre><code>class R:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This class (and its descendants) should be considered experimental and may\n        change or disappear in future versions.\n\n    Where [``H`` objects][dyce.h.H] and [``P`` objects][dyce.p.P] are used primarily for\n    enumerating weighted outcomes, ``#!python R`` objects represent rollers. More\n    specifically, they are immutable nodes assembled in tree-like structures to\n    represent calculations. Unlike [``H`` objects][dyce.h.H] or\n    [``P`` objects][dyce.p.P], rollers generate rolls that conform to weighted outcomes\n    without engaging in computationally expensive enumeration. Roller trees are\n    typically composed from various ``#!python R`` class methods and operators as well\n    as arithmetic operations.\n\n    ``` python\n    &gt;&gt;&gt; from dyce import H, P, R\n    &gt;&gt;&gt; d6 = H(6)\n    &gt;&gt;&gt; r_d6 = R.from_value(d6) ; r_d6\n    ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation='')\n    &gt;&gt;&gt; ((4 * r_d6 + 3) ** 2 % 5).gt(2)\n    BinarySumOpRoller(\n      bin_op=&lt;function R.gt.&lt;locals&gt;._gt at ...&gt;,\n      left_source=BinarySumOpRoller(\n          bin_op=&lt;built-in function mod&gt;,\n          left_source=BinarySumOpRoller(\n              bin_op=&lt;built-in function pow&gt;,\n              left_source=BinarySumOpRoller(\n                  bin_op=&lt;built-in function add&gt;,\n                  left_source=BinarySumOpRoller(\n                      bin_op=&lt;built-in function mul&gt;,\n                      left_source=ValueRoller(value=4, annotation=''),\n                      right_source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n                      annotation='',\n                    ),\n                  right_source=ValueRoller(value=3, annotation=''),\n                  annotation='',\n                ),\n              right_source=ValueRoller(value=2, annotation=''),\n              annotation='',\n            ),\n          right_source=ValueRoller(value=5, annotation=''),\n          annotation='',\n        ),\n      right_source=ValueRoller(value=2, annotation=''),\n      annotation='',\n    )\n\n    ```\n\n    !!! info\n\n        No optimizations are made when initializing roller trees. They retain their\n        exact structure, even where such structures could be trivially reduced.\n\n        ``` python\n        &gt;&gt;&gt; r_6 = R.from_value(6)\n        &gt;&gt;&gt; r_6_abs_3 = 3@abs(r_6)\n        &gt;&gt;&gt; r_6_abs_6_abs_6_abs = R.from_sources(abs(r_6), abs(r_6), abs(r_6))\n        &gt;&gt;&gt; tuple(r_6_abs_3.roll().outcomes()), tuple(r_6_abs_6_abs_6_abs.roll().outcomes())  # they generate the same rolls\n        ((6, 6, 6), (6, 6, 6))\n        &gt;&gt;&gt; r_6_abs_3 == r_6_abs_6_abs_6_abs  # and yet, they're different animals\n        False\n\n        ```\n\n        This is because the structure itself contains information that might be required\n        by certain contexts. If such information loss is permissible and\n        reduction is desirable, consider using [histograms][dyce.h.H] instead.\n\n    Roller trees can can be queried via the [``roll`` method][dyce.r.R.roll], which\n    produces [``Roll`` objects][dyce.r.Roll].\n\n    &lt;!-- BEGIN MONKEY PATCH --\n    For deterministic outcomes.\n\n    &gt;&gt;&gt; import random\n    &gt;&gt;&gt; from dyce import rng\n    &gt;&gt;&gt; rng.RNG = random.Random(1633056380)\n\n      -- END MONKEY PATCH --&gt;\n\n    ``` python\n    &gt;&gt;&gt; roll = r_d6.roll()\n    &gt;&gt;&gt; tuple(roll.outcomes())\n    (4,)\n    &gt;&gt;&gt; roll.total()\n    4\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; d6 + 3\n    H({4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1})\n    &gt;&gt;&gt; (r_d6 + 3).roll().total() in (d6 + 3)\n    True\n\n    ```\n\n    [``Roll`` objects][dyce.r.Roll] are much richer than mere sequences of outcomes.\n    They are also tree-like structures that mirror the roller trees used to produce\n    them, capturing references to rollers and the outcomes generated at each node.\n\n    ``` python\n    &gt;&gt;&gt; roll = (r_d6 + 3).roll()\n    &gt;&gt;&gt; roll.total()\n    8\n    &gt;&gt;&gt; roll\n    Roll(\n      r=...,\n      roll_outcomes=(\n        RollOutcome(\n          value=8,\n          sources=(\n            RollOutcome(\n              value=5,\n              sources=(),\n            ),\n            RollOutcome(\n              value=3,\n              sources=(),\n            ),\n          ),\n        ),\n      ),\n      source_rolls=(\n        Roll(\n          r=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n          roll_outcomes=(\n            RollOutcome(\n              value=5,\n              sources=(),\n            ),\n          ),\n          source_rolls=(),\n        ),\n        Roll(\n          r=ValueRoller(value=3, annotation=''),\n          roll_outcomes=(\n            RollOutcome(\n              value=3,\n              sources=(),\n            ),\n          ),\n          source_rolls=(),\n        ),\n      ),\n    )\n\n    ```\n\n    Rollers afford optional annotations as a convenience to callers. They are taken into\n    account when comparing roller trees, but otherwise ignored, internally. One use is\n    to capture references to nodes in an abstract syntax tree generated from parsing a\n    proprietary grammar. Any provided *annotation* can be retrieved using the\n    [``annotation`` property][dyce.r.R.annotation]. The\n    [``annotate`` method][dyce.r.R.annotate] can be used to apply an annotation to\n    existing roller.\n\n    The ``#!python R`` class itself acts as a base from which several\n    computation-specific implementations derive (such as expressing operands like\n    outcomes or histograms, unary operations, binary operations, pools, etc.).\n\n    &lt;!-- BEGIN MONKEY PATCH --\n    For type-checking docstrings\n\n    &gt;&gt;&gt; from typing import Union\n    &gt;&gt;&gt; from dyce.r import PoolRoller, Roll, RollOutcome, ValueRoller\n    &gt;&gt;&gt; which: tuple[Union[int, slice], ...]\n\n      -- END MONKEY PATCH --&gt;\n    \"\"\"\n    __slots__: Any = (\"_annotation\", \"_sources\")\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @experimental\n    @beartype\n    def __init__(\n        self,\n        sources: Iterable[_SourceT] = (),\n        annotation: Any = \"\",\n        **kw,\n    ):\n        r\"Initializer.\"\n        super().__init__()\n        self._sources = tuple(sources)\n        self._annotation = annotation\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  sources=({_seq_repr(self.sources)}),\n  annotation={self.annotation!r},\n)\"\"\"\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        if isinstance(other, R):\n            return (\n                (isinstance(self, type(other)) or isinstance(other, type(self)))\n                and __eq__(self.sources, other.sources)  # order matters\n                and __eq__(self.annotation, other.annotation)\n            )\n        else:\n            return super().__eq__(other)\n\n    @beartype\n    def __ne__(self, other) -&gt; bool:\n        if isinstance(other, R):\n            return not __eq__(self, other)\n        else:\n            return super().__ne__(other)\n\n    @beartype\n    def __add__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n        try:\n            return self.map(__add__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __radd__(self, other: RealLike) -&gt; BinarySumOpRoller:\n        try:\n            return self.rmap(other, __add__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __sub__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n        try:\n            return self.map(__sub__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rsub__(self, other: RealLike) -&gt; BinarySumOpRoller:\n        try:\n            return self.rmap(other, __sub__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __mul__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n        try:\n            return self.map(__mul__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rmul__(self, other: RealLike) -&gt; BinarySumOpRoller:\n        try:\n            return self.rmap(other, __mul__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __matmul__(self, other: SupportsInt) -&gt; R:\n        try:\n            other = as_int(other)\n        except TypeError:\n            return NotImplemented\n\n        if other &lt; 0:\n            raise ValueError(\"argument cannot be negative\")\n        else:\n            return RepeatRoller(other, self)\n\n    @beartype\n    def __rmatmul__(self, other: SupportsInt) -&gt; R:\n        return self.__matmul__(other)\n\n    @beartype\n    def __truediv__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n        try:\n            return self.map(__truediv__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rtruediv__(self, other: RealLike) -&gt; BinarySumOpRoller:\n        try:\n            return self.rmap(other, __truediv__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __floordiv__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n        try:\n            return self.map(__floordiv__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rfloordiv__(self, other: RealLike) -&gt; BinarySumOpRoller:\n        try:\n            return self.rmap(other, __floordiv__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __mod__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n        try:\n            return self.map(__mod__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rmod__(self, other: RealLike) -&gt; BinarySumOpRoller:\n        try:\n            return self.rmap(other, __mod__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __pow__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n        try:\n            return self.map(__pow__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rpow__(self, other: RealLike) -&gt; BinarySumOpRoller:\n        try:\n            return self.rmap(other, __pow__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __and__(self, other: Union[_SourceT, SupportsInt]) -&gt; BinarySumOpRoller:\n        try:\n            if isinstance(other, R):\n                return self.map(__and__, other)\n            else:\n                return self.map(__and__, as_int(other))\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rand__(self, other: SupportsInt) -&gt; BinarySumOpRoller:\n        try:\n            return self.rmap(as_int(other), __and__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __xor__(self, other: Union[_SourceT, SupportsInt]) -&gt; BinarySumOpRoller:\n        try:\n            if isinstance(other, R):\n                return self.map(__xor__, other)\n            else:\n                return self.map(__xor__, as_int(other))\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rxor__(self, other: SupportsInt) -&gt; BinarySumOpRoller:\n        try:\n            return self.rmap(as_int(other), __xor__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __or__(self, other: Union[_SourceT, SupportsInt]) -&gt; BinarySumOpRoller:\n        try:\n            if isinstance(other, R):\n                return self.map(__or__, other)\n            else:\n                return self.map(__or__, as_int(other))\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __ror__(self, other: SupportsInt) -&gt; BinarySumOpRoller:\n        try:\n            return self.rmap(as_int(other), __or__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __neg__(self) -&gt; UnarySumOpRoller:\n        return self.umap(__neg__)\n\n    @beartype\n    def __pos__(self) -&gt; UnarySumOpRoller:\n        return self.umap(__pos__)\n\n    @beartype\n    def __abs__(self) -&gt; UnarySumOpRoller:\n        return self.umap(__abs__)\n\n    @beartype\n    def __invert__(self) -&gt; UnarySumOpRoller:\n        return self.umap(__invert__)\n\n    @abstractmethod\n    def roll(self) -&gt; Roll:\nr\"\"\"\n        Sub-classes should implement this method to return a new\n        [``Roll`` object][dyce.r.Roll] taking into account any\n        [sources][dyce.r.R.sources].\n\n        !!! note\n\n            Implementors guarantee that all [``RollOutcome``][dyce.r.RollOutcome]s in\n            the returned [``Roll``][dyce.r.Roll] *must* be associated with a roll,\n            *including all roll outcomes\u2019 [``sources``][dyce.r.RollOutcome.sources]*.\n\n        &lt;!-- BEGIN MONKEY PATCH --\n        For deterministic outcomes.\n\n        &gt;&gt;&gt; import random\n        &gt;&gt;&gt; from dyce import rng\n        &gt;&gt;&gt; rng.RNG = random.Random(1633403927)\n\n          -- END MONKEY PATCH --&gt;\n\n        !!! tip\n\n            Show that roll outcomes from source rolls are excluded by creating a new\n            roll outcome with a value of ``#!python None`` with the excluded roll\n            outcome as its source. The\n            [``RollOutcome.euthanize``][dyce.r.RollOutcome.euthanize] convenience method\n            is provided for this purpose.\n\n            See the section on \u201c[Dropping dice from prior rolls\n            \u2026](rollin.md#dropping-dice-from-prior-rolls-keeping-the-best-three-of-3d6-and-1d8)\u201d\n            as well as the note in [``Roll.__init__``][dyce.r.Roll.__init__] for\n            additional color.\n\n            ``` python\n            &gt;&gt;&gt; from itertools import chain\n            &gt;&gt;&gt; class AntonChigurhRoller(R):\n            ...   h_coin_toss = H((0, 1))\n            ...   def roll(self) -&gt; Roll:\n            ...     source_rolls = list(self.source_rolls())\n            ...     def _roll_outcomes_gen():\n            ...       for roll_outcome in chain.from_iterable(source_rolls):\n            ...         if roll_outcome.value is None:\n            ...           # Omit those already deceased\n            ...           continue\n            ...         elif self.h_coin_toss.roll():\n            ...           # This one lives. Wrap the old outcome in a new one with the same value.\n            ...           yield roll_outcome\n            ...         else:\n            ...           # This one dies here. Wrap the old outcome in a new one with a value of None.\n            ...           yield roll_outcome.euthanize()\n            ...     return Roll(self, roll_outcomes=_roll_outcomes_gen(), source_rolls=source_rolls)\n            &gt;&gt;&gt; ac_r = AntonChigurhRoller(sources=(R.from_value(1), R.from_value(2), R.from_value(3)))\n            &gt;&gt;&gt; ac_r.roll()\n            Roll(\n              r=AntonChigurhRoller(\n                sources=(\n                  ValueRoller(value=1, annotation=''),\n                  ValueRoller(value=2, annotation=''),\n                  ValueRoller(value=3, annotation=''),\n                ),\n                annotation='',\n              ),\n              roll_outcomes=(\n                RollOutcome(\n                  value=None,\n                  sources=(\n                    RollOutcome(\n                      value=1,\n                      sources=(),\n                    ),\n                  ),\n                ),\n                RollOutcome(\n                  value=2,\n                  sources=(),\n                ),\n                RollOutcome(\n                  value=3,\n                  sources=(),\n                ),\n              ),\n              source_rolls=(\n                Roll(\n                  r=ValueRoller(value=1, annotation=''),\n                  roll_outcomes=(\n                    RollOutcome(\n                      value=1,\n                      sources=(),\n                    ),\n                  ),\n                  source_rolls=(),\n                ),\n                Roll(\n                  r=ValueRoller(value=2, annotation=''),\n                  roll_outcomes=(\n                    RollOutcome(\n                      value=2,\n                      sources=(),\n                    ),\n                  ),\n                  source_rolls=(),\n                ),\n                Roll(\n                  r=ValueRoller(value=3, annotation=''),\n                  roll_outcomes=(\n                    RollOutcome(\n                      value=3,\n                      sources=(),\n                    ),\n                  ),\n                  source_rolls=(),\n                ),\n              ),\n            )\n\n            ```\n        \"\"\"\n        ...\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def annotation(self) -&gt; Any:\nr\"\"\"\n        Any provided annotation.\n        \"\"\"\n        return self._annotation\n\n    @property\n    def sources(self) -&gt; tuple[_SourceT, ...]:\nr\"\"\"\n        The roller\u2019s direct sources (if any).\n        \"\"\"\n        return self._sources\n\n    # ---- Methods ---------------------------------------------------------------------\n\n    @classmethod\n    @beartype\n    def from_sources(\n        cls,\n        *sources: _SourceT,\n        annotation: Any = \"\",\n    ) -&gt; PoolRoller:\nr\"\"\"\n        Shorthand for ``#!python cls.from_sources_iterable(rs, annotation=annotation)``.\n\n        See the [``from_sources_iterable`` method][dyce.r.R.from_sources_iterable].\n        \"\"\"\n        return cls.from_sources_iterable(sources, annotation=annotation)\n\n    @classmethod\n    @beartype\n    def from_sources_iterable(\n        cls,\n        sources: Iterable[_SourceT],\n        annotation: Any = \"\",\n    ) -&gt; PoolRoller:\nr\"\"\"\n        Creates and returns a roller for \u201cpooling\u201d zero or more *sources*.\n\n        &lt;!-- BEGIN MONKEY PATCH --\n        For deterministic outcomes.\n\n        &gt;&gt;&gt; import random\n        &gt;&gt;&gt; from dyce import rng\n        &gt;&gt;&gt; rng.RNG = random.Random(1633056341)\n\n          -- END MONKEY PATCH --&gt;\n\n        ``` python\n        &gt;&gt;&gt; r_pool = R.from_sources_iterable(R.from_value(h) for h in (H((1, 2)), H((3, 4)), H((5, 6))))\n        &gt;&gt;&gt; roll = r_pool.roll()\n        &gt;&gt;&gt; tuple(roll.outcomes())\n        (2, 4, 6)\n        &gt;&gt;&gt; roll\n        Roll(\n          r=...,\n          roll_outcomes=(\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n            RollOutcome(\n              value=4,\n              sources=(),\n            ),\n            RollOutcome(\n              value=6,\n              sources=(),\n            ),\n          ),\n          source_rolls=...,\n        )\n\n        ```\n        \"\"\"\n        return PoolRoller(sources, annotation=annotation)\n\n    @classmethod\n    @beartype\n    def from_value(\n        cls,\n        value: _ValueT,\n        annotation: Any = \"\",\n    ) -&gt; ValueRoller:\nr\"\"\"\n        Creates and returns a [``ValueRoller``][dyce.r.ValueRoller] from *value*.\n\n        ``` python\n        &gt;&gt;&gt; R.from_value(6)\n        ValueRoller(value=6, annotation='')\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; R.from_value(H(6))\n        ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation='')\n\n        ```\n\n        ``` python\n        &gt;&gt;&gt; R.from_value(P(6, 6))\n        ValueRoller(value=2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})), annotation='')\n\n        ```\n        \"\"\"\n        return ValueRoller(value, annotation=annotation)\n\n    @classmethod\n    @beartype\n    def from_values(\n        cls,\n        *values: _ValueT,\n        annotation: Any = \"\",\n    ) -&gt; PoolRoller:\nr\"\"\"\n        Shorthand for ``#!python cls.from_values_iterable(values, annotation=annotation)``.\n\n        See the [``from_values_iterable`` method][dyce.r.R.from_values_iterable].\n        \"\"\"\n        return cls.from_values_iterable(values, annotation=annotation)\n\n    @classmethod\n    @beartype\n    def from_values_iterable(\n        cls,\n        values: Iterable[_ValueT],\n        annotation: Any = \"\",\n    ) -&gt; PoolRoller:\nr\"\"\"\n        Shorthand for ``#!python cls.from_sources_iterable((cls.from_value(value) for value\n        in values), annotation=annotation)``.\n\n        See the [``from_value``][dyce.r.R.from_value] and\n        [``from_sources_iterable``][dyce.r.R.from_sources_iterable] methods.\n        \"\"\"\n        return cls.from_sources_iterable(\n            (cls.from_value(value) for value in values),\n            annotation=annotation,\n        )\n\n    @classmethod\n    @beartype\n    def filter_from_sources(\n        cls,\n        predicate: _PredicateT,\n        *sources: _SourceT,\n        annotation: Any = \"\",\n    ) -&gt; FilterRoller:\nr\"\"\"\n        Shorthand for ``#!python cls.filter_from_sources_iterable(predicate, sources,\n        annotation=annotation)``.\n\n        See the [``filter_from_sources_iterable``\n        method][dyce.r.R.filter_from_sources_iterable].\n        \"\"\"\n        return cls.filter_from_sources_iterable(\n            predicate, sources, annotation=annotation\n        )\n\n    @classmethod\n    @beartype\n    def filter_from_sources_iterable(\n        cls,\n        predicate: _PredicateT,\n        sources: Iterable[_SourceT],\n        annotation: Any = \"\",\n    ) -&gt; FilterRoller:\nr\"\"\"\n        Creates and returns a [``FilterRoller``][dyce.r.FilterRoller] for applying filterion\n        *predicate* to sorted outcomes from *sources*.\n\n        ``` python\n        &gt;&gt;&gt; r_filter = R.filter_from_sources_iterable(\n        ...   lambda outcome: bool(outcome.is_even().value),\n        ...   (R.from_value(i) for i in (5, 4, 6, 3, 7, 2, 8, 1, 9, 0)),\n        ... ) ; r_filter\n        FilterRoller(\n          predicate=&lt;function &lt;lambda&gt; at ...&gt;,\n          sources=(\n            ValueRoller(value=5, annotation=''),\n            ValueRoller(value=4, annotation=''),\n            ...,\n            ValueRoller(value=9, annotation=''),\n            ValueRoller(value=0, annotation=''),\n          ),\n          annotation='',\n        )\n        &gt;&gt;&gt; tuple(r_filter.roll().outcomes())\n        (4, 6, 2, 8, 0)\n\n        ```\n        \"\"\"\n        return FilterRoller(predicate, sources, annotation=annotation)\n\n    @classmethod\n    @beartype\n    def filter_from_values(\n        cls,\n        predicate: _PredicateT,\n        *values: _ValueT,\n        annotation: Any = \"\",\n    ) -&gt; FilterRoller:\nr\"\"\"\n        Shorthand for ``#!python cls.filter_from_values_iterable(predicate, values,\n        annotation=annotation)``.\n\n        See the\n        [``filter_from_values_iterable`` method][dyce.r.R.filter_from_values_iterable].\n        \"\"\"\n        return cls.filter_from_values_iterable(predicate, values, annotation=annotation)\n\n    @classmethod\n    @beartype\n    def filter_from_values_iterable(\n        cls,\n        predicate: _PredicateT,\n        values: Iterable[_ValueT],\n        annotation: Any = \"\",\n    ) -&gt; FilterRoller:\nr\"\"\"\n        Shorthand for ``#!python cls.filter_from_sources_iterable((cls.from_value(value) for\n        value in values), annotation=annotation)``.\n\n        See the [``from_value``][dyce.r.R.from_value] and\n        [``filter_from_sources_iterable``][dyce.r.R.filter_from_sources_iterable]\n        methods.\n        \"\"\"\n        return cls.filter_from_sources_iterable(\n            predicate,\n            (cls.from_value(value) for value in values),\n            annotation=annotation,\n        )\n\n    @classmethod\n    @beartype\n    def select_from_sources(\n        cls,\n        which: Iterable[_GetItemT],\n        *sources: _SourceT,\n        annotation: Any = \"\",\n    ) -&gt; SelectionRoller:\nr\"\"\"\n        Shorthand for ``#!python cls.select_from_sources_iterable(which, sources,\n        annotation=annotation)``.\n\n        See the [``select_from_sources_iterable``\n        method][dyce.r.R.select_from_sources_iterable].\n        \"\"\"\n        return cls.select_from_sources_iterable(which, sources, annotation=annotation)\n\n    @classmethod\n    @beartype\n    def select_from_sources_iterable(\n        cls,\n        which: Iterable[_GetItemT],\n        sources: Iterable[_SourceT],\n        annotation: Any = \"\",\n    ) -&gt; SelectionRoller:\nr\"\"\"\n        Creates and returns a [``SelectionRoller``][dyce.r.SelectionRoller] for applying\n        selection *which* to sorted outcomes from *sources*.\n\n        ``` python\n        &gt;&gt;&gt; r_select = R.select_from_sources_iterable(\n        ...   (0, -1, slice(3, 6), slice(6, 3, -1), -1, 0),\n        ...   (R.from_value(i) for i in (5, 4, 6, 3, 7, 2, 8, 1, 9, 0)),\n        ... ) ; r_select\n        SelectionRoller(\n          which=(0, -1, slice(3, 6, None), slice(6, 3, -1), -1, 0),\n          sources=(\n            ValueRoller(value=5, annotation=''),\n            ValueRoller(value=4, annotation=''),\n            ...,\n            ValueRoller(value=9, annotation=''),\n            ValueRoller(value=0, annotation=''),\n          ),\n          annotation='',\n        )\n        &gt;&gt;&gt; tuple(r_select.roll().outcomes())\n        (0, 9, 3, 4, 5, 6, 5, 4, 9, 0)\n\n        ```\n        \"\"\"\n        return SelectionRoller(which, sources, annotation=annotation)\n\n    @classmethod\n    @beartype\n    def select_from_values(\n        cls,\n        which: Iterable[_GetItemT],\n        *values: _ValueT,\n        annotation: Any = \"\",\n    ) -&gt; SelectionRoller:\nr\"\"\"\n        Shorthand for ``#!python cls.select_from_values_iterable(which, values,\n        annotation=annotation)``.\n\n        See the\n        [``select_from_values_iterable`` method][dyce.r.R.select_from_values_iterable].\n        \"\"\"\n        return cls.select_from_values_iterable(which, values, annotation=annotation)\n\n    @classmethod\n    @beartype\n    def select_from_values_iterable(\n        cls,\n        which: Iterable[_GetItemT],\n        values: Iterable[_ValueT],\n        annotation: Any = \"\",\n    ) -&gt; SelectionRoller:\nr\"\"\"\n        Shorthand for ``#!python cls.select_from_sources_iterable((cls.from_value(value) for\n        value in values), annotation=annotation)``.\n\n        See the [``from_value``][dyce.r.R.from_value] and\n        [``select_from_sources_iterable``][dyce.r.R.select_from_sources_iterable]\n        methods.\n        \"\"\"\n        return cls.select_from_sources_iterable(\n            which,\n            (cls.from_value(value) for value in values),\n            annotation=annotation,\n        )\n\n    @beartype\n    def source_rolls(self) -&gt; Iterator[\"Roll\"]:\nr\"\"\"\n        Generates new rolls from all [``sources``][dyce.r.R.sources].\n        \"\"\"\n        for source in self.sources:\n            yield source.roll()\n\n    @beartype\n    def annotate(self, annotation: Any = \"\") -&gt; R:\nr\"\"\"\n        Generates a copy of the roller with the desired annotation.\n\n        ``` python\n        &gt;&gt;&gt; r_just_the_n_of_us = R.from_value(5, annotation=\"But I'm 42!\") ; r_just_the_n_of_us\n        ValueRoller(value=5, annotation=\"But I'm 42!\")\n        &gt;&gt;&gt; r_just_the_n_of_us.annotate(\"I'm a 42-year-old investment banker!\")\n        ValueRoller(value=5, annotation=\"I'm a 42-year-old investment banker!\")\n\n        ```\n        \"\"\"\n        r = copy(self)\n        r._annotation = annotation\n\n        return r\n\n    @beartype\n    def map(\n        self,\n        bin_op: _RollOutcomeBinaryOperatorT,\n        right_operand: _ROperandT,\n        annotation: Any = \"\",\n    ) -&gt; BinarySumOpRoller:\nr\"\"\"\n        Creates and returns a [``BinarySumOpRoller``][dyce.r.BinarySumOpRoller] for applying\n        *bin_op* to this roller and *right_operand* as its sources. Shorthands exist for\n        many arithmetic operators and comparators.\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; r_bin_op = R.from_value(H(6)).map(operator.__pow__, 2) ; r_bin_op\n        BinarySumOpRoller(\n          bin_op=&lt;built-in function pow&gt;,\n          left_source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n          right_source=ValueRoller(value=2, annotation=''),\n          annotation='',\n        )\n        &gt;&gt;&gt; r_bin_op == R.from_value(H(6)) ** 2\n        True\n\n        ```\n        \"\"\"\n        if isinstance(right_operand, RealLike):\n            right_operand = ValueRoller(right_operand)\n\n        if isinstance(right_operand, (R, RollOutcome)):\n            return BinarySumOpRoller(bin_op, self, right_operand, annotation=annotation)\n        else:\n            raise NotImplementedError\n\n    @beartype\n    def rmap(\n        self,\n        # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n        left_operand: Union[RealLike, \"RollOutcome\"],\n        bin_op: _RollOutcomeBinaryOperatorT,\n        annotation: Any = \"\",\n    ) -&gt; BinarySumOpRoller:\nr\"\"\"\n        Analogous to the [``map`` method][dyce.r.R.map], but where the caller supplies\n        *left_operand*.\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; r_bin_op = R.from_value(H(6)).rmap(2, operator.__pow__) ; r_bin_op\n        BinarySumOpRoller(\n          bin_op=&lt;built-in function pow&gt;,\n          left_source=ValueRoller(value=2, annotation=''),\n          right_source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n          annotation='',\n        )\n        &gt;&gt;&gt; r_bin_op == 2 ** R.from_value(H(6))\n        True\n\n        ```\n\n        !!! note\n\n            The positions of *left_operand* and *bin_op* are different from\n            [``map`` method][dyce.r.R.map]. This is intentional and serves as a reminder\n            of operand ordering.\n        \"\"\"\n        if isinstance(left_operand, RealLike):\n            return BinarySumOpRoller(\n                bin_op, ValueRoller(left_operand), self, annotation=annotation\n            )\n        elif isinstance(left_operand, RollOutcome):\n            return BinarySumOpRoller(bin_op, left_operand, self, annotation=annotation)\n        else:\n            raise NotImplementedError\n\n    @beartype\n    def umap(\n        self,\n        un_op: _RollOutcomeUnaryOperatorT,\n        annotation: Any = \"\",\n    ) -&gt; UnarySumOpRoller:\nr\"\"\"\n        Creates and returns a [``UnarySumOpRoller``][dyce.r.UnarySumOpRoller] roller for\n        applying *un_op* to this roller as its source.\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; r_un_op = R.from_value(H(6)).umap(operator.__neg__) ; r_un_op\n        UnarySumOpRoller(\n          un_op=&lt;built-in function neg&gt;,\n          source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n          annotation='',\n        )\n        &gt;&gt;&gt; r_un_op == -R.from_value(H(6))\n        True\n\n        ```\n        \"\"\"\n        return UnarySumOpRoller(un_op, self, annotation=annotation)\n\n    @beartype\n    def lt(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n        Shorthand for ``#!python self.map(lambda left, right: left.lt(right), other)``.\n\n        See the [``map`` method][dyce.r.R.map].\n        \"\"\"\n\n        def _lt(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n            return left_operand.lt(right_operand)\n\n        return self.map(_lt, other)\n\n    @beartype\n    def le(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n        Shorthand for ``#!python self.map(lambda left, right: left.le(right), other)``.\n\n        See the [``map`` method][dyce.r.R.map].\n        \"\"\"\n\n        def _le(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n            return left_operand.le(right_operand)\n\n        return self.map(_le, other)\n\n    @beartype\n    def eq(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n        Shorthand for ``#!python self.map(lambda left, right: left.eq(right), other)``.\n\n        See the [``map`` method][dyce.r.R.map].\n        \"\"\"\n\n        def _eq(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n            return left_operand.eq(right_operand)\n\n        return self.map(_eq, other)\n\n    @beartype\n    def ne(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n        Shorthand for ``#!python self.map(lambda left, right: left.ne(right), other)``.\n\n        See the [``map`` method][dyce.r.R.map].\n        \"\"\"\n\n        def _ne(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n            return left_operand.ne(right_operand)\n\n        return self.map(_ne, other)\n\n    @beartype\n    def gt(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n        Shorthand for ``#!python self.map(lambda left, right: left.gt(right), other)``.\n\n        See the [``map`` method][dyce.r.R.map].\n        \"\"\"\n\n        def _gt(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n            return left_operand.gt(right_operand)\n\n        return self.map(_gt, other)\n\n    @beartype\n    def ge(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n        Shorthand for ``#!python self.map(lambda left, right: left.ge(right), other)``.\n\n        See the [``map`` method][dyce.r.R.map].\n        \"\"\"\n\n        def _ge(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n            return left_operand.ge(right_operand)\n\n        return self.map(_ge, other)\n\n    @beartype\n    def is_even(self) -&gt; UnarySumOpRoller:\nr\"\"\"\n        Shorthand for: ``#!python self.umap(lambda operand: operand.is_even())``.\n\n        See the [``umap`` method][dyce.r.R.umap].\n        \"\"\"\n\n        def _is_even(operand: RollOutcome) -&gt; RollOutcome:\n            return operand.is_even()\n\n        return self.umap(_is_even)\n\n    @beartype\n    def is_odd(self) -&gt; UnarySumOpRoller:\nr\"\"\"\n        Shorthand for: ``#!python self.umap(lambda operand: operand.is_odd())``.\n\n        See the [``umap`` method][dyce.r.R.umap].\n        \"\"\"\n\n        def _is_odd(operand: RollOutcome) -&gt; RollOutcome:\n            return operand.is_odd()\n\n        return self.umap(_is_odd)\n\n    @beartype\n    def filter(\n        self,\n        predicate: _PredicateT,\n        annotation: Any = \"\",\n    ) -&gt; FilterRoller:\nr\"\"\"\n        Shorthand for ``#!python type(self).filter_from_sources(predicate, self,\n        annotation=annotation)``.\n\n        See the [``filter_from_sources`` method][dyce.r.R.filter_from_sources].\n        \"\"\"\n        return type(self).filter_from_sources(predicate, self, annotation=annotation)\n\n    @beartype\n    def select(\n        self,\n        *which: _GetItemT,\n        annotation: Any = \"\",\n    ) -&gt; SelectionRoller:\nr\"\"\"\n        Shorthand for ``#!python self.select_iterable(which, annotation=annotation)``.\n\n        See the [``select_iterable`` method][dyce.r.R.select_iterable].\n        \"\"\"\n        return self.select_iterable(which, annotation=annotation)\n\n    @beartype\n    def select_iterable(\n        self,\n        which: Iterable[_GetItemT],\n        annotation: Any = \"\",\n    ) -&gt; SelectionRoller:\nr\"\"\"\n        Shorthand for ``#!python type(self).select_from_sources(which, self,\n        annotation=annotation)``.\n\n        See the [``select_from_sources`` method][dyce.r.R.select_from_sources].\n        \"\"\"\n        return type(self).select_from_sources(which, self, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__slots__","title":"<code>__slots__: Any = ('_annotation', '_sources')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.R.annotation","title":"<code>annotation: Any</code>  <code>property</code>","text":"<p>Any provided annotation.</p>"},{"location":"dyce.r/#dyce.r.R.sources","title":"<code>sources: tuple[_SourceT, ...]</code>  <code>property</code>","text":"<p>The roller\u2019s direct sources (if any).</p>"},{"location":"dyce.r/#dyce.r.R.__abs__","title":"<code>__abs__() -&gt; UnarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __abs__(self) -&gt; UnarySumOpRoller:\n    return self.umap(__abs__)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__add__","title":"<code>__add__(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __add__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n    try:\n        return self.map(__add__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__and__","title":"<code>__and__(other: Union[_SourceT, SupportsInt]) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __and__(self, other: Union[_SourceT, SupportsInt]) -&gt; BinarySumOpRoller:\n    try:\n        if isinstance(other, R):\n            return self.map(__and__, other)\n        else:\n            return self.map(__and__, as_int(other))\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    if isinstance(other, R):\n        return (\n            (isinstance(self, type(other)) or isinstance(other, type(self)))\n            and __eq__(self.sources, other.sources)  # order matters\n            and __eq__(self.annotation, other.annotation)\n        )\n    else:\n        return super().__eq__(other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__floordiv__","title":"<code>__floordiv__(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __floordiv__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n    try:\n        return self.map(__floordiv__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__init__","title":"<code>__init__(sources: Iterable[_SourceT] = (), annotation: Any = '', **kw: Any)</code>","text":"<p>Initializer.</p> Source code in <code>dyce/r.py</code> <pre><code>@experimental\n@beartype\ndef __init__(\n    self,\n    sources: Iterable[_SourceT] = (),\n    annotation: Any = \"\",\n    **kw,\n):\n    r\"Initializer.\"\n    super().__init__()\n    self._sources = tuple(sources)\n    self._annotation = annotation\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__invert__","title":"<code>__invert__() -&gt; UnarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __invert__(self) -&gt; UnarySumOpRoller:\n    return self.umap(__invert__)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__matmul__","title":"<code>__matmul__(other: SupportsInt) -&gt; R</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __matmul__(self, other: SupportsInt) -&gt; R:\n    try:\n        other = as_int(other)\n    except TypeError:\n        return NotImplemented\n\n    if other &lt; 0:\n        raise ValueError(\"argument cannot be negative\")\n    else:\n        return RepeatRoller(other, self)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__mod__","title":"<code>__mod__(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __mod__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n    try:\n        return self.map(__mod__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__mul__","title":"<code>__mul__(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __mul__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n    try:\n        return self.map(__mul__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__ne__","title":"<code>__ne__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __ne__(self, other) -&gt; bool:\n    if isinstance(other, R):\n        return not __eq__(self, other)\n    else:\n        return super().__ne__(other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__neg__","title":"<code>__neg__() -&gt; UnarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __neg__(self) -&gt; UnarySumOpRoller:\n    return self.umap(__neg__)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__or__","title":"<code>__or__(other: Union[_SourceT, SupportsInt]) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __or__(self, other: Union[_SourceT, SupportsInt]) -&gt; BinarySumOpRoller:\n    try:\n        if isinstance(other, R):\n            return self.map(__or__, other)\n        else:\n            return self.map(__or__, as_int(other))\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__pos__","title":"<code>__pos__() -&gt; UnarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __pos__(self) -&gt; UnarySumOpRoller:\n    return self.umap(__pos__)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__pow__","title":"<code>__pow__(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __pow__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n    try:\n        return self.map(__pow__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__radd__","title":"<code>__radd__(other: RealLike) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __radd__(self, other: RealLike) -&gt; BinarySumOpRoller:\n    try:\n        return self.rmap(other, __add__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__rand__","title":"<code>__rand__(other: SupportsInt) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rand__(self, other: SupportsInt) -&gt; BinarySumOpRoller:\n    try:\n        return self.rmap(as_int(other), __and__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  sources=({_seq_repr(self.sources)}),\n  annotation={self.annotation!r},\n)\"\"\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__rfloordiv__","title":"<code>__rfloordiv__(other: RealLike) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rfloordiv__(self, other: RealLike) -&gt; BinarySumOpRoller:\n    try:\n        return self.rmap(other, __floordiv__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__rmatmul__","title":"<code>__rmatmul__(other: SupportsInt) -&gt; R</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rmatmul__(self, other: SupportsInt) -&gt; R:\n    return self.__matmul__(other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__rmod__","title":"<code>__rmod__(other: RealLike) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rmod__(self, other: RealLike) -&gt; BinarySumOpRoller:\n    try:\n        return self.rmap(other, __mod__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__rmul__","title":"<code>__rmul__(other: RealLike) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rmul__(self, other: RealLike) -&gt; BinarySumOpRoller:\n    try:\n        return self.rmap(other, __mul__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__ror__","title":"<code>__ror__(other: SupportsInt) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __ror__(self, other: SupportsInt) -&gt; BinarySumOpRoller:\n    try:\n        return self.rmap(as_int(other), __or__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__rpow__","title":"<code>__rpow__(other: RealLike) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rpow__(self, other: RealLike) -&gt; BinarySumOpRoller:\n    try:\n        return self.rmap(other, __pow__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__rsub__","title":"<code>__rsub__(other: RealLike) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rsub__(self, other: RealLike) -&gt; BinarySumOpRoller:\n    try:\n        return self.rmap(other, __sub__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__rtruediv__","title":"<code>__rtruediv__(other: RealLike) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rtruediv__(self, other: RealLike) -&gt; BinarySumOpRoller:\n    try:\n        return self.rmap(other, __truediv__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__rxor__","title":"<code>__rxor__(other: SupportsInt) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rxor__(self, other: SupportsInt) -&gt; BinarySumOpRoller:\n    try:\n        return self.rmap(as_int(other), __xor__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__sub__","title":"<code>__sub__(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __sub__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n    try:\n        return self.map(__sub__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__truediv__","title":"<code>__truediv__(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __truediv__(self, other: _ROperandT) -&gt; BinarySumOpRoller:\n    try:\n        return self.map(__truediv__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.__xor__","title":"<code>__xor__(other: Union[_SourceT, SupportsInt]) -&gt; BinarySumOpRoller</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __xor__(self, other: Union[_SourceT, SupportsInt]) -&gt; BinarySumOpRoller:\n    try:\n        if isinstance(other, R):\n            return self.map(__xor__, other)\n        else:\n            return self.map(__xor__, as_int(other))\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.annotate","title":"<code>annotate(annotation: Any = '') -&gt; R</code>","text":"<p>Generates a copy of the roller with the desired annotation.</p> <pre><code>&gt;&gt;&gt; r_just_the_n_of_us = R.from_value(5, annotation=\"But I'm 42!\") ; r_just_the_n_of_us\nValueRoller(value=5, annotation=\"But I'm 42!\")\n&gt;&gt;&gt; r_just_the_n_of_us.annotate(\"I'm a 42-year-old investment banker!\")\nValueRoller(value=5, annotation=\"I'm a 42-year-old investment banker!\")\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef annotate(self, annotation: Any = \"\") -&gt; R:\nr\"\"\"\n    Generates a copy of the roller with the desired annotation.\n\n    ``` python\n    &gt;&gt;&gt; r_just_the_n_of_us = R.from_value(5, annotation=\"But I'm 42!\") ; r_just_the_n_of_us\n    ValueRoller(value=5, annotation=\"But I'm 42!\")\n    &gt;&gt;&gt; r_just_the_n_of_us.annotate(\"I'm a 42-year-old investment banker!\")\n    ValueRoller(value=5, annotation=\"I'm a 42-year-old investment banker!\")\n\n    ```\n    \"\"\"\n    r = copy(self)\n    r._annotation = annotation\n\n    return r\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.eq","title":"<code>eq(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"<p>Shorthand for <code>self.map(lambda left, right: left.eq(right), other)</code>.</p> <p>See the <code>map</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef eq(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n    Shorthand for ``#!python self.map(lambda left, right: left.eq(right), other)``.\n\n    See the [``map`` method][dyce.r.R.map].\n    \"\"\"\n\n    def _eq(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n        return left_operand.eq(right_operand)\n\n    return self.map(_eq, other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.filter","title":"<code>filter(predicate: _PredicateT, annotation: Any = '') -&gt; FilterRoller</code>","text":"<p>Shorthand for <code>type(self).filter_from_sources(predicate, self,annotation=annotation)</code>.</p> <p>See the <code>filter_from_sources</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef filter(\n    self,\n    predicate: _PredicateT,\n    annotation: Any = \"\",\n) -&gt; FilterRoller:\nr\"\"\"\n    Shorthand for ``#!python type(self).filter_from_sources(predicate, self,\n    annotation=annotation)``.\n\n    See the [``filter_from_sources`` method][dyce.r.R.filter_from_sources].\n    \"\"\"\n    return type(self).filter_from_sources(predicate, self, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.filter_from_sources","title":"<code>filter_from_sources(predicate: _PredicateT, *sources: _SourceT, annotation: Any = '') -&gt; FilterRoller</code>  <code>classmethod</code>","text":"<p>Shorthand for <code>cls.filter_from_sources_iterable(predicate, sources,annotation=annotation)</code>.</p> <p>See the <code>filter_from_sources_iterable</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef filter_from_sources(\n    cls,\n    predicate: _PredicateT,\n    *sources: _SourceT,\n    annotation: Any = \"\",\n) -&gt; FilterRoller:\nr\"\"\"\n    Shorthand for ``#!python cls.filter_from_sources_iterable(predicate, sources,\n    annotation=annotation)``.\n\n    See the [``filter_from_sources_iterable``\n    method][dyce.r.R.filter_from_sources_iterable].\n    \"\"\"\n    return cls.filter_from_sources_iterable(\n        predicate, sources, annotation=annotation\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.filter_from_sources_iterable","title":"<code>filter_from_sources_iterable(predicate: _PredicateT, sources: Iterable[_SourceT], annotation: Any = '') -&gt; FilterRoller</code>  <code>classmethod</code>","text":"<p>Creates and returns a <code>FilterRoller</code> for applying filterion predicate to sorted outcomes from sources.</p> <pre><code>&gt;&gt;&gt; r_filter = R.filter_from_sources_iterable(\n...   lambda outcome: bool(outcome.is_even().value),\n...   (R.from_value(i) for i in (5, 4, 6, 3, 7, 2, 8, 1, 9, 0)),\n... ) ; r_filter\nFilterRoller(\n  predicate=&lt;function &lt;lambda&gt; at ...&gt;,\n  sources=(\n    ValueRoller(value=5, annotation=''),\n    ValueRoller(value=4, annotation=''),\n    ...,\n    ValueRoller(value=9, annotation=''),\n    ValueRoller(value=0, annotation=''),\n  ),\n  annotation='',\n)\n&gt;&gt;&gt; tuple(r_filter.roll().outcomes())\n(4, 6, 2, 8, 0)\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef filter_from_sources_iterable(\n    cls,\n    predicate: _PredicateT,\n    sources: Iterable[_SourceT],\n    annotation: Any = \"\",\n) -&gt; FilterRoller:\nr\"\"\"\n    Creates and returns a [``FilterRoller``][dyce.r.FilterRoller] for applying filterion\n    *predicate* to sorted outcomes from *sources*.\n\n    ``` python\n    &gt;&gt;&gt; r_filter = R.filter_from_sources_iterable(\n    ...   lambda outcome: bool(outcome.is_even().value),\n    ...   (R.from_value(i) for i in (5, 4, 6, 3, 7, 2, 8, 1, 9, 0)),\n    ... ) ; r_filter\n    FilterRoller(\n      predicate=&lt;function &lt;lambda&gt; at ...&gt;,\n      sources=(\n        ValueRoller(value=5, annotation=''),\n        ValueRoller(value=4, annotation=''),\n        ...,\n        ValueRoller(value=9, annotation=''),\n        ValueRoller(value=0, annotation=''),\n      ),\n      annotation='',\n    )\n    &gt;&gt;&gt; tuple(r_filter.roll().outcomes())\n    (4, 6, 2, 8, 0)\n\n    ```\n    \"\"\"\n    return FilterRoller(predicate, sources, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.filter_from_values","title":"<code>filter_from_values(predicate: _PredicateT, *values: _ValueT, annotation: Any = '') -&gt; FilterRoller</code>  <code>classmethod</code>","text":"<p>Shorthand for <code>cls.filter_from_values_iterable(predicate, values,annotation=annotation)</code>.</p> <p>See the <code>filter_from_values_iterable</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef filter_from_values(\n    cls,\n    predicate: _PredicateT,\n    *values: _ValueT,\n    annotation: Any = \"\",\n) -&gt; FilterRoller:\nr\"\"\"\n    Shorthand for ``#!python cls.filter_from_values_iterable(predicate, values,\n    annotation=annotation)``.\n\n    See the\n    [``filter_from_values_iterable`` method][dyce.r.R.filter_from_values_iterable].\n    \"\"\"\n    return cls.filter_from_values_iterable(predicate, values, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.filter_from_values_iterable","title":"<code>filter_from_values_iterable(predicate: _PredicateT, values: Iterable[_ValueT], annotation: Any = '') -&gt; FilterRoller</code>  <code>classmethod</code>","text":"<p>Shorthand for <code>cls.filter_from_sources_iterable((cls.from_value(value) forvalue in values), annotation=annotation)</code>.</p> <p>See the <code>from_value</code> and <code>filter_from_sources_iterable</code> methods.</p> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef filter_from_values_iterable(\n    cls,\n    predicate: _PredicateT,\n    values: Iterable[_ValueT],\n    annotation: Any = \"\",\n) -&gt; FilterRoller:\nr\"\"\"\n    Shorthand for ``#!python cls.filter_from_sources_iterable((cls.from_value(value) for\n    value in values), annotation=annotation)``.\n\n    See the [``from_value``][dyce.r.R.from_value] and\n    [``filter_from_sources_iterable``][dyce.r.R.filter_from_sources_iterable]\n    methods.\n    \"\"\"\n    return cls.filter_from_sources_iterable(\n        predicate,\n        (cls.from_value(value) for value in values),\n        annotation=annotation,\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.from_sources","title":"<code>from_sources(*sources: _SourceT, annotation: Any = '') -&gt; PoolRoller</code>  <code>classmethod</code>","text":"<p>Shorthand for <code>cls.from_sources_iterable(rs, annotation=annotation)</code>.</p> <p>See the <code>from_sources_iterable</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef from_sources(\n    cls,\n    *sources: _SourceT,\n    annotation: Any = \"\",\n) -&gt; PoolRoller:\nr\"\"\"\n    Shorthand for ``#!python cls.from_sources_iterable(rs, annotation=annotation)``.\n\n    See the [``from_sources_iterable`` method][dyce.r.R.from_sources_iterable].\n    \"\"\"\n    return cls.from_sources_iterable(sources, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.from_sources_iterable","title":"<code>from_sources_iterable(sources: Iterable[_SourceT], annotation: Any = '') -&gt; PoolRoller</code>  <code>classmethod</code>","text":"<p>Creates and returns a roller for \u201cpooling\u201d zero or more sources.</p> <pre><code>&gt;&gt;&gt; r_pool = R.from_sources_iterable(R.from_value(h) for h in (H((1, 2)), H((3, 4)), H((5, 6))))\n&gt;&gt;&gt; roll = r_pool.roll()\n&gt;&gt;&gt; tuple(roll.outcomes())\n(2, 4, 6)\n&gt;&gt;&gt; roll\nRoll(\n  r=...,\n  roll_outcomes=(\n    RollOutcome(\n      value=2,\n      sources=(),\n    ),\n    RollOutcome(\n      value=4,\n      sources=(),\n    ),\n    RollOutcome(\n      value=6,\n      sources=(),\n    ),\n  ),\n  source_rolls=...,\n)\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef from_sources_iterable(\n    cls,\n    sources: Iterable[_SourceT],\n    annotation: Any = \"\",\n) -&gt; PoolRoller:\nr\"\"\"\n    Creates and returns a roller for \u201cpooling\u201d zero or more *sources*.\n\n    &lt;!-- BEGIN MONKEY PATCH --\n    For deterministic outcomes.\n\n    &gt;&gt;&gt; import random\n    &gt;&gt;&gt; from dyce import rng\n    &gt;&gt;&gt; rng.RNG = random.Random(1633056341)\n\n      -- END MONKEY PATCH --&gt;\n\n    ``` python\n    &gt;&gt;&gt; r_pool = R.from_sources_iterable(R.from_value(h) for h in (H((1, 2)), H((3, 4)), H((5, 6))))\n    &gt;&gt;&gt; roll = r_pool.roll()\n    &gt;&gt;&gt; tuple(roll.outcomes())\n    (2, 4, 6)\n    &gt;&gt;&gt; roll\n    Roll(\n      r=...,\n      roll_outcomes=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n        RollOutcome(\n          value=4,\n          sources=(),\n        ),\n        RollOutcome(\n          value=6,\n          sources=(),\n        ),\n      ),\n      source_rolls=...,\n    )\n\n    ```\n    \"\"\"\n    return PoolRoller(sources, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.from_value","title":"<code>from_value(value: _ValueT, annotation: Any = '') -&gt; ValueRoller</code>  <code>classmethod</code>","text":"<p>Creates and returns a <code>ValueRoller</code> from value.</p> <pre><code>&gt;&gt;&gt; R.from_value(6)\nValueRoller(value=6, annotation='')\n</code></pre> <pre><code>&gt;&gt;&gt; R.from_value(H(6))\nValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation='')\n</code></pre> <pre><code>&gt;&gt;&gt; R.from_value(P(6, 6))\nValueRoller(value=2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})), annotation='')\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef from_value(\n    cls,\n    value: _ValueT,\n    annotation: Any = \"\",\n) -&gt; ValueRoller:\nr\"\"\"\n    Creates and returns a [``ValueRoller``][dyce.r.ValueRoller] from *value*.\n\n    ``` python\n    &gt;&gt;&gt; R.from_value(6)\n    ValueRoller(value=6, annotation='')\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; R.from_value(H(6))\n    ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation='')\n\n    ```\n\n    ``` python\n    &gt;&gt;&gt; R.from_value(P(6, 6))\n    ValueRoller(value=2@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})), annotation='')\n\n    ```\n    \"\"\"\n    return ValueRoller(value, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.from_values","title":"<code>from_values(*values: _ValueT, annotation: Any = '') -&gt; PoolRoller</code>  <code>classmethod</code>","text":"<p>Shorthand for <code>cls.from_values_iterable(values, annotation=annotation)</code>.</p> <p>See the <code>from_values_iterable</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef from_values(\n    cls,\n    *values: _ValueT,\n    annotation: Any = \"\",\n) -&gt; PoolRoller:\nr\"\"\"\n    Shorthand for ``#!python cls.from_values_iterable(values, annotation=annotation)``.\n\n    See the [``from_values_iterable`` method][dyce.r.R.from_values_iterable].\n    \"\"\"\n    return cls.from_values_iterable(values, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.from_values_iterable","title":"<code>from_values_iterable(values: Iterable[_ValueT], annotation: Any = '') -&gt; PoolRoller</code>  <code>classmethod</code>","text":"<p>Shorthand for <code>cls.from_sources_iterable((cls.from_value(value) for valuein values), annotation=annotation)</code>.</p> <p>See the <code>from_value</code> and <code>from_sources_iterable</code> methods.</p> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef from_values_iterable(\n    cls,\n    values: Iterable[_ValueT],\n    annotation: Any = \"\",\n) -&gt; PoolRoller:\nr\"\"\"\n    Shorthand for ``#!python cls.from_sources_iterable((cls.from_value(value) for value\n    in values), annotation=annotation)``.\n\n    See the [``from_value``][dyce.r.R.from_value] and\n    [``from_sources_iterable``][dyce.r.R.from_sources_iterable] methods.\n    \"\"\"\n    return cls.from_sources_iterable(\n        (cls.from_value(value) for value in values),\n        annotation=annotation,\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.ge","title":"<code>ge(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"<p>Shorthand for <code>self.map(lambda left, right: left.ge(right), other)</code>.</p> <p>See the <code>map</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef ge(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n    Shorthand for ``#!python self.map(lambda left, right: left.ge(right), other)``.\n\n    See the [``map`` method][dyce.r.R.map].\n    \"\"\"\n\n    def _ge(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n        return left_operand.ge(right_operand)\n\n    return self.map(_ge, other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.gt","title":"<code>gt(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"<p>Shorthand for <code>self.map(lambda left, right: left.gt(right), other)</code>.</p> <p>See the <code>map</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef gt(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n    Shorthand for ``#!python self.map(lambda left, right: left.gt(right), other)``.\n\n    See the [``map`` method][dyce.r.R.map].\n    \"\"\"\n\n    def _gt(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n        return left_operand.gt(right_operand)\n\n    return self.map(_gt, other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.is_even","title":"<code>is_even() -&gt; UnarySumOpRoller</code>","text":"<p>Shorthand for: <code>self.umap(lambda operand: operand.is_even())</code>.</p> <p>See the <code>umap</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef is_even(self) -&gt; UnarySumOpRoller:\nr\"\"\"\n    Shorthand for: ``#!python self.umap(lambda operand: operand.is_even())``.\n\n    See the [``umap`` method][dyce.r.R.umap].\n    \"\"\"\n\n    def _is_even(operand: RollOutcome) -&gt; RollOutcome:\n        return operand.is_even()\n\n    return self.umap(_is_even)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.is_odd","title":"<code>is_odd() -&gt; UnarySumOpRoller</code>","text":"<p>Shorthand for: <code>self.umap(lambda operand: operand.is_odd())</code>.</p> <p>See the <code>umap</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef is_odd(self) -&gt; UnarySumOpRoller:\nr\"\"\"\n    Shorthand for: ``#!python self.umap(lambda operand: operand.is_odd())``.\n\n    See the [``umap`` method][dyce.r.R.umap].\n    \"\"\"\n\n    def _is_odd(operand: RollOutcome) -&gt; RollOutcome:\n        return operand.is_odd()\n\n    return self.umap(_is_odd)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.le","title":"<code>le(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"<p>Shorthand for <code>self.map(lambda left, right: left.le(right), other)</code>.</p> <p>See the <code>map</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef le(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n    Shorthand for ``#!python self.map(lambda left, right: left.le(right), other)``.\n\n    See the [``map`` method][dyce.r.R.map].\n    \"\"\"\n\n    def _le(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n        return left_operand.le(right_operand)\n\n    return self.map(_le, other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.lt","title":"<code>lt(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"<p>Shorthand for <code>self.map(lambda left, right: left.lt(right), other)</code>.</p> <p>See the <code>map</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef lt(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n    Shorthand for ``#!python self.map(lambda left, right: left.lt(right), other)``.\n\n    See the [``map`` method][dyce.r.R.map].\n    \"\"\"\n\n    def _lt(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n        return left_operand.lt(right_operand)\n\n    return self.map(_lt, other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.map","title":"<code>map(bin_op: _RollOutcomeBinaryOperatorT, right_operand: _ROperandT, annotation: Any = '') -&gt; BinarySumOpRoller</code>","text":"<p>Creates and returns a <code>BinarySumOpRoller</code> for applying bin_op to this roller and right_operand as its sources. Shorthands exist for many arithmetic operators and comparators.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; r_bin_op = R.from_value(H(6)).map(operator.__pow__, 2) ; r_bin_op\nBinarySumOpRoller(\n  bin_op=&lt;built-in function pow&gt;,\n  left_source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n  right_source=ValueRoller(value=2, annotation=''),\n  annotation='',\n)\n&gt;&gt;&gt; r_bin_op == R.from_value(H(6)) ** 2\nTrue\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef map(\n    self,\n    bin_op: _RollOutcomeBinaryOperatorT,\n    right_operand: _ROperandT,\n    annotation: Any = \"\",\n) -&gt; BinarySumOpRoller:\nr\"\"\"\n    Creates and returns a [``BinarySumOpRoller``][dyce.r.BinarySumOpRoller] for applying\n    *bin_op* to this roller and *right_operand* as its sources. Shorthands exist for\n    many arithmetic operators and comparators.\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; r_bin_op = R.from_value(H(6)).map(operator.__pow__, 2) ; r_bin_op\n    BinarySumOpRoller(\n      bin_op=&lt;built-in function pow&gt;,\n      left_source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n      right_source=ValueRoller(value=2, annotation=''),\n      annotation='',\n    )\n    &gt;&gt;&gt; r_bin_op == R.from_value(H(6)) ** 2\n    True\n\n    ```\n    \"\"\"\n    if isinstance(right_operand, RealLike):\n        right_operand = ValueRoller(right_operand)\n\n    if isinstance(right_operand, (R, RollOutcome)):\n        return BinarySumOpRoller(bin_op, self, right_operand, annotation=annotation)\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.ne","title":"<code>ne(other: _ROperandT) -&gt; BinarySumOpRoller</code>","text":"<p>Shorthand for <code>self.map(lambda left, right: left.ne(right), other)</code>.</p> <p>See the <code>map</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef ne(self, other: _ROperandT) -&gt; BinarySumOpRoller:\nr\"\"\"\n    Shorthand for ``#!python self.map(lambda left, right: left.ne(right), other)``.\n\n    See the [``map`` method][dyce.r.R.map].\n    \"\"\"\n\n    def _ne(left_operand: RollOutcome, right_operand: RollOutcome) -&gt; RollOutcome:\n        return left_operand.ne(right_operand)\n\n    return self.map(_ne, other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.rmap","title":"<code>rmap(left_operand: Union[RealLike, 'RollOutcome'], bin_op: _RollOutcomeBinaryOperatorT, annotation: Any = '') -&gt; BinarySumOpRoller</code>","text":"<p>Analogous to the <code>map</code> method, but where the caller supplies left_operand.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; r_bin_op = R.from_value(H(6)).rmap(2, operator.__pow__) ; r_bin_op\nBinarySumOpRoller(\n  bin_op=&lt;built-in function pow&gt;,\n  left_source=ValueRoller(value=2, annotation=''),\n  right_source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n  annotation='',\n)\n&gt;&gt;&gt; r_bin_op == 2 ** R.from_value(H(6))\nTrue\n</code></pre> <p>Note</p> <p>The positions of left_operand and bin_op are different from <code>map</code> method. This is intentional and serves as a reminder of operand ordering.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef rmap(\n    self,\n    # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n    left_operand: Union[RealLike, \"RollOutcome\"],\n    bin_op: _RollOutcomeBinaryOperatorT,\n    annotation: Any = \"\",\n) -&gt; BinarySumOpRoller:\nr\"\"\"\n    Analogous to the [``map`` method][dyce.r.R.map], but where the caller supplies\n    *left_operand*.\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; r_bin_op = R.from_value(H(6)).rmap(2, operator.__pow__) ; r_bin_op\n    BinarySumOpRoller(\n      bin_op=&lt;built-in function pow&gt;,\n      left_source=ValueRoller(value=2, annotation=''),\n      right_source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n      annotation='',\n    )\n    &gt;&gt;&gt; r_bin_op == 2 ** R.from_value(H(6))\n    True\n\n    ```\n\n    !!! note\n\n        The positions of *left_operand* and *bin_op* are different from\n        [``map`` method][dyce.r.R.map]. This is intentional and serves as a reminder\n        of operand ordering.\n    \"\"\"\n    if isinstance(left_operand, RealLike):\n        return BinarySumOpRoller(\n            bin_op, ValueRoller(left_operand), self, annotation=annotation\n        )\n    elif isinstance(left_operand, RollOutcome):\n        return BinarySumOpRoller(bin_op, left_operand, self, annotation=annotation)\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.roll","title":"<code>roll() -&gt; Roll</code>  <code>abstractmethod</code>","text":"<p>Sub-classes should implement this method to return a new <code>Roll</code> object taking into account any sources.</p> <p>Note</p> <p>Implementors guarantee that all <code>RollOutcome</code>s in the returned <code>Roll</code> must be associated with a roll, including all roll outcomes\u2019 <code>sources</code>.</p> <p>Tip</p> <p>Show that roll outcomes from source rolls are excluded by creating a new roll outcome with a value of <code>None</code> with the excluded roll outcome as its source. The <code>RollOutcome.euthanize</code> convenience method is provided for this purpose.</p> <p>See the section on \u201cDropping dice from prior rolls \u2026\u201d as well as the note in <code>Roll.__init__</code> for additional color.</p> <pre><code>&gt;&gt;&gt; from itertools import chain\n&gt;&gt;&gt; class AntonChigurhRoller(R):\n...   h_coin_toss = H((0, 1))\n...   def roll(self) -&gt; Roll:\n...     source_rolls = list(self.source_rolls())\n...     def _roll_outcomes_gen():\n...       for roll_outcome in chain.from_iterable(source_rolls):\n...         if roll_outcome.value is None:\n...           # Omit those already deceased\n...           continue\n...         elif self.h_coin_toss.roll():\n...           # This one lives. Wrap the old outcome in a new one with the same value.\n...           yield roll_outcome\n...         else:\n...           # This one dies here. Wrap the old outcome in a new one with a value of None.\n...           yield roll_outcome.euthanize()\n...     return Roll(self, roll_outcomes=_roll_outcomes_gen(), source_rolls=source_rolls)\n&gt;&gt;&gt; ac_r = AntonChigurhRoller(sources=(R.from_value(1), R.from_value(2), R.from_value(3)))\n&gt;&gt;&gt; ac_r.roll()\nRoll(\n  r=AntonChigurhRoller(\n    sources=(\n      ValueRoller(value=1, annotation=''),\n      ValueRoller(value=2, annotation=''),\n      ValueRoller(value=3, annotation=''),\n    ),\n    annotation='',\n  ),\n  roll_outcomes=(\n    RollOutcome(\n      value=None,\n      sources=(\n        RollOutcome(\n          value=1,\n          sources=(),\n        ),\n      ),\n    ),\n    RollOutcome(\n      value=2,\n      sources=(),\n    ),\n    RollOutcome(\n      value=3,\n      sources=(),\n    ),\n  ),\n  source_rolls=(\n    Roll(\n      r=ValueRoller(value=1, annotation=''),\n      roll_outcomes=(\n        RollOutcome(\n          value=1,\n          sources=(),\n        ),\n      ),\n      source_rolls=(),\n    ),\n    Roll(\n      r=ValueRoller(value=2, annotation=''),\n      roll_outcomes=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n      ),\n      source_rolls=(),\n    ),\n    Roll(\n      r=ValueRoller(value=3, annotation=''),\n      roll_outcomes=(\n        RollOutcome(\n          value=3,\n          sources=(),\n        ),\n      ),\n      source_rolls=(),\n    ),\n  ),\n)\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@abstractmethod\ndef roll(self) -&gt; Roll:\nr\"\"\"\n    Sub-classes should implement this method to return a new\n    [``Roll`` object][dyce.r.Roll] taking into account any\n    [sources][dyce.r.R.sources].\n\n    !!! note\n\n        Implementors guarantee that all [``RollOutcome``][dyce.r.RollOutcome]s in\n        the returned [``Roll``][dyce.r.Roll] *must* be associated with a roll,\n        *including all roll outcomes\u2019 [``sources``][dyce.r.RollOutcome.sources]*.\n\n    &lt;!-- BEGIN MONKEY PATCH --\n    For deterministic outcomes.\n\n    &gt;&gt;&gt; import random\n    &gt;&gt;&gt; from dyce import rng\n    &gt;&gt;&gt; rng.RNG = random.Random(1633403927)\n\n      -- END MONKEY PATCH --&gt;\n\n    !!! tip\n\n        Show that roll outcomes from source rolls are excluded by creating a new\n        roll outcome with a value of ``#!python None`` with the excluded roll\n        outcome as its source. The\n        [``RollOutcome.euthanize``][dyce.r.RollOutcome.euthanize] convenience method\n        is provided for this purpose.\n\n        See the section on \u201c[Dropping dice from prior rolls\n        \u2026](rollin.md#dropping-dice-from-prior-rolls-keeping-the-best-three-of-3d6-and-1d8)\u201d\n        as well as the note in [``Roll.__init__``][dyce.r.Roll.__init__] for\n        additional color.\n\n        ``` python\n        &gt;&gt;&gt; from itertools import chain\n        &gt;&gt;&gt; class AntonChigurhRoller(R):\n        ...   h_coin_toss = H((0, 1))\n        ...   def roll(self) -&gt; Roll:\n        ...     source_rolls = list(self.source_rolls())\n        ...     def _roll_outcomes_gen():\n        ...       for roll_outcome in chain.from_iterable(source_rolls):\n        ...         if roll_outcome.value is None:\n        ...           # Omit those already deceased\n        ...           continue\n        ...         elif self.h_coin_toss.roll():\n        ...           # This one lives. Wrap the old outcome in a new one with the same value.\n        ...           yield roll_outcome\n        ...         else:\n        ...           # This one dies here. Wrap the old outcome in a new one with a value of None.\n        ...           yield roll_outcome.euthanize()\n        ...     return Roll(self, roll_outcomes=_roll_outcomes_gen(), source_rolls=source_rolls)\n        &gt;&gt;&gt; ac_r = AntonChigurhRoller(sources=(R.from_value(1), R.from_value(2), R.from_value(3)))\n        &gt;&gt;&gt; ac_r.roll()\n        Roll(\n          r=AntonChigurhRoller(\n            sources=(\n              ValueRoller(value=1, annotation=''),\n              ValueRoller(value=2, annotation=''),\n              ValueRoller(value=3, annotation=''),\n            ),\n            annotation='',\n          ),\n          roll_outcomes=(\n            RollOutcome(\n              value=None,\n              sources=(\n                RollOutcome(\n                  value=1,\n                  sources=(),\n                ),\n              ),\n            ),\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n            RollOutcome(\n              value=3,\n              sources=(),\n            ),\n          ),\n          source_rolls=(\n            Roll(\n              r=ValueRoller(value=1, annotation=''),\n              roll_outcomes=(\n                RollOutcome(\n                  value=1,\n                  sources=(),\n                ),\n              ),\n              source_rolls=(),\n            ),\n            Roll(\n              r=ValueRoller(value=2, annotation=''),\n              roll_outcomes=(\n                RollOutcome(\n                  value=2,\n                  sources=(),\n                ),\n              ),\n              source_rolls=(),\n            ),\n            Roll(\n              r=ValueRoller(value=3, annotation=''),\n              roll_outcomes=(\n                RollOutcome(\n                  value=3,\n                  sources=(),\n                ),\n              ),\n              source_rolls=(),\n            ),\n          ),\n        )\n\n        ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.select","title":"<code>select(*which: _GetItemT, annotation: Any = '') -&gt; SelectionRoller</code>","text":"<p>Shorthand for <code>self.select_iterable(which, annotation=annotation)</code>.</p> <p>See the <code>select_iterable</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef select(\n    self,\n    *which: _GetItemT,\n    annotation: Any = \"\",\n) -&gt; SelectionRoller:\nr\"\"\"\n    Shorthand for ``#!python self.select_iterable(which, annotation=annotation)``.\n\n    See the [``select_iterable`` method][dyce.r.R.select_iterable].\n    \"\"\"\n    return self.select_iterable(which, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.select_from_sources","title":"<code>select_from_sources(which: Iterable[_GetItemT], *sources: _SourceT, annotation: Any = '') -&gt; SelectionRoller</code>  <code>classmethod</code>","text":"<p>Shorthand for <code>cls.select_from_sources_iterable(which, sources,annotation=annotation)</code>.</p> <p>See the <code>select_from_sources_iterable</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef select_from_sources(\n    cls,\n    which: Iterable[_GetItemT],\n    *sources: _SourceT,\n    annotation: Any = \"\",\n) -&gt; SelectionRoller:\nr\"\"\"\n    Shorthand for ``#!python cls.select_from_sources_iterable(which, sources,\n    annotation=annotation)``.\n\n    See the [``select_from_sources_iterable``\n    method][dyce.r.R.select_from_sources_iterable].\n    \"\"\"\n    return cls.select_from_sources_iterable(which, sources, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.select_from_sources_iterable","title":"<code>select_from_sources_iterable(which: Iterable[_GetItemT], sources: Iterable[_SourceT], annotation: Any = '') -&gt; SelectionRoller</code>  <code>classmethod</code>","text":"<p>Creates and returns a <code>SelectionRoller</code> for applying selection which to sorted outcomes from sources.</p> <pre><code>&gt;&gt;&gt; r_select = R.select_from_sources_iterable(\n...   (0, -1, slice(3, 6), slice(6, 3, -1), -1, 0),\n...   (R.from_value(i) for i in (5, 4, 6, 3, 7, 2, 8, 1, 9, 0)),\n... ) ; r_select\nSelectionRoller(\n  which=(0, -1, slice(3, 6, None), slice(6, 3, -1), -1, 0),\n  sources=(\n    ValueRoller(value=5, annotation=''),\n    ValueRoller(value=4, annotation=''),\n    ...,\n    ValueRoller(value=9, annotation=''),\n    ValueRoller(value=0, annotation=''),\n  ),\n  annotation='',\n)\n&gt;&gt;&gt; tuple(r_select.roll().outcomes())\n(0, 9, 3, 4, 5, 6, 5, 4, 9, 0)\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef select_from_sources_iterable(\n    cls,\n    which: Iterable[_GetItemT],\n    sources: Iterable[_SourceT],\n    annotation: Any = \"\",\n) -&gt; SelectionRoller:\nr\"\"\"\n    Creates and returns a [``SelectionRoller``][dyce.r.SelectionRoller] for applying\n    selection *which* to sorted outcomes from *sources*.\n\n    ``` python\n    &gt;&gt;&gt; r_select = R.select_from_sources_iterable(\n    ...   (0, -1, slice(3, 6), slice(6, 3, -1), -1, 0),\n    ...   (R.from_value(i) for i in (5, 4, 6, 3, 7, 2, 8, 1, 9, 0)),\n    ... ) ; r_select\n    SelectionRoller(\n      which=(0, -1, slice(3, 6, None), slice(6, 3, -1), -1, 0),\n      sources=(\n        ValueRoller(value=5, annotation=''),\n        ValueRoller(value=4, annotation=''),\n        ...,\n        ValueRoller(value=9, annotation=''),\n        ValueRoller(value=0, annotation=''),\n      ),\n      annotation='',\n    )\n    &gt;&gt;&gt; tuple(r_select.roll().outcomes())\n    (0, 9, 3, 4, 5, 6, 5, 4, 9, 0)\n\n    ```\n    \"\"\"\n    return SelectionRoller(which, sources, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.select_from_values","title":"<code>select_from_values(which: Iterable[_GetItemT], *values: _ValueT, annotation: Any = '') -&gt; SelectionRoller</code>  <code>classmethod</code>","text":"<p>Shorthand for <code>cls.select_from_values_iterable(which, values,annotation=annotation)</code>.</p> <p>See the <code>select_from_values_iterable</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef select_from_values(\n    cls,\n    which: Iterable[_GetItemT],\n    *values: _ValueT,\n    annotation: Any = \"\",\n) -&gt; SelectionRoller:\nr\"\"\"\n    Shorthand for ``#!python cls.select_from_values_iterable(which, values,\n    annotation=annotation)``.\n\n    See the\n    [``select_from_values_iterable`` method][dyce.r.R.select_from_values_iterable].\n    \"\"\"\n    return cls.select_from_values_iterable(which, values, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.select_from_values_iterable","title":"<code>select_from_values_iterable(which: Iterable[_GetItemT], values: Iterable[_ValueT], annotation: Any = '') -&gt; SelectionRoller</code>  <code>classmethod</code>","text":"<p>Shorthand for <code>cls.select_from_sources_iterable((cls.from_value(value) forvalue in values), annotation=annotation)</code>.</p> <p>See the <code>from_value</code> and <code>select_from_sources_iterable</code> methods.</p> Source code in <code>dyce/r.py</code> <pre><code>@classmethod\n@beartype\ndef select_from_values_iterable(\n    cls,\n    which: Iterable[_GetItemT],\n    values: Iterable[_ValueT],\n    annotation: Any = \"\",\n) -&gt; SelectionRoller:\nr\"\"\"\n    Shorthand for ``#!python cls.select_from_sources_iterable((cls.from_value(value) for\n    value in values), annotation=annotation)``.\n\n    See the [``from_value``][dyce.r.R.from_value] and\n    [``select_from_sources_iterable``][dyce.r.R.select_from_sources_iterable]\n    methods.\n    \"\"\"\n    return cls.select_from_sources_iterable(\n        which,\n        (cls.from_value(value) for value in values),\n        annotation=annotation,\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.select_iterable","title":"<code>select_iterable(which: Iterable[_GetItemT], annotation: Any = '') -&gt; SelectionRoller</code>","text":"<p>Shorthand for <code>type(self).select_from_sources(which, self,annotation=annotation)</code>.</p> <p>See the <code>select_from_sources</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef select_iterable(\n    self,\n    which: Iterable[_GetItemT],\n    annotation: Any = \"\",\n) -&gt; SelectionRoller:\nr\"\"\"\n    Shorthand for ``#!python type(self).select_from_sources(which, self,\n    annotation=annotation)``.\n\n    See the [``select_from_sources`` method][dyce.r.R.select_from_sources].\n    \"\"\"\n    return type(self).select_from_sources(which, self, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.source_rolls","title":"<code>source_rolls() -&gt; Iterator['Roll']</code>","text":"<p>Generates new rolls from all <code>sources</code>.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef source_rolls(self) -&gt; Iterator[\"Roll\"]:\nr\"\"\"\n    Generates new rolls from all [``sources``][dyce.r.R.sources].\n    \"\"\"\n    for source in self.sources:\n        yield source.roll()\n</code></pre>"},{"location":"dyce.r/#dyce.r.R.umap","title":"<code>umap(un_op: _RollOutcomeUnaryOperatorT, annotation: Any = '') -&gt; UnarySumOpRoller</code>","text":"<p>Creates and returns a <code>UnarySumOpRoller</code> roller for applying un_op to this roller as its source.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; r_un_op = R.from_value(H(6)).umap(operator.__neg__) ; r_un_op\nUnarySumOpRoller(\n  un_op=&lt;built-in function neg&gt;,\n  source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n  annotation='',\n)\n&gt;&gt;&gt; r_un_op == -R.from_value(H(6))\nTrue\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef umap(\n    self,\n    un_op: _RollOutcomeUnaryOperatorT,\n    annotation: Any = \"\",\n) -&gt; UnarySumOpRoller:\nr\"\"\"\n    Creates and returns a [``UnarySumOpRoller``][dyce.r.UnarySumOpRoller] roller for\n    applying *un_op* to this roller as its source.\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; r_un_op = R.from_value(H(6)).umap(operator.__neg__) ; r_un_op\n    UnarySumOpRoller(\n      un_op=&lt;built-in function neg&gt;,\n      source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n      annotation='',\n    )\n    &gt;&gt;&gt; r_un_op == -R.from_value(H(6))\n    True\n\n    ```\n    \"\"\"\n    return UnarySumOpRoller(un_op, self, annotation=annotation)\n</code></pre>"},{"location":"dyce.r/#dyce.r.ValueRoller","title":"<code>ValueRoller</code>","text":"<p>             Bases: <code>R</code></p> <p>A roller whose roll outcomes are derived from scalars, <code>H</code> objects, <code>P</code> objects, <code>RollOutcome</code> objects, or even <code>Roll</code> objects, instead of other source rollers.</p> Source code in <code>dyce/r.py</code> <pre><code>class ValueRoller(R):\nr\"\"\"\n    A [roller][dyce.r.R] whose roll outcomes are derived from scalars,\n    [``H`` objects][dyce.h.H], [``P`` objects][dyce.p.P],\n    [``RollOutcome`` objects][dyce.r.RollOutcome], or even\n    [``Roll`` objects][dyce.r.Roll], instead of other source rollers.\n    \"\"\"\n    __slots__: Any = (\"_value\",)\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @beartype\n    def __init__(\n        self,\n        value: _ValueT,\n        annotation: Any = \"\",\n        **kw,\n    ):\n        r\"Initializer.\"\n        super().__init__(sources=(), annotation=annotation, **kw)\n\n        if isinstance(value, P) and not value.is_homogeneous():\n            warnings.warn(\n                f\"using a heterogeneous pool ({value}) is not recommended where traceability is important\",\n                stacklevel=2,\n            )\n\n        self._value = value\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"{type(self).__name__}(value={self.value!r}, annotation={self.annotation!r})\"\n\n    @beartype\n    def roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n        if isinstance(self.value, P):\n            return Roll(\n                self,\n                roll_outcomes=(RollOutcome(outcome) for outcome in self.value.roll()),\n            )\n        elif isinstance(self.value, H):\n            return Roll(self, roll_outcomes=(RollOutcome(self.value.roll()),))\n        elif isinstance(self.value, RealLike):\n            return Roll(self, roll_outcomes=(RollOutcome(self.value),))\n        else:\n            assert False, f\"unrecognized value type {self.value!r}\"\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def value(self) -&gt; _ValueT:\nr\"\"\"\n        The value to be emitted by this roller via its\n        [``ValueRoller.roll`` method][dyce.r.ValueRoller.roll].\n        \"\"\"\n        return self._value\n</code></pre>"},{"location":"dyce.r/#dyce.r.ValueRoller.__slots__","title":"<code>__slots__: Any = ('_value')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.ValueRoller.value","title":"<code>value: _ValueT</code>  <code>property</code>","text":"<p>The value to be emitted by this roller via its <code>ValueRoller.roll</code> method.</p>"},{"location":"dyce.r/#dyce.r.ValueRoller.__init__","title":"<code>__init__(value: _ValueT, annotation: Any = '', **kw: Any)</code>","text":"<p>Initializer.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    value: _ValueT,\n    annotation: Any = \"\",\n    **kw,\n):\n    r\"Initializer.\"\n    super().__init__(sources=(), annotation=annotation, **kw)\n\n    if isinstance(value, P) and not value.is_homogeneous():\n        warnings.warn(\n            f\"using a heterogeneous pool ({value}) is not recommended where traceability is important\",\n            stacklevel=2,\n        )\n\n    self._value = value\n</code></pre>"},{"location":"dyce.r/#dyce.r.ValueRoller.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __repr__(self) -&gt; str:\n    return f\"{type(self).__name__}(value={self.value!r}, annotation={self.annotation!r})\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.ValueRoller.roll","title":"<code>roll() -&gt; Roll</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n    if isinstance(self.value, P):\n        return Roll(\n            self,\n            roll_outcomes=(RollOutcome(outcome) for outcome in self.value.roll()),\n        )\n    elif isinstance(self.value, H):\n        return Roll(self, roll_outcomes=(RollOutcome(self.value.roll()),))\n    elif isinstance(self.value, RealLike):\n        return Roll(self, roll_outcomes=(RollOutcome(self.value),))\n    else:\n        assert False, f\"unrecognized value type {self.value!r}\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.PoolRoller","title":"<code>PoolRoller</code>","text":"<p>             Bases: <code>R</code></p> <p>A roller for rolling flattened \u201cpools\u201d from all sources.</p> <pre><code>&gt;&gt;&gt; PoolRoller((\n...   PoolRoller((\n...     ValueRoller(11),\n...     ValueRoller(12),\n...   )),\n...   PoolRoller((\n...     PoolRoller((\n...       ValueRoller(211),\n...       ValueRoller(212),\n...     )),\n...     PoolRoller((\n...       ValueRoller(221),\n...       ValueRoller(222),\n...     )),\n...   )),\n...   ValueRoller(3),\n... )).roll()\nRoll(\n  r=...,\n  roll_outcomes=(\n    RollOutcome(\n      value=11,\n      sources=...,\n    ),\n    RollOutcome(\n      value=12,\n      sources=...,\n    ),\n    RollOutcome(\n      value=211,\n      sources=...,\n    ),\n    RollOutcome(\n      value=212,\n      sources=...,\n    ),\n    RollOutcome(\n      value=221,\n      sources=...,\n    ),\n    RollOutcome(\n      value=222,\n      sources=...,\n    ),\n    RollOutcome(\n      value=3,\n      sources=...,\n    ),\n  ),\n  source_rolls=...,\n)\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>class PoolRoller(R):\nr\"\"\"\n    A [roller][dyce.r.R] for rolling flattened \u201cpools\u201d from all *sources*.\n\n    ``` python\n    &gt;&gt;&gt; PoolRoller((\n    ...   PoolRoller((\n    ...     ValueRoller(11),\n    ...     ValueRoller(12),\n    ...   )),\n    ...   PoolRoller((\n    ...     PoolRoller((\n    ...       ValueRoller(211),\n    ...       ValueRoller(212),\n    ...     )),\n    ...     PoolRoller((\n    ...       ValueRoller(221),\n    ...       ValueRoller(222),\n    ...     )),\n    ...   )),\n    ...   ValueRoller(3),\n    ... )).roll()\n    Roll(\n      r=...,\n      roll_outcomes=(\n        RollOutcome(\n          value=11,\n          sources=...,\n        ),\n        RollOutcome(\n          value=12,\n          sources=...,\n        ),\n        RollOutcome(\n          value=211,\n          sources=...,\n        ),\n        RollOutcome(\n          value=212,\n          sources=...,\n        ),\n        RollOutcome(\n          value=221,\n          sources=...,\n        ),\n        RollOutcome(\n          value=222,\n          sources=...,\n        ),\n        RollOutcome(\n          value=3,\n          sources=...,\n        ),\n      ),\n      source_rolls=...,\n    )\n\n    ```\n    \"\"\"\n    __slots__: Any = ()\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n        source_rolls = list(self.source_rolls())\n\n        return Roll(\n            self,\n            roll_outcomes=(\n                roll_outcome\n                for roll_outcome in chain.from_iterable(source_rolls)\n                if roll_outcome.value is not None\n            ),\n            source_rolls=source_rolls,\n        )\n</code></pre>"},{"location":"dyce.r/#dyce.r.PoolRoller.__slots__","title":"<code>__slots__: Any = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.PoolRoller.roll","title":"<code>roll() -&gt; Roll</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n    source_rolls = list(self.source_rolls())\n\n    return Roll(\n        self,\n        roll_outcomes=(\n            roll_outcome\n            for roll_outcome in chain.from_iterable(source_rolls)\n            if roll_outcome.value is not None\n        ),\n        source_rolls=source_rolls,\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.RepeatRoller","title":"<code>RepeatRoller</code>","text":"<p>             Bases: <code>R</code></p> <p>A roller to implement the <code>__matmul__</code> operator. It is akin to a homogeneous <code>PoolRoller</code> containing n identical sources.</p> <pre><code>&gt;&gt;&gt; d20 = H(20)\n&gt;&gt;&gt; r_d20 = R.from_value(d20)\n&gt;&gt;&gt; r_d20_100 = 100@r_d20 ; r_d20_100\nRepeatRoller(\n  n=100,\n  source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1, 19: 1, 20: 1}), annotation=''),\n  annotation='',\n)\n&gt;&gt;&gt; all(outcome in d20 for outcome in r_d20_100.roll().outcomes())\nTrue\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>class RepeatRoller(R):\nr\"\"\"\n    A [roller][dyce.r.R] to implement the ``#!python __matmul__`` operator. It is akin\n    to a homogeneous [``PoolRoller``][dyce.r.PoolRoller] containing *n* identical\n    *source*s.\n\n    ``` python\n    &gt;&gt;&gt; d20 = H(20)\n    &gt;&gt;&gt; r_d20 = R.from_value(d20)\n    &gt;&gt;&gt; r_d20_100 = 100@r_d20 ; r_d20_100\n    RepeatRoller(\n      n=100,\n      source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1, 19: 1, 20: 1}), annotation=''),\n      annotation='',\n    )\n    &gt;&gt;&gt; all(outcome in d20 for outcome in r_d20_100.roll().outcomes())\n    True\n\n    ```\n    \"\"\"\n    __slots__: Any = (\"_n\",)\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @beartype\n    def __init__(\n        self,\n        n: SupportsInt,\n        source: _SourceT,\n        annotation: Any = \"\",\n        **kw,\n    ):\n        r\"Initializer.\"\n        super().__init__(sources=(source,), annotation=annotation, **kw)\n        self._n = as_int(n)\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        (source,) = self.sources\n\n        return f\"\"\"{type(self).__name__}(\n  n={self.n!r},\n  source={indent(repr(source), \"  \").strip()},\n  annotation={self.annotation!r},\n)\"\"\"\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        return super().__eq__(other) and self.n == other.n\n\n    @beartype\n    def roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n        source_rolls: list[Roll] = []\n\n        for _ in range(self.n):\n            source_rolls.extend(self.source_rolls())\n\n        return Roll(\n            self,\n            roll_outcomes=(\n                roll_outcome\n                for roll_outcome in chain.from_iterable(source_rolls)\n                if roll_outcome.value is not None\n            ),\n            source_rolls=source_rolls,\n        )\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def n(self) -&gt; int:\nr\"\"\"\n        The number of times to \u201crepeat\u201d the roller\u2019s sole source.\n        \"\"\"\n        return self._n\n</code></pre>"},{"location":"dyce.r/#dyce.r.RepeatRoller.__slots__","title":"<code>__slots__: Any = ('_n')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.RepeatRoller.n","title":"<code>n: int</code>  <code>property</code>","text":"<p>The number of times to \u201crepeat\u201d the roller\u2019s sole source.</p>"},{"location":"dyce.r/#dyce.r.RepeatRoller.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    return super().__eq__(other) and self.n == other.n\n</code></pre>"},{"location":"dyce.r/#dyce.r.RepeatRoller.__init__","title":"<code>__init__(n: SupportsInt, source: _SourceT, annotation: Any = '', **kw: Any)</code>","text":"<p>Initializer.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    n: SupportsInt,\n    source: _SourceT,\n    annotation: Any = \"\",\n    **kw,\n):\n    r\"Initializer.\"\n    super().__init__(sources=(source,), annotation=annotation, **kw)\n    self._n = as_int(n)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RepeatRoller.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>    @beartype\n    def __repr__(self) -&gt; str:\n        (source,) = self.sources\n\n        return f\"\"\"{type(self).__name__}(\n  n={self.n!r},\n  source={indent(repr(source), \"  \").strip()},\n  annotation={self.annotation!r},\n)\"\"\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.RepeatRoller.roll","title":"<code>roll() -&gt; Roll</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n    source_rolls: list[Roll] = []\n\n    for _ in range(self.n):\n        source_rolls.extend(self.source_rolls())\n\n    return Roll(\n        self,\n        roll_outcomes=(\n            roll_outcome\n            for roll_outcome in chain.from_iterable(source_rolls)\n            if roll_outcome.value is not None\n        ),\n        source_rolls=source_rolls,\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.BasicOpRoller","title":"<code>BasicOpRoller</code>","text":"<p>             Bases: <code>R</code></p> <p>A roller for applying op to some variation of outcomes from sources. Any <code>RollOutcome</code>s returned by op are used directly in the creation of a new <code>Roll</code>.</p> Source code in <code>dyce/r.py</code> <pre><code>class BasicOpRoller(R):\nr\"\"\"\n    A [roller][dyce.r.R] for applying *op* to some variation of outcomes from *sources*.\n    Any [``RollOutcome``][dyce.r.RollOutcome]s returned by *op* are used directly in the\n    creation of a new [``Roll``][dyce.r.Roll].\n    \"\"\"\n    __slots__: Any = (\"_op\",)\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @beartype\n    def __init__(\n        self,\n        op: BasicOperatorT,\n        sources: Iterable[_SourceT],\n        annotation: Any = \"\",\n        **kw,\n    ):\n        r\"Initializer.\"\n        super().__init__(sources=sources, annotation=annotation, **kw)\n        self._op = op\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  op={self.op!r},\n  sources=({_seq_repr(self.sources)}),\n  annotation={self.annotation!r},\n)\"\"\"\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        return super().__eq__(other) and (_callable_cmp(self.op, other.op))\n\n    @beartype\n    def roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n        source_rolls = list(self.source_rolls())\n        res = self.op(\n            self,\n            (\n                roll_outcome\n                for roll_outcome in chain.from_iterable(source_rolls)\n                if roll_outcome.value is not None\n            ),\n        )\n\n        if isinstance(res, RollOutcome):\n            roll_outcomes = (res,)\n        else:\n            roll_outcomes = res  # type: ignore [assignment]  # TODO(posita): WTF?\n\n        return Roll(self, roll_outcomes=roll_outcomes, source_rolls=source_rolls)\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def op(self) -&gt; BasicOperatorT:\nr\"\"\"\n        The operator this roller applies to its sources.\n        \"\"\"\n        return self._op\n</code></pre>"},{"location":"dyce.r/#dyce.r.BasicOpRoller.__slots__","title":"<code>__slots__: Any = ('_op')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.BasicOpRoller.op","title":"<code>op: BasicOperatorT</code>  <code>property</code>","text":"<p>The operator this roller applies to its sources.</p>"},{"location":"dyce.r/#dyce.r.BasicOpRoller.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    return super().__eq__(other) and (_callable_cmp(self.op, other.op))\n</code></pre>"},{"location":"dyce.r/#dyce.r.BasicOpRoller.__init__","title":"<code>__init__(op: BasicOperatorT, sources: Iterable[_SourceT], annotation: Any = '', **kw: Any)</code>","text":"<p>Initializer.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    op: BasicOperatorT,\n    sources: Iterable[_SourceT],\n    annotation: Any = \"\",\n    **kw,\n):\n    r\"Initializer.\"\n    super().__init__(sources=sources, annotation=annotation, **kw)\n    self._op = op\n</code></pre>"},{"location":"dyce.r/#dyce.r.BasicOpRoller.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  op={self.op!r},\n  sources=({_seq_repr(self.sources)}),\n  annotation={self.annotation!r},\n)\"\"\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.BasicOpRoller.roll","title":"<code>roll() -&gt; Roll</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n    source_rolls = list(self.source_rolls())\n    res = self.op(\n        self,\n        (\n            roll_outcome\n            for roll_outcome in chain.from_iterable(source_rolls)\n            if roll_outcome.value is not None\n        ),\n    )\n\n    if isinstance(res, RollOutcome):\n        roll_outcomes = (res,)\n    else:\n        roll_outcomes = res  # type: ignore [assignment]  # TODO(posita): WTF?\n\n    return Roll(self, roll_outcomes=roll_outcomes, source_rolls=source_rolls)\n</code></pre>"},{"location":"dyce.r/#dyce.r.NarySumOpRoller","title":"<code>NarySumOpRoller</code>","text":"<p>             Bases: <code>BasicOpRoller</code></p> <p>A <code>BasicOpRoller</code> for applying op to the sum of outcomes grouped by each of sources.</p> Source code in <code>dyce/r.py</code> <pre><code>class NarySumOpRoller(BasicOpRoller):\nr\"\"\"\n    A [``BasicOpRoller``][dyce.r.BasicOpRoller] for applying *op* to the sum of outcomes\n    grouped by each of *sources*.\n    \"\"\"\n    __slots__: Any = ()\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n        source_rolls = list(self.source_rolls())\n\n        def _sum_roll_outcomes_by_rolls() -&gt; Iterator[RollOutcome]:\n            for source_roll in source_rolls:\n                if len(source_roll) == 1 and source_roll[0].value is not None:\n                    yield from source_roll\n                else:\n                    yield RollOutcome(sum(source_roll.outcomes()), sources=source_roll)\n\n        res = self.op(self, _sum_roll_outcomes_by_rolls())\n\n        if isinstance(res, RollOutcome):\n            roll_outcomes = (res,)\n        else:\n            roll_outcomes = res  # type: ignore [assignment]  # TODO(posita): WTF?\n\n        return Roll(self, roll_outcomes=roll_outcomes, source_rolls=source_rolls)\n</code></pre>"},{"location":"dyce.r/#dyce.r.NarySumOpRoller.__slots__","title":"<code>__slots__: Any = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.NarySumOpRoller.roll","title":"<code>roll() -&gt; Roll</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n    source_rolls = list(self.source_rolls())\n\n    def _sum_roll_outcomes_by_rolls() -&gt; Iterator[RollOutcome]:\n        for source_roll in source_rolls:\n            if len(source_roll) == 1 and source_roll[0].value is not None:\n                yield from source_roll\n            else:\n                yield RollOutcome(sum(source_roll.outcomes()), sources=source_roll)\n\n    res = self.op(self, _sum_roll_outcomes_by_rolls())\n\n    if isinstance(res, RollOutcome):\n        roll_outcomes = (res,)\n    else:\n        roll_outcomes = res  # type: ignore [assignment]  # TODO(posita): WTF?\n\n    return Roll(self, roll_outcomes=roll_outcomes, source_rolls=source_rolls)\n</code></pre>"},{"location":"dyce.r/#dyce.r.BinarySumOpRoller","title":"<code>BinarySumOpRoller</code>","text":"<p>             Bases: <code>NarySumOpRoller</code></p> <p>An <code>NarySumOpRoller</code> for applying a binary operator bin_op to the sum of all outcomes from its left_source and the sum of all outcomes from its right_source.</p> Source code in <code>dyce/r.py</code> <pre><code>class BinarySumOpRoller(NarySumOpRoller):\nr\"\"\"\n    An [``NarySumOpRoller``][dyce.r.NarySumOpRoller] for applying a binary operator\n    *bin_op* to the sum of all outcomes from its *left_source* and the sum of all\n    outcomes from its *right_source*.\n    \"\"\"\n    __slots__: Any = (\"_bin_op\",)\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @beartype\n    def __init__(\n        self,\n        bin_op: _RollOutcomeBinaryOperatorT,\n        left_source: _SourceT,\n        right_source: _SourceT,\n        annotation: Any = \"\",\n        **kw,\n    ):\n        r\"Initializer.\"\n\n        def _op(\n            r: R,\n            roll_outcomes: Iterable[RollOutcome],\n        ) -&gt; Union[RollOutcome, Iterable[RollOutcome]]:\n            left_operand, right_operand = roll_outcomes\n\n            return bin_op(left_operand, right_operand)\n\n        super().__init__(\n            op=_op, sources=(left_source, right_source), annotation=annotation, **kw\n        )\n        self._bin_op = bin_op\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def bin_op(self) -&gt; _RollOutcomeBinaryOperatorT:\nr\"\"\"\n        The operator this roller applies to its sources.\n        \"\"\"\n        return self._bin_op\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        def _source_repr(source: _SourceT) -&gt; str:\n            return indent(repr(source), \"  \").strip()\n\n        left_source, right_source = self.sources\n\n        return f\"\"\"{type(self).__name__}(\n  bin_op={self.bin_op!r},\n  left_source={_source_repr(left_source)},\n  right_source={_source_repr(right_source)},\n  annotation={self.annotation!r},\n)\"\"\"\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        return super().__eq__(other) and (_callable_cmp(self.bin_op, other.bin_op))\n</code></pre>"},{"location":"dyce.r/#dyce.r.BinarySumOpRoller.__slots__","title":"<code>__slots__: Any = ('_bin_op')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.BinarySumOpRoller.bin_op","title":"<code>bin_op: _RollOutcomeBinaryOperatorT</code>  <code>property</code>","text":"<p>The operator this roller applies to its sources.</p>"},{"location":"dyce.r/#dyce.r.BinarySumOpRoller.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    return super().__eq__(other) and (_callable_cmp(self.bin_op, other.bin_op))\n</code></pre>"},{"location":"dyce.r/#dyce.r.BinarySumOpRoller.__init__","title":"<code>__init__(bin_op: _RollOutcomeBinaryOperatorT, left_source: _SourceT, right_source: _SourceT, annotation: Any = '', **kw: Any)</code>","text":"<p>Initializer.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    bin_op: _RollOutcomeBinaryOperatorT,\n    left_source: _SourceT,\n    right_source: _SourceT,\n    annotation: Any = \"\",\n    **kw,\n):\n    r\"Initializer.\"\n\n    def _op(\n        r: R,\n        roll_outcomes: Iterable[RollOutcome],\n    ) -&gt; Union[RollOutcome, Iterable[RollOutcome]]:\n        left_operand, right_operand = roll_outcomes\n\n        return bin_op(left_operand, right_operand)\n\n    super().__init__(\n        op=_op, sources=(left_source, right_source), annotation=annotation, **kw\n    )\n    self._bin_op = bin_op\n</code></pre>"},{"location":"dyce.r/#dyce.r.BinarySumOpRoller.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>    @beartype\n    def __repr__(self) -&gt; str:\n        def _source_repr(source: _SourceT) -&gt; str:\n            return indent(repr(source), \"  \").strip()\n\n        left_source, right_source = self.sources\n\n        return f\"\"\"{type(self).__name__}(\n  bin_op={self.bin_op!r},\n  left_source={_source_repr(left_source)},\n  right_source={_source_repr(right_source)},\n  annotation={self.annotation!r},\n)\"\"\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.UnarySumOpRoller","title":"<code>UnarySumOpRoller</code>","text":"<p>             Bases: <code>NarySumOpRoller</code></p> <p>An <code>NarySumOpRoller</code> for applying a unary operator un_op to the sum of all outcomes from its sole source.</p> Source code in <code>dyce/r.py</code> <pre><code>class UnarySumOpRoller(NarySumOpRoller):\nr\"\"\"\n    An [``NarySumOpRoller``][dyce.r.NarySumOpRoller] for applying a unary operator\n    *un_op* to the sum of all outcomes from its sole *source*.\n    \"\"\"\n    __slots__: Any = (\"_un_op\",)\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @beartype\n    def __init__(\n        self,\n        un_op: _RollOutcomeUnaryOperatorT,\n        source: _SourceT,\n        annotation: Any = \"\",\n        **kw,\n    ):\n        r\"Initializer.\"\n\n        def _op(\n            r: R,\n            roll_outcomes: Iterable[RollOutcome],\n        ) -&gt; Union[RollOutcome, Iterable[RollOutcome]]:\n            (operand,) = roll_outcomes\n\n            return un_op(operand)\n\n        super().__init__(op=_op, sources=(source,), annotation=annotation, **kw)\n        self._un_op = un_op\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        (source,) = self.sources\n\n        return f\"\"\"{type(self).__name__}(\n  un_op={self.un_op!r},\n  source={indent(repr(source), \"  \").strip()},\n  annotation={self.annotation!r},\n)\"\"\"\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        return super().__eq__(other) and (_callable_cmp(self.un_op, other.un_op))\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def un_op(self) -&gt; _RollOutcomeUnaryOperatorT:\nr\"\"\"\n        The operator this roller applies to its sources.\n        \"\"\"\n        return self._un_op\n</code></pre>"},{"location":"dyce.r/#dyce.r.UnarySumOpRoller.__slots__","title":"<code>__slots__: Any = ('_un_op')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.UnarySumOpRoller.un_op","title":"<code>un_op: _RollOutcomeUnaryOperatorT</code>  <code>property</code>","text":"<p>The operator this roller applies to its sources.</p>"},{"location":"dyce.r/#dyce.r.UnarySumOpRoller.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    return super().__eq__(other) and (_callable_cmp(self.un_op, other.un_op))\n</code></pre>"},{"location":"dyce.r/#dyce.r.UnarySumOpRoller.__init__","title":"<code>__init__(un_op: _RollOutcomeUnaryOperatorT, source: _SourceT, annotation: Any = '', **kw: Any)</code>","text":"<p>Initializer.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    un_op: _RollOutcomeUnaryOperatorT,\n    source: _SourceT,\n    annotation: Any = \"\",\n    **kw,\n):\n    r\"Initializer.\"\n\n    def _op(\n        r: R,\n        roll_outcomes: Iterable[RollOutcome],\n    ) -&gt; Union[RollOutcome, Iterable[RollOutcome]]:\n        (operand,) = roll_outcomes\n\n        return un_op(operand)\n\n    super().__init__(op=_op, sources=(source,), annotation=annotation, **kw)\n    self._un_op = un_op\n</code></pre>"},{"location":"dyce.r/#dyce.r.UnarySumOpRoller.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>    @beartype\n    def __repr__(self) -&gt; str:\n        (source,) = self.sources\n\n        return f\"\"\"{type(self).__name__}(\n  un_op={self.un_op!r},\n  source={indent(repr(source), \"  \").strip()},\n  annotation={self.annotation!r},\n)\"\"\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.SubstitutionRoller","title":"<code>SubstitutionRoller</code>","text":"<p>             Bases: <code>R</code></p> <p>A roller for applying expansion_op to determine when to roll new values up to max_depth times for incorporation via coalesce_mode.</p> <pre><code>&gt;&gt;&gt; from dyce.r import SubstitutionRoller\n&gt;&gt;&gt; r_d6 = R.from_value(H(6))\n&gt;&gt;&gt; r_replace = SubstitutionRoller(\n...   lambda outcome: RollOutcome(0) if outcome.value is not None and outcome.value &lt;= 3 else outcome,\n...   r_d6,\n... )\n&gt;&gt;&gt; (2@r_replace).roll()\nRoll(\n  r=RepeatRoller(\n    n=2,\n    source=SubstitutionRoller(\n      expansion_op=&lt;function &lt;lambda&gt; at ...&gt;,\n      source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n      coalesce_mode=&lt;CoalesceMode.REPLACE: 1&gt;,\n      max_depth=1,\n      annotation='',\n    ),\n    annotation='',\n  ),\n  roll_outcomes=(\n    RollOutcome(\n      value=0,\n      sources=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n      ),\n    ),\n    RollOutcome(\n      value=5,\n      sources=(),\n    ),\n  ),\n  source_rolls=(...),\n)\n</code></pre> <p>See the section on \u201cFiltering and substitution\u201d more examples.</p> Source code in <code>dyce/r.py</code> <pre><code>class SubstitutionRoller(R):\nr\"\"\"\n    A [roller][dyce.r.R] for applying *expansion_op* to determine when to roll new\n    values up to *max_depth* times for incorporation via *coalesce_mode*.\n\n    &lt;!-- BEGIN MONKEY PATCH --\n    For deterministic outcomes.\n\n    &gt;&gt;&gt; import random\n    &gt;&gt;&gt; from dyce import rng\n    &gt;&gt;&gt; rng.RNG = random.Random(1639580307)\n\n      -- END MONKEY PATCH --&gt;\n\n    ``` python\n    &gt;&gt;&gt; from dyce.r import SubstitutionRoller\n    &gt;&gt;&gt; r_d6 = R.from_value(H(6))\n    &gt;&gt;&gt; r_replace = SubstitutionRoller(\n    ...   lambda outcome: RollOutcome(0) if outcome.value is not None and outcome.value &lt;= 3 else outcome,\n    ...   r_d6,\n    ... )\n    &gt;&gt;&gt; (2@r_replace).roll()\n    Roll(\n      r=RepeatRoller(\n        n=2,\n        source=SubstitutionRoller(\n          expansion_op=&lt;function &lt;lambda&gt; at ...&gt;,\n          source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n          coalesce_mode=&lt;CoalesceMode.REPLACE: 1&gt;,\n          max_depth=1,\n          annotation='',\n        ),\n        annotation='',\n      ),\n      roll_outcomes=(\n        RollOutcome(\n          value=0,\n          sources=(\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n          ),\n        ),\n        RollOutcome(\n          value=5,\n          sources=(),\n        ),\n      ),\n      source_rolls=(...),\n    )\n\n    ```\n\n    See the section on \u201c[Filtering and\n    substitution](rollin.md#filtering-and-substitution)\u201d more examples.\n    \"\"\"\n    __slots__: Any = (\"_coalesce_mode\", \"_expansion_op\", \"_max_depth\")\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @beartype\n    def __init__(\n        self,\n        expansion_op: _ExpansionOperatorT,\n        source: _SourceT,\n        coalesce_mode: CoalesceMode = CoalesceMode.REPLACE,\n        max_depth: SupportsInt = 1,\n        annotation: Any = \"\",\n        **kw,\n    ):\n        r\"Initializer.\"\n        super().__init__(sources=(source,), annotation=annotation, **kw)\n        self._expansion_op = expansion_op\n        self._coalesce_mode = coalesce_mode\n        self._max_depth = as_int(max_depth)\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        (source,) = self.sources\n\n        return f\"\"\"{type(self).__name__}(\n  expansion_op={self.expansion_op!r},\n  source={indent(repr(source), \"  \").strip()},\n  coalesce_mode={self.coalesce_mode!r},\n  max_depth={self.max_depth!r},\n  annotation={self.annotation!r},\n)\"\"\"\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        return (\n            super().__eq__(other)\n            and _callable_cmp(self.expansion_op, other.expansion_op)\n            and self.coalesce_mode == other.coalesce_mode\n            and self.max_depth == other.max_depth\n        )\n\n    @beartype\n    def roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n        (source_roll,) = self.source_rolls()\n        source_rolls: list[Roll] = []\n\n        def _expanded_roll_outcomes(\n            roll: Roll,\n            depth: int = 0,\n        ) -&gt; Iterator[RollOutcome]:\n            source_rolls.append(roll)\n            roll_outcomes = (\n                roll_outcome for roll_outcome in roll if roll_outcome.value is not None\n            )\n\n            if depth &gt;= self.max_depth:\n                yield from roll_outcomes\n\n                return\n\n            for roll_outcome in roll_outcomes:\n                expanded = self.expansion_op(roll_outcome)\n\n                if isinstance(expanded, RollOutcome):\n                    if expanded is not roll_outcome:\n                        expanded = expanded.adopt((roll_outcome,), CoalesceMode.APPEND)\n                        # TODO(posita): Not sure why this is necessary\n                        assert isinstance(expanded, RollOutcome)\n\n                    yield expanded\n                elif isinstance(expanded, Roll):\n                    if self.coalesce_mode == CoalesceMode.REPLACE:\n                        yield roll_outcome.euthanize()\n                    elif self.coalesce_mode == CoalesceMode.APPEND:\n                        yield roll_outcome\n                    else:\n                        assert (\n                            False\n                        ), f\"unrecognized substitution mode {self.coalesce_mode!r}\"\n\n                    expanded_roll = expanded.adopt((roll_outcome,), CoalesceMode.APPEND)\n                    yield from _expanded_roll_outcomes(expanded_roll, depth + 1)\n                else:\n                    assert False, f\"unrecognized type for expanded value {expanded!r}\"\n\n        return Roll(\n            self,\n            roll_outcomes=_expanded_roll_outcomes(source_roll),\n            source_rolls=source_rolls,\n        )\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def max_depth(self) -&gt; int:\nr\"\"\"\n        The max number of times this roller will attempt to substitute an outcome satisfying\n        its [``expansion_op``][dyce.r.SubstitutionRoller.expansion_op].\n        \"\"\"\n        return self._max_depth\n\n    @property\n    def expansion_op(self) -&gt; _ExpansionOperatorT:\nr\"\"\"\n        The expansion operator this roller applies to decide whether to substitute outcomes.\n        \"\"\"\n        return self._expansion_op\n\n    @property\n    def coalesce_mode(self) -&gt; CoalesceMode:\nr\"\"\"\n        The coalesce mode this roller uses to incorporate substituted outcomes.\n        \"\"\"\n        return self._coalesce_mode\n</code></pre>"},{"location":"dyce.r/#dyce.r.SubstitutionRoller.__slots__","title":"<code>__slots__: Any = ('_coalesce_mode', '_expansion_op', '_max_depth')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.SubstitutionRoller.coalesce_mode","title":"<code>coalesce_mode: CoalesceMode</code>  <code>property</code>","text":"<p>The coalesce mode this roller uses to incorporate substituted outcomes.</p>"},{"location":"dyce.r/#dyce.r.SubstitutionRoller.expansion_op","title":"<code>expansion_op: _ExpansionOperatorT</code>  <code>property</code>","text":"<p>The expansion operator this roller applies to decide whether to substitute outcomes.</p>"},{"location":"dyce.r/#dyce.r.SubstitutionRoller.max_depth","title":"<code>max_depth: int</code>  <code>property</code>","text":"<p>The max number of times this roller will attempt to substitute an outcome satisfying its <code>expansion_op</code>.</p>"},{"location":"dyce.r/#dyce.r.SubstitutionRoller.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    return (\n        super().__eq__(other)\n        and _callable_cmp(self.expansion_op, other.expansion_op)\n        and self.coalesce_mode == other.coalesce_mode\n        and self.max_depth == other.max_depth\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.SubstitutionRoller.__init__","title":"<code>__init__(expansion_op: _ExpansionOperatorT, source: _SourceT, coalesce_mode: CoalesceMode = CoalesceMode.REPLACE, max_depth: SupportsInt = 1, annotation: Any = '', **kw: Any)</code>","text":"<p>Initializer.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    expansion_op: _ExpansionOperatorT,\n    source: _SourceT,\n    coalesce_mode: CoalesceMode = CoalesceMode.REPLACE,\n    max_depth: SupportsInt = 1,\n    annotation: Any = \"\",\n    **kw,\n):\n    r\"Initializer.\"\n    super().__init__(sources=(source,), annotation=annotation, **kw)\n    self._expansion_op = expansion_op\n    self._coalesce_mode = coalesce_mode\n    self._max_depth = as_int(max_depth)\n</code></pre>"},{"location":"dyce.r/#dyce.r.SubstitutionRoller.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>    @beartype\n    def __repr__(self) -&gt; str:\n        (source,) = self.sources\n\n        return f\"\"\"{type(self).__name__}(\n  expansion_op={self.expansion_op!r},\n  source={indent(repr(source), \"  \").strip()},\n  coalesce_mode={self.coalesce_mode!r},\n  max_depth={self.max_depth!r},\n  annotation={self.annotation!r},\n)\"\"\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.SubstitutionRoller.roll","title":"<code>roll() -&gt; Roll</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n    (source_roll,) = self.source_rolls()\n    source_rolls: list[Roll] = []\n\n    def _expanded_roll_outcomes(\n        roll: Roll,\n        depth: int = 0,\n    ) -&gt; Iterator[RollOutcome]:\n        source_rolls.append(roll)\n        roll_outcomes = (\n            roll_outcome for roll_outcome in roll if roll_outcome.value is not None\n        )\n\n        if depth &gt;= self.max_depth:\n            yield from roll_outcomes\n\n            return\n\n        for roll_outcome in roll_outcomes:\n            expanded = self.expansion_op(roll_outcome)\n\n            if isinstance(expanded, RollOutcome):\n                if expanded is not roll_outcome:\n                    expanded = expanded.adopt((roll_outcome,), CoalesceMode.APPEND)\n                    # TODO(posita): Not sure why this is necessary\n                    assert isinstance(expanded, RollOutcome)\n\n                yield expanded\n            elif isinstance(expanded, Roll):\n                if self.coalesce_mode == CoalesceMode.REPLACE:\n                    yield roll_outcome.euthanize()\n                elif self.coalesce_mode == CoalesceMode.APPEND:\n                    yield roll_outcome\n                else:\n                    assert (\n                        False\n                    ), f\"unrecognized substitution mode {self.coalesce_mode!r}\"\n\n                expanded_roll = expanded.adopt((roll_outcome,), CoalesceMode.APPEND)\n                yield from _expanded_roll_outcomes(expanded_roll, depth + 1)\n            else:\n                assert False, f\"unrecognized type for expanded value {expanded!r}\"\n\n    return Roll(\n        self,\n        roll_outcomes=_expanded_roll_outcomes(source_roll),\n        source_rolls=source_rolls,\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.FilterRoller","title":"<code>FilterRoller</code>","text":"<p>             Bases: <code>R</code></p> <p>A roller for applying predicate to filter outcomes its sources.</p> <pre><code>&gt;&gt;&gt; r_d6 = R.from_value(H(6))\n&gt;&gt;&gt; filter_r = (2@r_d6).filter(\n...   lambda outcome: outcome.value is not None and outcome.value &gt; 3,  # type: ignore [operator]\n... )\n&gt;&gt;&gt; (filter_r).roll()\nRoll(\n  r=FilterRoller(\n    predicate=&lt;function &lt;lambda&gt; at ...&gt;,\n    sources=(\n      RepeatRoller(\n        n=2,\n        source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n        annotation='',\n      ),\n    ),\n    annotation='',\n  ),\n  roll_outcomes=(\n    RollOutcome(\n      value=None,\n      sources=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n      ),\n    ),\n    RollOutcome(\n      value=5,\n      sources=(),\n    ),\n  ),\n  source_rolls=(\n    Roll(\n      r=RepeatRoller(\n        n=2,\n        source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n        annotation='',\n      ),\n      roll_outcomes=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n        RollOutcome(\n          value=5,\n          sources=(),\n        ),\n      ),\n      source_rolls=(\n        Roll(\n          r=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n          roll_outcomes=(\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n          ),\n          source_rolls=(),\n        ),\n        Roll(\n          r=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n          roll_outcomes=(\n            RollOutcome(\n              value=5,\n              sources=(),\n            ),\n          ),\n          source_rolls=(),\n        ),\n      ),\n    ),\n  ),\n)\n</code></pre> <p>See the section on \u201cFiltering and substitution\u201d more examples.</p> Source code in <code>dyce/r.py</code> <pre><code>class FilterRoller(R):\nr\"\"\"\n    A [roller][dyce.r.R] for applying *predicate* to filter outcomes its *sources*.\n\n    &lt;!-- BEGIN MONKEY PATCH --\n    For deterministic outcomes.\n\n    &gt;&gt;&gt; import random\n    &gt;&gt;&gt; from dyce import rng\n    &gt;&gt;&gt; rng.RNG = random.Random(1639580307)\n\n      -- END MONKEY PATCH --&gt;\n\n    ``` python\n    &gt;&gt;&gt; r_d6 = R.from_value(H(6))\n    &gt;&gt;&gt; filter_r = (2@r_d6).filter(\n    ...   lambda outcome: outcome.value is not None and outcome.value &gt; 3,  # type: ignore [operator]\n    ... )\n    &gt;&gt;&gt; (filter_r).roll()\n    Roll(\n      r=FilterRoller(\n        predicate=&lt;function &lt;lambda&gt; at ...&gt;,\n        sources=(\n          RepeatRoller(\n            n=2,\n            source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n            annotation='',\n          ),\n        ),\n        annotation='',\n      ),\n      roll_outcomes=(\n        RollOutcome(\n          value=None,\n          sources=(\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n          ),\n        ),\n        RollOutcome(\n          value=5,\n          sources=(),\n        ),\n      ),\n      source_rolls=(\n        Roll(\n          r=RepeatRoller(\n            n=2,\n            source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n            annotation='',\n          ),\n          roll_outcomes=(\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n            RollOutcome(\n              value=5,\n              sources=(),\n            ),\n          ),\n          source_rolls=(\n            Roll(\n              r=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n              roll_outcomes=(\n                RollOutcome(\n                  value=2,\n                  sources=(),\n                ),\n              ),\n              source_rolls=(),\n            ),\n            Roll(\n              r=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n              roll_outcomes=(\n                RollOutcome(\n                  value=5,\n                  sources=(),\n                ),\n              ),\n              source_rolls=(),\n            ),\n          ),\n        ),\n      ),\n    )\n\n    ```\n\n    See the section on \u201c[Filtering and\n    substitution](rollin.md#filtering-and-substitution)\u201d more examples.\n    \"\"\"\n    __slots__: Any = (\"_predicate\",)\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @beartype\n    def __init__(\n        self,\n        predicate: _PredicateT,\n        sources: Iterable[R],\n        annotation: Any = \"\",\n        **kw,\n    ):\n        r\"Initializer.\"\n        super().__init__(sources=sources, annotation=annotation, **kw)\n        self._predicate = predicate\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  predicate={self.predicate!r},\n  sources=({_seq_repr(self.sources)}),\n  annotation={self.annotation!r},\n)\"\"\"\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        return super().__eq__(other) and _callable_cmp(self.predicate, other.predicate)\n\n    @beartype\n    def roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n        source_rolls = list(self.source_rolls())\n\n        def _filtered_roll_outcomes() -&gt; Iterator[RollOutcome]:\n            for roll_outcome in chain.from_iterable(source_rolls):\n                if roll_outcome.value is not None:\n                    if self.predicate(roll_outcome):\n                        yield roll_outcome\n                    else:\n                        yield roll_outcome.euthanize()\n\n        return Roll(\n            self, roll_outcomes=_filtered_roll_outcomes(), source_rolls=source_rolls\n        )\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def predicate(self) -&gt; _PredicateT:\nr\"\"\"\n        The predicate this roller applies to filter its sources.\n        \"\"\"\n        return self._predicate\n</code></pre>"},{"location":"dyce.r/#dyce.r.FilterRoller.__slots__","title":"<code>__slots__: Any = ('_predicate')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.FilterRoller.predicate","title":"<code>predicate: _PredicateT</code>  <code>property</code>","text":"<p>The predicate this roller applies to filter its sources.</p>"},{"location":"dyce.r/#dyce.r.FilterRoller.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    return super().__eq__(other) and _callable_cmp(self.predicate, other.predicate)\n</code></pre>"},{"location":"dyce.r/#dyce.r.FilterRoller.__init__","title":"<code>__init__(predicate: _PredicateT, sources: Iterable[R], annotation: Any = '', **kw: Any)</code>","text":"<p>Initializer.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    predicate: _PredicateT,\n    sources: Iterable[R],\n    annotation: Any = \"\",\n    **kw,\n):\n    r\"Initializer.\"\n    super().__init__(sources=sources, annotation=annotation, **kw)\n    self._predicate = predicate\n</code></pre>"},{"location":"dyce.r/#dyce.r.FilterRoller.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  predicate={self.predicate!r},\n  sources=({_seq_repr(self.sources)}),\n  annotation={self.annotation!r},\n)\"\"\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.FilterRoller.roll","title":"<code>roll() -&gt; Roll</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n    source_rolls = list(self.source_rolls())\n\n    def _filtered_roll_outcomes() -&gt; Iterator[RollOutcome]:\n        for roll_outcome in chain.from_iterable(source_rolls):\n            if roll_outcome.value is not None:\n                if self.predicate(roll_outcome):\n                    yield roll_outcome\n                else:\n                    yield roll_outcome.euthanize()\n\n    return Roll(\n        self, roll_outcomes=_filtered_roll_outcomes(), source_rolls=source_rolls\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.SelectionRoller","title":"<code>SelectionRoller</code>","text":"<p>             Bases: <code>R</code></p> <p>A roller for sorting outcomes from its sources and applying a selector which.</p> <p>Roll outcomes in created rolls are ordered according to the selections which. However, those selections are interpreted as indexes in a sorted view of the source\u2019s roll outcomes.</p> <pre><code>&gt;&gt;&gt; r_values = R.from_values(10000, 1, 1000, 10, 100)\n&gt;&gt;&gt; outcomes = tuple(r_values.roll().outcomes()) ; outcomes\n(10000, 1, 1000, 10, 100)\n&gt;&gt;&gt; sorted_outcomes = tuple(sorted(outcomes)) ; sorted_outcomes\n(1, 10, 100, 1000, 10000)\n&gt;&gt;&gt; which = (3, 1, 3, 2)\n&gt;&gt;&gt; tuple(sorted_outcomes[i] for i in which)\n(1000, 10, 1000, 100)\n&gt;&gt;&gt; r_select = r_values.select_iterable(which) ; r_select\nSelectionRoller(\n  which=(3, 1, 3, 2),\n  sources=(\n    PoolRoller(\n      sources=(\n        ValueRoller(value=10000, annotation=''),\n        ValueRoller(value=1, annotation=''),\n        ValueRoller(value=1000, annotation=''),\n        ValueRoller(value=10, annotation=''),\n        ValueRoller(value=100, annotation=''),\n      ),\n      annotation='',\n    ),\n  ),\n  annotation='',\n)\n&gt;&gt;&gt; roll = r_select.roll()\n&gt;&gt;&gt; tuple(roll.outcomes())\n(1000, 10, 1000, 100)\n&gt;&gt;&gt; roll\nRoll(\n  r=...,\n  roll_outcomes=(\n    RollOutcome(\n      value=1000,\n      sources=(),\n    ),\n    RollOutcome(\n      value=10,\n      sources=(),\n    ),\n    RollOutcome(\n      value=1000,\n      sources=(),\n    ),\n    RollOutcome(\n      value=100,\n      sources=(),\n    ),\n    RollOutcome(\n      value=None,\n      sources=(\n        RollOutcome(\n          value=1,\n          sources=(),\n        ),\n      ),\n    ),\n    RollOutcome(\n      value=None,\n      sources=(\n        RollOutcome(\n          value=10000,\n          sources=(),\n        ),\n      ),\n    ),\n  ),\n  source_rolls=...,\n)\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>class SelectionRoller(R):\nr\"\"\"\n    A [roller][dyce.r.R] for sorting outcomes from its *sources* and applying a selector\n    *which*.\n\n    Roll outcomes in created rolls are ordered according to the selections *which*.\n    However, those selections are interpreted as indexes in a *sorted* view of the\n    source\u2019s roll outcomes.\n\n    ``` python\n    &gt;&gt;&gt; r_values = R.from_values(10000, 1, 1000, 10, 100)\n    &gt;&gt;&gt; outcomes = tuple(r_values.roll().outcomes()) ; outcomes\n    (10000, 1, 1000, 10, 100)\n    &gt;&gt;&gt; sorted_outcomes = tuple(sorted(outcomes)) ; sorted_outcomes\n    (1, 10, 100, 1000, 10000)\n    &gt;&gt;&gt; which = (3, 1, 3, 2)\n    &gt;&gt;&gt; tuple(sorted_outcomes[i] for i in which)\n    (1000, 10, 1000, 100)\n    &gt;&gt;&gt; r_select = r_values.select_iterable(which) ; r_select\n    SelectionRoller(\n      which=(3, 1, 3, 2),\n      sources=(\n        PoolRoller(\n          sources=(\n            ValueRoller(value=10000, annotation=''),\n            ValueRoller(value=1, annotation=''),\n            ValueRoller(value=1000, annotation=''),\n            ValueRoller(value=10, annotation=''),\n            ValueRoller(value=100, annotation=''),\n          ),\n          annotation='',\n        ),\n      ),\n      annotation='',\n    )\n    &gt;&gt;&gt; roll = r_select.roll()\n    &gt;&gt;&gt; tuple(roll.outcomes())\n    (1000, 10, 1000, 100)\n    &gt;&gt;&gt; roll\n    Roll(\n      r=...,\n      roll_outcomes=(\n        RollOutcome(\n          value=1000,\n          sources=(),\n        ),\n        RollOutcome(\n          value=10,\n          sources=(),\n        ),\n        RollOutcome(\n          value=1000,\n          sources=(),\n        ),\n        RollOutcome(\n          value=100,\n          sources=(),\n        ),\n        RollOutcome(\n          value=None,\n          sources=(\n            RollOutcome(\n              value=1,\n              sources=(),\n            ),\n          ),\n        ),\n        RollOutcome(\n          value=None,\n          sources=(\n            RollOutcome(\n              value=10000,\n              sources=(),\n            ),\n          ),\n        ),\n      ),\n      source_rolls=...,\n    )\n\n    ```\n    \"\"\"\n    __slots__: Any = (\"_which\",)\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @beartype\n    def __init__(\n        self,\n        which: Iterable[_GetItemT],\n        sources: Iterable[_SourceT],\n        annotation: Any = \"\",\n        **kw,\n    ):\n        r\"Initializer.\"\n        super().__init__(sources=sources, annotation=annotation, **kw)\n        self._which = tuple(which)\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  which={self.which!r},\n  sources=({_seq_repr(self.sources)}),\n  annotation={self.annotation!r},\n)\"\"\"\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        return super().__eq__(other) and self.which == other.which\n\n    @beartype\n    def roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n        source_rolls = list(self.source_rolls())\n        roll_outcomes = list(\n            roll_outcome\n            for roll_outcome in chain.from_iterable(source_rolls)\n            if roll_outcome.value is not None\n        )\n        roll_outcomes.sort(key=attrgetter(\"value\"))\n        all_indexes = tuple(range(len(roll_outcomes)))\n        selected_indexes = tuple(getitems(all_indexes, self.which))\n\n        def _selected_roll_outcomes():\n            for selected_index in selected_indexes:\n                selected_roll_outcome = roll_outcomes[selected_index]\n                assert selected_roll_outcome.value is not None\n                yield selected_roll_outcome\n\n            for excluded_index in set(all_indexes) - set(selected_indexes):\n                yield roll_outcomes[excluded_index].euthanize()\n\n        return Roll(\n            self,\n            roll_outcomes=_selected_roll_outcomes(),\n            source_rolls=source_rolls,\n        )\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def which(self) -&gt; tuple[_GetItemT, ...]:\nr\"\"\"\n        The selector this roller applies to the sorted outcomes of its sole source.\n        \"\"\"\n        return self._which\n</code></pre>"},{"location":"dyce.r/#dyce.r.SelectionRoller.__slots__","title":"<code>__slots__: Any = ('_which')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.SelectionRoller.which","title":"<code>which: tuple[_GetItemT, ...]</code>  <code>property</code>","text":"<p>The selector this roller applies to the sorted outcomes of its sole source.</p>"},{"location":"dyce.r/#dyce.r.SelectionRoller.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    return super().__eq__(other) and self.which == other.which\n</code></pre>"},{"location":"dyce.r/#dyce.r.SelectionRoller.__init__","title":"<code>__init__(which: Iterable[_GetItemT], sources: Iterable[_SourceT], annotation: Any = '', **kw: Any)</code>","text":"<p>Initializer.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    which: Iterable[_GetItemT],\n    sources: Iterable[_SourceT],\n    annotation: Any = \"\",\n    **kw,\n):\n    r\"Initializer.\"\n    super().__init__(sources=sources, annotation=annotation, **kw)\n    self._which = tuple(which)\n</code></pre>"},{"location":"dyce.r/#dyce.r.SelectionRoller.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  which={self.which!r},\n  sources=({_seq_repr(self.sources)}),\n  annotation={self.annotation!r},\n)\"\"\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.SelectionRoller.roll","title":"<code>roll() -&gt; Roll</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef roll(self) -&gt; Roll:\nr\"\"\"\"\"\"\n    source_rolls = list(self.source_rolls())\n    roll_outcomes = list(\n        roll_outcome\n        for roll_outcome in chain.from_iterable(source_rolls)\n        if roll_outcome.value is not None\n    )\n    roll_outcomes.sort(key=attrgetter(\"value\"))\n    all_indexes = tuple(range(len(roll_outcomes)))\n    selected_indexes = tuple(getitems(all_indexes, self.which))\n\n    def _selected_roll_outcomes():\n        for selected_index in selected_indexes:\n            selected_roll_outcome = roll_outcomes[selected_index]\n            assert selected_roll_outcome.value is not None\n            yield selected_roll_outcome\n\n        for excluded_index in set(all_indexes) - set(selected_indexes):\n            yield roll_outcomes[excluded_index].euthanize()\n\n    return Roll(\n        self,\n        roll_outcomes=_selected_roll_outcomes(),\n        source_rolls=source_rolls,\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.Roll","title":"<code>Roll</code>","text":"<p>             Bases: <code>Sequence[RollOutcome]</code></p> <p>Experimental</p> <p>This class should be considered experimental and may change or disappear in future versions.</p> <p>An immutable roll result (or \u201croll\u201d for short). More specifically, the result of calling the <code>R.roll</code> method. Rolls are sequences of <code>RollOutcome</code> objects that can be assembled into trees.</p> Source code in <code>dyce/r.py</code> <pre><code>class Roll(Sequence[RollOutcome]):\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This class should be considered experimental and may change or disappear in\n        future versions.\n\n    An immutable roll result (or \u201croll\u201d for short). More specifically, the result of\n    calling the [``R.roll`` method][dyce.r.R.roll]. Rolls are sequences of\n    [``RollOutcome`` objects][dyce.r.RollOutcome] that can be assembled into trees.\n    \"\"\"\n    __slots__: Any = (\"_r\", \"_roll_outcomes\", \"_source_rolls\")\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @experimental\n    @beartype\n    def __init__(\n        self,\n        r: R,\n        roll_outcomes: Iterable[RollOutcome],\n        source_rolls: Iterable[\"Roll\"] = (),\n    ):\nr\"\"\"\n        Initializer.\n\n        This initializer will associate each of *roll_outcomes* with the newly\n        constructed roll if they do not already have a\n        [``source_roll``][dyce.r.RollOutcome.source_roll].\n\n        ``` python\n        &gt;&gt;&gt; r_4 = ValueRoller(4)\n        &gt;&gt;&gt; roll = r_4.roll()\n        &gt;&gt;&gt; new_roll = Roll(r_4, roll) ; new_roll\n        Roll(\n          r=ValueRoller(value=4, annotation=''),\n          roll_outcomes=(\n            RollOutcome(\n              value=4,\n              sources=(),\n            ),\n          ),\n          source_rolls=(),\n        )\n        &gt;&gt;&gt; roll[0].source_roll == roll\n        True\n        &gt;&gt;&gt; roll[0].r == r_4\n        True\n\n        ```\n\n        !!! note\n\n            Technically, this violates the immutability of roll outcomes.\n\n            ``dyce`` does not generally contemplate creation of rolls or roll outcomes\n            outside the womb of [``R.roll``][dyce.r.R.roll] implementations.\n            [``Roll`` objects][dyce.r.Roll] and\n            [``RollOutcome`` objects][dyce.r.RollOutcome] generally mate for life, being\n            created exclusively for (and in close proximity to) one another. A roll\n            manipulating a roll outcome\u2019s internal state post initialization may seem\n            unseemly, but that intimacy is a fundamental part of their primordial\n            ritual.\n\n            That being said, you\u2019re an adult. Do what you want. Just know that if you\u2019re\n            going to create your own roll outcomes and pimp them out all over town, they\n            might pick something up along the way.\n\n            See also the\n            [``RollOutcome.source_roll`` property][dyce.r.RollOutcome.source_roll].\n        \"\"\"\n        super().__init__()\n        self._r = r\n        self._roll_outcomes = tuple(roll_outcomes)\n        self._source_rolls = tuple(source_rolls)\n\n        for roll_outcome in self._roll_outcomes:\n            if roll_outcome._roll is None:\n                roll_outcome._roll = self\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  r={indent(repr(self.r), \"  \").strip()},\n  roll_outcomes=({_seq_repr(self)}),\n  source_rolls=({_seq_repr(self.source_rolls)}),\n)\"\"\"\n\n    @beartype\n    def __len__(self) -&gt; int:\n        return len(self._roll_outcomes)\n\n    @overload\n    def __getitem__(self, key: SupportsIndex) -&gt; RollOutcome:\n        ...\n\n    @overload\n    def __getitem__(self, key: slice) -&gt; tuple[RollOutcome, ...]:\n        ...\n\n    @beartype\n    def __getitem__(\n        self,\n        key: _GetItemT,\n    ) -&gt; Union[RollOutcome, tuple[RollOutcome, ...]]:\n        if isinstance(key, slice):\n            return self._roll_outcomes[key]\n        else:\n            return self._roll_outcomes[__index__(key)]\n\n    @beartype\n    def __iter__(self) -&gt; Iterator[RollOutcome]:\n        return iter(self._roll_outcomes)\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def annotation(self) -&gt; Any:\nr\"\"\"\n        Shorthand for ``#!python self.r.annotation``.\n\n        See the [``R.annotation`` property][dyce.r.R.annotation].\n        \"\"\"\n        return self.r.annotation\n\n    @property\n    def r(self) -&gt; R:\nr\"\"\"\n        The roller that generated the roll.\n        \"\"\"\n        return self._r\n\n    @property\n    def source_rolls(self) -&gt; tuple[Roll, ...]:\nr\"\"\"\n        The source rolls from which this roll was generated.\n        \"\"\"\n        return self._source_rolls\n\n    # ---- Methods ---------------------------------------------------------------------\n\n    @beartype\n    def adopt(\n        self,\n        sources: Iterable[\"RollOutcome\"] = (),\n        coalesce_mode: CoalesceMode = CoalesceMode.REPLACE,\n    ) -&gt; Roll:\nr\"\"\"\n        Shorthand for ``#!python Roll(self.r, (roll_outcome.adopt(sources,\n        coalesce_mode) for roll_outcome in self), self.source_rolls)``.\n        \"\"\"\n        return type(self)(\n            self.r,\n            (roll_outcome.adopt(sources, coalesce_mode) for roll_outcome in self),\n            self.source_rolls,\n        )\n\n    @beartype\n    def outcomes(self) -&gt; Iterator[RealLike]:\nr\"\"\"\n        Shorthand for ``#!python (roll_outcome.value for roll_outcome in self if\n        roll_outcome.value is not None)``.\n\n        &lt;!-- BEGIN MONKEY PATCH --\n        For deterministic outcomes.\n\n        &gt;&gt;&gt; import random\n        &gt;&gt;&gt; from dyce import rng\n        &gt;&gt;&gt; rng.RNG = random.Random(1633056410)\n\n          -- END MONKEY PATCH --&gt;\n\n        !!! info\n\n            Unlike [``H.roll``][dyce.h.H.roll] and [``P.roll``][dyce.p.P.roll], these\n            outcomes are *not* sorted. Instead, they retain the ordering as passed to\n            [``__init__``][dyce.r.Roll.__init__].\n\n            ``` python\n            &gt;&gt;&gt; r_3d6 = 3@R.from_value(H(6))\n            &gt;&gt;&gt; r_3d6_neg = 3@-R.from_value(H(6))\n            &gt;&gt;&gt; roll = R.from_sources(r_3d6, r_3d6_neg).roll()\n            &gt;&gt;&gt; tuple(roll.outcomes())\n            (1, 3, 1, -4, -6, -1)\n            &gt;&gt;&gt; len(roll)\n            6\n\n            ```\n        \"\"\"\n        return (\n            roll_outcome.value\n            for roll_outcome in self\n            if roll_outcome.value is not None\n        )\n\n    @beartype\n    def total(self) -&gt; RealLike:\nr\"\"\"\n        Shorthand for ``#!python sum(self.outcomes())``.\n        \"\"\"\n        return sum(self.outcomes())\n</code></pre>"},{"location":"dyce.r/#dyce.r.Roll.__slots__","title":"<code>__slots__: Any = ('_r', '_roll_outcomes', '_source_rolls')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.Roll.annotation","title":"<code>annotation: Any</code>  <code>property</code>","text":"<p>Shorthand for <code>self.r.annotation</code>.</p> <p>See the <code>R.annotation</code> property.</p>"},{"location":"dyce.r/#dyce.r.Roll.r","title":"<code>r: R</code>  <code>property</code>","text":"<p>The roller that generated the roll.</p>"},{"location":"dyce.r/#dyce.r.Roll.source_rolls","title":"<code>source_rolls: tuple[Roll, ...]</code>  <code>property</code>","text":"<p>The source rolls from which this roll was generated.</p>"},{"location":"dyce.r/#dyce.r.Roll.__getitem__","title":"<code>__getitem__(key: _GetItemT) -&gt; Union[RollOutcome, tuple[RollOutcome, ...]]</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __getitem__(\n    self,\n    key: _GetItemT,\n) -&gt; Union[RollOutcome, tuple[RollOutcome, ...]]:\n    if isinstance(key, slice):\n        return self._roll_outcomes[key]\n    else:\n        return self._roll_outcomes[__index__(key)]\n</code></pre>"},{"location":"dyce.r/#dyce.r.Roll.__init__","title":"<code>__init__(r: R, roll_outcomes: Iterable[RollOutcome], source_rolls: Iterable['Roll'] = ())</code>","text":"<p>Initializer.</p> <p>This initializer will associate each of roll_outcomes with the newly constructed roll if they do not already have a <code>source_roll</code>.</p> <pre><code>&gt;&gt;&gt; r_4 = ValueRoller(4)\n&gt;&gt;&gt; roll = r_4.roll()\n&gt;&gt;&gt; new_roll = Roll(r_4, roll) ; new_roll\nRoll(\n  r=ValueRoller(value=4, annotation=''),\n  roll_outcomes=(\n    RollOutcome(\n      value=4,\n      sources=(),\n    ),\n  ),\n  source_rolls=(),\n)\n&gt;&gt;&gt; roll[0].source_roll == roll\nTrue\n&gt;&gt;&gt; roll[0].r == r_4\nTrue\n</code></pre> <p>Note</p> <p>Technically, this violates the immutability of roll outcomes.</p> <p><code>dyce</code> does not generally contemplate creation of rolls or roll outcomes outside the womb of <code>R.roll</code> implementations. <code>Roll</code> objects and <code>RollOutcome</code> objects generally mate for life, being created exclusively for (and in close proximity to) one another. A roll manipulating a roll outcome\u2019s internal state post initialization may seem unseemly, but that intimacy is a fundamental part of their primordial ritual.</p> <p>That being said, you\u2019re an adult. Do what you want. Just know that if you\u2019re going to create your own roll outcomes and pimp them out all over town, they might pick something up along the way.</p> <p>See also the <code>RollOutcome.source_roll</code> property.</p> Source code in <code>dyce/r.py</code> <pre><code>@experimental\n@beartype\ndef __init__(\n    self,\n    r: R,\n    roll_outcomes: Iterable[RollOutcome],\n    source_rolls: Iterable[\"Roll\"] = (),\n):\nr\"\"\"\n    Initializer.\n\n    This initializer will associate each of *roll_outcomes* with the newly\n    constructed roll if they do not already have a\n    [``source_roll``][dyce.r.RollOutcome.source_roll].\n\n    ``` python\n    &gt;&gt;&gt; r_4 = ValueRoller(4)\n    &gt;&gt;&gt; roll = r_4.roll()\n    &gt;&gt;&gt; new_roll = Roll(r_4, roll) ; new_roll\n    Roll(\n      r=ValueRoller(value=4, annotation=''),\n      roll_outcomes=(\n        RollOutcome(\n          value=4,\n          sources=(),\n        ),\n      ),\n      source_rolls=(),\n    )\n    &gt;&gt;&gt; roll[0].source_roll == roll\n    True\n    &gt;&gt;&gt; roll[0].r == r_4\n    True\n\n    ```\n\n    !!! note\n\n        Technically, this violates the immutability of roll outcomes.\n\n        ``dyce`` does not generally contemplate creation of rolls or roll outcomes\n        outside the womb of [``R.roll``][dyce.r.R.roll] implementations.\n        [``Roll`` objects][dyce.r.Roll] and\n        [``RollOutcome`` objects][dyce.r.RollOutcome] generally mate for life, being\n        created exclusively for (and in close proximity to) one another. A roll\n        manipulating a roll outcome\u2019s internal state post initialization may seem\n        unseemly, but that intimacy is a fundamental part of their primordial\n        ritual.\n\n        That being said, you\u2019re an adult. Do what you want. Just know that if you\u2019re\n        going to create your own roll outcomes and pimp them out all over town, they\n        might pick something up along the way.\n\n        See also the\n        [``RollOutcome.source_roll`` property][dyce.r.RollOutcome.source_roll].\n    \"\"\"\n    super().__init__()\n    self._r = r\n    self._roll_outcomes = tuple(roll_outcomes)\n    self._source_rolls = tuple(source_rolls)\n\n    for roll_outcome in self._roll_outcomes:\n        if roll_outcome._roll is None:\n            roll_outcome._roll = self\n</code></pre>"},{"location":"dyce.r/#dyce.r.Roll.__iter__","title":"<code>__iter__() -&gt; Iterator[RollOutcome]</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __iter__(self) -&gt; Iterator[RollOutcome]:\n    return iter(self._roll_outcomes)\n</code></pre>"},{"location":"dyce.r/#dyce.r.Roll.__len__","title":"<code>__len__() -&gt; int</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __len__(self) -&gt; int:\n    return len(self._roll_outcomes)\n</code></pre>"},{"location":"dyce.r/#dyce.r.Roll.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  r={indent(repr(self.r), \"  \").strip()},\n  roll_outcomes=({_seq_repr(self)}),\n  source_rolls=({_seq_repr(self.source_rolls)}),\n)\"\"\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.Roll.adopt","title":"<code>adopt(sources: Iterable['RollOutcome'] = (), coalesce_mode: CoalesceMode = CoalesceMode.REPLACE) -&gt; Roll</code>","text":"<p>Shorthand for <code>Roll(self.r, (roll_outcome.adopt(sources,coalesce_mode) for roll_outcome in self), self.source_rolls)</code>.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef adopt(\n    self,\n    sources: Iterable[\"RollOutcome\"] = (),\n    coalesce_mode: CoalesceMode = CoalesceMode.REPLACE,\n) -&gt; Roll:\nr\"\"\"\n    Shorthand for ``#!python Roll(self.r, (roll_outcome.adopt(sources,\n    coalesce_mode) for roll_outcome in self), self.source_rolls)``.\n    \"\"\"\n    return type(self)(\n        self.r,\n        (roll_outcome.adopt(sources, coalesce_mode) for roll_outcome in self),\n        self.source_rolls,\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.Roll.outcomes","title":"<code>outcomes() -&gt; Iterator[RealLike]</code>","text":"<p>Shorthand for <code>(roll_outcome.value for roll_outcome in self ifroll_outcome.value is not None)</code>.</p> <p>Info</p> <p>Unlike <code>H.roll</code> and <code>P.roll</code>, these outcomes are not sorted. Instead, they retain the ordering as passed to <code>__init__</code>.</p> <pre><code>&gt;&gt;&gt; r_3d6 = 3@R.from_value(H(6))\n&gt;&gt;&gt; r_3d6_neg = 3@-R.from_value(H(6))\n&gt;&gt;&gt; roll = R.from_sources(r_3d6, r_3d6_neg).roll()\n&gt;&gt;&gt; tuple(roll.outcomes())\n(1, 3, 1, -4, -6, -1)\n&gt;&gt;&gt; len(roll)\n6\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef outcomes(self) -&gt; Iterator[RealLike]:\nr\"\"\"\n    Shorthand for ``#!python (roll_outcome.value for roll_outcome in self if\n    roll_outcome.value is not None)``.\n\n    &lt;!-- BEGIN MONKEY PATCH --\n    For deterministic outcomes.\n\n    &gt;&gt;&gt; import random\n    &gt;&gt;&gt; from dyce import rng\n    &gt;&gt;&gt; rng.RNG = random.Random(1633056410)\n\n      -- END MONKEY PATCH --&gt;\n\n    !!! info\n\n        Unlike [``H.roll``][dyce.h.H.roll] and [``P.roll``][dyce.p.P.roll], these\n        outcomes are *not* sorted. Instead, they retain the ordering as passed to\n        [``__init__``][dyce.r.Roll.__init__].\n\n        ``` python\n        &gt;&gt;&gt; r_3d6 = 3@R.from_value(H(6))\n        &gt;&gt;&gt; r_3d6_neg = 3@-R.from_value(H(6))\n        &gt;&gt;&gt; roll = R.from_sources(r_3d6, r_3d6_neg).roll()\n        &gt;&gt;&gt; tuple(roll.outcomes())\n        (1, 3, 1, -4, -6, -1)\n        &gt;&gt;&gt; len(roll)\n        6\n\n        ```\n    \"\"\"\n    return (\n        roll_outcome.value\n        for roll_outcome in self\n        if roll_outcome.value is not None\n    )\n</code></pre>"},{"location":"dyce.r/#dyce.r.Roll.total","title":"<code>total() -&gt; RealLike</code>","text":"<p>Shorthand for <code>sum(self.outcomes())</code>.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef total(self) -&gt; RealLike:\nr\"\"\"\n    Shorthand for ``#!python sum(self.outcomes())``.\n    \"\"\"\n    return sum(self.outcomes())\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome","title":"<code>RollOutcome</code>","text":"<p>Experimental</p> <p>This class should be considered experimental and may change or disappear in future versions.</p> <p>A single, (mostly) immutable outcome generated by a roll.</p> Source code in <code>dyce/r.py</code> <pre><code>class RollOutcome:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This class should be considered experimental and may change or disappear in\n        future versions.\n\n    A single, ([mostly][dyce.r.Roll.__init__]) immutable outcome generated by a roll.\n    \"\"\"\n    __slots__: Any = (\"_roll\", \"_sources\", \"_value\")\n\n    # ---- Initializer -----------------------------------------------------------------\n\n    @experimental\n    @beartype\n    def __init__(\n        self,\n        value: Optional[RealLike],\n        # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n        sources: Iterable[\"RollOutcome\"] = (),\n    ):\n        r\"Initializer.\"\n        super().__init__()\n        self._value = value\n        self._sources = tuple(sources)\n        self._roll: Optional[Roll] = None\n\n        if self._value is None and not self._sources:\n            raise ValueError(\"value can only be None if sources is non-empty\")\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  value={repr(self.value)},\n  sources=({_seq_repr(self.sources)}),\n)\"\"\"\n\n    @beartype\n    # TODO(posita): See &lt;https://github.com/python/mypy/issues/10943&gt;\n    def __lt__(self, other: _RollOutcomeOperandT) -&gt; bool:  # type: ignore [has-type]\n        if (\n            isinstance(other, RollOutcome)\n            and self.value is not None\n            and other.value is not None\n        ):\n            return bool(__lt__(self.value, other.value))\n        else:\n            return NotImplemented\n\n    @beartype\n    # TODO(posita): See &lt;https://github.com/python/mypy/issues/10943&gt;\n    def __le__(self, other: _RollOutcomeOperandT) -&gt; bool:  # type: ignore [has-type]\n        if (\n            isinstance(other, RollOutcome)\n            and self.value is not None\n            and other.value is not None\n        ):\n            return bool(__le__(self.value, other.value))\n        else:\n            return NotImplemented\n\n    @beartype\n    def __eq__(self, other) -&gt; bool:\n        if isinstance(other, RollOutcome):\n            return bool(__eq__(self.value, other.value))\n        else:\n            return super().__eq__(other)\n\n    @beartype\n    def __ne__(self, other) -&gt; bool:\n        if isinstance(other, RollOutcome):\n            return bool(__ne__(self.value, other.value))\n        else:\n            return super().__ne__(other)\n\n    @beartype\n    def __gt__(self, other: _RollOutcomeOperandT) -&gt; bool:\n        if (\n            isinstance(other, RollOutcome)\n            and self.value is not None\n            and other.value is not None\n        ):\n            return bool(__gt__(self.value, other.value))\n        else:\n            return NotImplemented\n\n    @beartype\n    def __ge__(self, other: _RollOutcomeOperandT) -&gt; bool:\n        if (\n            isinstance(other, RollOutcome)\n            and self.value is not None\n            and other.value is not None\n        ):\n            return bool(__ge__(self.value, other.value))\n        else:\n            return NotImplemented\n\n    @beartype\n    def __add__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        try:\n            return self.map(__add__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __radd__(self, other: RealLike) -&gt; RollOutcome:\n        try:\n            return self.rmap(other, __add__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __sub__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        try:\n            return self.map(__sub__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rsub__(self, other: RealLike) -&gt; RollOutcome:\n        try:\n            return self.rmap(other, __sub__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __mul__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        try:\n            return self.map(__mul__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rmul__(self, other: RealLike) -&gt; RollOutcome:\n        try:\n            return self.rmap(other, __mul__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __truediv__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        try:\n            return self.map(__truediv__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rtruediv__(self, other: RealLike) -&gt; RollOutcome:\n        try:\n            return self.rmap(other, __truediv__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __floordiv__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        try:\n            return self.map(__floordiv__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rfloordiv__(self, other: RealLike) -&gt; RollOutcome:\n        try:\n            return self.rmap(other, __floordiv__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __mod__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        try:\n            return self.map(__mod__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rmod__(self, other: RealLike) -&gt; RollOutcome:\n        try:\n            return self.rmap(other, __mod__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __pow__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        try:\n            return self.map(__pow__, other)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    def __rpow__(self, other: RealLike) -&gt; RollOutcome:\n        try:\n            return self.rmap(other, __pow__)\n        except NotImplementedError:\n            return NotImplemented\n\n    @beartype\n    # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n    def __and__(self, other: Union[\"RollOutcome\", SupportsInt]) -&gt; RollOutcome:\n        try:\n            if isinstance(other, SupportsInt):\n                other = as_int(other)\n\n            return self.map(__and__, other)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    def __rand__(self, other: SupportsInt) -&gt; RollOutcome:\n        try:\n            return self.rmap(as_int(other), __and__)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n    def __xor__(self, other: Union[\"RollOutcome\", SupportsInt]) -&gt; RollOutcome:\n        try:\n            if isinstance(other, SupportsInt):\n                other = as_int(other)\n\n            return self.map(__xor__, other)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    def __rxor__(self, other: SupportsInt) -&gt; RollOutcome:\n        try:\n            return self.rmap(as_int(other), __xor__)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n    def __or__(self, other: Union[\"RollOutcome\", SupportsInt]) -&gt; RollOutcome:\n        try:\n            if isinstance(other, SupportsInt):\n                other = as_int(other)\n\n            return self.map(__or__, other)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    def __ror__(self, other: SupportsInt) -&gt; RollOutcome:\n        try:\n            return self.rmap(as_int(other), __or__)\n        except (NotImplementedError, TypeError):\n            return NotImplemented\n\n    @beartype\n    def __neg__(self) -&gt; RollOutcome:\n        return self.umap(__neg__)\n\n    @beartype\n    def __pos__(self) -&gt; RollOutcome:\n        return self.umap(__pos__)\n\n    @beartype\n    def __abs__(self) -&gt; RollOutcome:\n        return self.umap(__abs__)\n\n    @beartype\n    def __invert__(self) -&gt; RollOutcome:\n        return self.umap(__invert__)\n\n    # ---- Properties ------------------------------------------------------------------\n\n    @property\n    def annotation(self) -&gt; Any:\nr\"\"\"\n        Shorthand for ``#!python self.source_roll.annotation``.\n\n        See the [``source_roll``][dyce.r.RollOutcome.source_roll] and\n        [``Roll.annotation``][dyce.r.Roll.annotation] properties.\n        \"\"\"\n        return self.source_roll.annotation\n\n    @property\n    def r(self) -&gt; R:\nr\"\"\"\n        Shorthand for ``#!python self.source_roll.r``.\n\n        See the [``source_roll``][dyce.r.RollOutcome.source_roll] and\n        [``Roll.r``][dyce.r.Roll.r] properties.\n        \"\"\"\n        return self.source_roll.r\n\n    @property\n    def source_roll(self) -&gt; Roll:\nr\"\"\"\n        Returns the roll if one has been associated with this roll outcome. Usually that\n        happens by submitting the roll outcome to the\n        [``Roll.__init__`` method][dyce.r.Roll.__init__] inside a\n        [``R.roll`` method][dyce.r.R.roll] implementation. Accessing this property\n        before the roll outcome has been associated with a roll is considered a\n        programming error.\n\n        ``` python\n        &gt;&gt;&gt; ro = RollOutcome(4)\n        &gt;&gt;&gt; ro.source_roll\n        Traceback (most recent call last):\n          ...\n        AssertionError: RollOutcome.source_roll accessed before associating the roll outcome with a roll (usually via Roll.__init__)\n        assert None is not None\n        &gt;&gt;&gt; roll = Roll(R.from_value(4), roll_outcomes=(ro,))\n        &gt;&gt;&gt; ro.source_roll\n        Roll(\n          r=ValueRoller(value=4, annotation=''),\n          roll_outcomes=(\n            RollOutcome(\n              value=4,\n              sources=(),\n            ),\n          ),\n          source_rolls=(),\n        )\n\n        ```\n        \"\"\"\n        assert (\n            self._roll is not None\n        ), \"RollOutcome.source_roll accessed before associating the roll outcome with a roll (usually via Roll.__init__)\"\n\n        return self._roll\n\n    @property\n    def sources(self) -&gt; tuple[RollOutcome, ...]:\nr\"\"\"\n        The source roll outcomes from which this roll outcome was generated.\n        \"\"\"\n        return self._sources\n\n    @property\n    def value(self) -&gt; Optional[RealLike]:\nr\"\"\"\n        The outcome value. A value of ``#!python None`` is used to signal that a source\u2019s\n        roll outcome was excluded by the roller.\n        \"\"\"\n        return self._value\n\n    # ---- Methods ---------------------------------------------------------------------\n\n    @beartype\n    def map(\n        self,\n        bin_op: _BinaryOperatorT,\n        right_operand: _RollOutcomeOperandT,\n    ) -&gt; RollOutcome:\nr\"\"\"\n        Applies *bin_op* to the value of this roll outcome as the left operand and\n        *right_operand* as the right. Shorthands exist for many arithmetic operators and\n        comparators.\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; two = RollOutcome(2)\n        &gt;&gt;&gt; two.map(operator.__pow__, 10)\n        RollOutcome(\n          value=1024,\n          sources=(\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n          ),\n        )\n        &gt;&gt;&gt; two.map(operator.__pow__, 10) == two ** 10\n        True\n\n        ```\n        \"\"\"\n        if isinstance(right_operand, RollOutcome):\n            sources: tuple[RollOutcome, ...] = (self, right_operand)\n            right_operand_value: Optional[RealLike] = right_operand.value\n        else:\n            sources = (self,)\n            right_operand_value = right_operand\n\n        if isinstance(right_operand_value, RealLike):\n            return type(self)(bin_op(self.value, right_operand_value), sources)\n        else:\n            raise NotImplementedError\n\n    @beartype\n    def rmap(self, left_operand: RealLike, bin_op: _BinaryOperatorT) -&gt; RollOutcome:\nr\"\"\"\n        Analogous to the [``map`` method][dyce.r.RollOutcome.map], but where the caller\n        supplies *left_operand*.\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; two = RollOutcome(2)\n        &gt;&gt;&gt; two.rmap(10, operator.__pow__)\n        RollOutcome(\n          value=100,\n          sources=(\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n          ),\n        )\n        &gt;&gt;&gt; two.rmap(10, operator.__pow__) == 10 ** two\n        True\n\n        ```\n\n        !!! note\n\n            The positions of *left_operand* and *bin_op* are different from\n            [``map`` method][dyce.r.RollOutcome.map]. This is intentional and serves as\n            a reminder of operand ordering.\n        \"\"\"\n        if isinstance(left_operand, RealLike):\n            return type(self)(bin_op(left_operand, self.value), sources=(self,))\n        else:\n            raise NotImplementedError\n\n    @beartype\n    def umap(\n        self,\n        un_op: _UnaryOperatorT,\n    ) -&gt; RollOutcome:\nr\"\"\"\n        Applies *un_op* to the value of this roll outcome. Shorthands exist for many\n        arithmetic operators and comparators.\n\n        ``` python\n        &gt;&gt;&gt; import operator\n        &gt;&gt;&gt; two_neg = RollOutcome(-2)\n        &gt;&gt;&gt; two_neg.umap(operator.__neg__)\n        RollOutcome(\n          value=2,\n          sources=(\n            RollOutcome(\n              value=-2,\n              sources=(),\n            ),\n          ),\n        )\n        &gt;&gt;&gt; two_neg.umap(operator.__neg__) == -two_neg\n        True\n\n        ```\n        \"\"\"\n        return type(self)(un_op(self.value), sources=(self,))\n\n    @beartype\n    def lt(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        if isinstance(other, RollOutcome):\n            return type(self)(bool(__lt__(self, other)), sources=(self, other))\n        elif self.value is not None:\n            return type(self)(bool(__lt__(self.value, other)), sources=(self,))\n        else:\n            raise ValueError(f\"unable to compare {self} to {other}\")\n\n    @beartype\n    def le(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        if isinstance(other, RollOutcome):\n            return type(self)(bool(__le__(self, other)), sources=(self, other))\n        elif self.value is not None:\n            return type(self)(bool(__le__(self.value, other)), sources=(self,))\n        else:\n            raise ValueError(f\"unable to compare {self} to {other}\")\n\n    @beartype\n    def eq(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        if isinstance(other, RollOutcome):\n            return type(self)(bool(__eq__(self, other)), sources=(self, other))\n        elif self.value is not None:\n            return type(self)(bool(__eq__(self.value, other)), sources=(self,))\n        else:\n            raise ValueError(f\"unable to compare {self} to {other}\")\n\n    @beartype\n    def ne(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        if isinstance(other, RollOutcome):\n            return type(self)(bool(__ne__(self, other)), sources=(self, other))\n        else:\n            return type(self)(bool(__ne__(self.value, other)), sources=(self,))\n\n    @beartype\n    def gt(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        if isinstance(other, RollOutcome):\n            return type(self)(bool(__gt__(self, other)), sources=(self, other))\n        elif self.value is not None:\n            return type(self)(bool(__gt__(self.value, other)), sources=(self,))\n        else:\n            raise ValueError(f\"unable to compare {self} to {other}\")\n\n    @beartype\n    def ge(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n        if isinstance(other, RollOutcome):\n            return type(self)(bool(__ge__(self, other)), sources=(self, other))\n        elif self.value is not None:\n            return type(self)(bool(__ge__(self.value, other)), sources=(self,))\n        else:\n            raise ValueError(f\"unable to compare {self} to {other}\")\n\n    @beartype\n    def is_even(self) -&gt; RollOutcome:\nr\"\"\"\n        Shorthand for: ``#!python self.umap(dyce.types.is_even)``.\n\n        See the [``umap`` method][dyce.r.RollOutcome.umap].\n        \"\"\"\n        return self.umap(is_even)\n\n    @beartype\n    def is_odd(self) -&gt; RollOutcome:\nr\"\"\"\n        Shorthand for: ``#!python self.umap(dyce.types.is_even)``.\n\n        See the [``umap`` method][dyce.r.RollOutcome.umap].\n        \"\"\"\n        return self.umap(is_odd)\n\n    @beartype\n    def adopt(\n        self,\n        sources: Iterable[\"RollOutcome\"] = (),\n        coalesce_mode: CoalesceMode = CoalesceMode.REPLACE,\n    ) -&gt; RollOutcome:\nr\"\"\"\n        Creates and returns a new roll outcome identical to this roll outcome, but with\n        *sources* replacing or appended to this roll outcome\u2019s sources in accordance\n        with *coalesce_mode*.\n\n        ``` python\n        &gt;&gt;&gt; from dyce.r import CoalesceMode\n        &gt;&gt;&gt; orig = RollOutcome(1, sources=(RollOutcome(2),)) ; orig\n        RollOutcome(\n          value=1,\n          sources=(\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n          ),\n        )\n        &gt;&gt;&gt; orig.adopt((RollOutcome(3),), coalesce_mode=CoalesceMode.REPLACE)\n        RollOutcome(\n          value=1,\n          sources=(\n            RollOutcome(\n              value=3,\n              sources=(),\n            ),\n          ),\n        )\n        &gt;&gt;&gt; orig.adopt((RollOutcome(3),), coalesce_mode=CoalesceMode.APPEND)\n        RollOutcome(\n          value=1,\n          sources=(\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n            RollOutcome(\n              value=3,\n              sources=(),\n            ),\n          ),\n        )\n\n        ```\n        \"\"\"\n        if coalesce_mode is CoalesceMode.REPLACE:\n            adopted_sources = sources\n        elif coalesce_mode is CoalesceMode.APPEND:\n            adopted_sources = chain(self.sources, sources)\n        else:\n            assert False, f\"unrecognized substitution mode {self.coalesce_mode!r}\"\n\n        adopted_roll_outcome = type(self)(self.value, adopted_sources)\n        adopted_roll_outcome._roll = self._roll\n\n        return adopted_roll_outcome\n\n    @beartype\n    def euthanize(self) -&gt; RollOutcome:\nr\"\"\"\n        Shorthand for ``#!python self.umap(lambda operand: None)``.\n\n        ``` python\n        &gt;&gt;&gt; two = RollOutcome(2)\n        &gt;&gt;&gt; two.euthanize()\n        RollOutcome(\n          value=None,\n          sources=(\n            RollOutcome(\n              value=2,\n              sources=(),\n            ),\n          ),\n        )\n\n        ```\n\n        See the [``umap`` method][dyce.r.RollOutcome.umap].\n        \"\"\"\n\n        def _euthanize(operand: Optional[RealLike]) -&gt; None:\n            pass\n\n        return self.umap(_euthanize)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__slots__","title":"<code>__slots__: Any = ('_roll', '_sources', '_value')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.RollOutcome.annotation","title":"<code>annotation: Any</code>  <code>property</code>","text":"<p>Shorthand for <code>self.source_roll.annotation</code>.</p> <p>See the <code>source_roll</code> and <code>Roll.annotation</code> properties.</p>"},{"location":"dyce.r/#dyce.r.RollOutcome.r","title":"<code>r: R</code>  <code>property</code>","text":"<p>Shorthand for <code>self.source_roll.r</code>.</p> <p>See the <code>source_roll</code> and <code>Roll.r</code> properties.</p>"},{"location":"dyce.r/#dyce.r.RollOutcome.source_roll","title":"<code>source_roll: Roll</code>  <code>property</code>","text":"<p>Returns the roll if one has been associated with this roll outcome. Usually that happens by submitting the roll outcome to the <code>Roll.__init__</code> method inside a <code>R.roll</code> method implementation. Accessing this property before the roll outcome has been associated with a roll is considered a programming error.</p> <pre><code>&gt;&gt;&gt; ro = RollOutcome(4)\n&gt;&gt;&gt; ro.source_roll\nTraceback (most recent call last):\n  ...\nAssertionError: RollOutcome.source_roll accessed before associating the roll outcome with a roll (usually via Roll.__init__)\nassert None is not None\n&gt;&gt;&gt; roll = Roll(R.from_value(4), roll_outcomes=(ro,))\n&gt;&gt;&gt; ro.source_roll\nRoll(\n  r=ValueRoller(value=4, annotation=''),\n  roll_outcomes=(\n    RollOutcome(\n      value=4,\n      sources=(),\n    ),\n  ),\n  source_rolls=(),\n)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.sources","title":"<code>sources: tuple[RollOutcome, ...]</code>  <code>property</code>","text":"<p>The source roll outcomes from which this roll outcome was generated.</p>"},{"location":"dyce.r/#dyce.r.RollOutcome.value","title":"<code>value: Optional[RealLike]</code>  <code>property</code>","text":"<p>The outcome value. A value of <code>None</code> is used to signal that a source\u2019s roll outcome was excluded by the roller.</p>"},{"location":"dyce.r/#dyce.r.RollOutcome.__abs__","title":"<code>__abs__() -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __abs__(self) -&gt; RollOutcome:\n    return self.umap(__abs__)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__add__","title":"<code>__add__(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __add__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    try:\n        return self.map(__add__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__and__","title":"<code>__and__(other: Union['RollOutcome', SupportsInt]) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\n# TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\ndef __and__(self, other: Union[\"RollOutcome\", SupportsInt]) -&gt; RollOutcome:\n    try:\n        if isinstance(other, SupportsInt):\n            other = as_int(other)\n\n        return self.map(__and__, other)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__eq__","title":"<code>__eq__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __eq__(self, other) -&gt; bool:\n    if isinstance(other, RollOutcome):\n        return bool(__eq__(self.value, other.value))\n    else:\n        return super().__eq__(other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__floordiv__","title":"<code>__floordiv__(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __floordiv__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    try:\n        return self.map(__floordiv__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__ge__","title":"<code>__ge__(other: _RollOutcomeOperandT) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __ge__(self, other: _RollOutcomeOperandT) -&gt; bool:\n    if (\n        isinstance(other, RollOutcome)\n        and self.value is not None\n        and other.value is not None\n    ):\n        return bool(__ge__(self.value, other.value))\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__gt__","title":"<code>__gt__(other: _RollOutcomeOperandT) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __gt__(self, other: _RollOutcomeOperandT) -&gt; bool:\n    if (\n        isinstance(other, RollOutcome)\n        and self.value is not None\n        and other.value is not None\n    ):\n        return bool(__gt__(self.value, other.value))\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__init__","title":"<code>__init__(value: Optional[RealLike], sources: Iterable['RollOutcome'] = ())</code>","text":"<p>Initializer.</p> Source code in <code>dyce/r.py</code> <pre><code>@experimental\n@beartype\ndef __init__(\n    self,\n    value: Optional[RealLike],\n    # TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\n    sources: Iterable[\"RollOutcome\"] = (),\n):\n    r\"Initializer.\"\n    super().__init__()\n    self._value = value\n    self._sources = tuple(sources)\n    self._roll: Optional[Roll] = None\n\n    if self._value is None and not self._sources:\n        raise ValueError(\"value can only be None if sources is non-empty\")\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__invert__","title":"<code>__invert__() -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __invert__(self) -&gt; RollOutcome:\n    return self.umap(__invert__)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__le__","title":"<code>__le__(other: _RollOutcomeOperandT) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\n# TODO(posita): See &lt;https://github.com/python/mypy/issues/10943&gt;\ndef __le__(self, other: _RollOutcomeOperandT) -&gt; bool:  # type: ignore [has-type]\n    if (\n        isinstance(other, RollOutcome)\n        and self.value is not None\n        and other.value is not None\n    ):\n        return bool(__le__(self.value, other.value))\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__lt__","title":"<code>__lt__(other: _RollOutcomeOperandT) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\n# TODO(posita): See &lt;https://github.com/python/mypy/issues/10943&gt;\ndef __lt__(self, other: _RollOutcomeOperandT) -&gt; bool:  # type: ignore [has-type]\n    if (\n        isinstance(other, RollOutcome)\n        and self.value is not None\n        and other.value is not None\n    ):\n        return bool(__lt__(self.value, other.value))\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__mod__","title":"<code>__mod__(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __mod__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    try:\n        return self.map(__mod__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__mul__","title":"<code>__mul__(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __mul__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    try:\n        return self.map(__mul__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__ne__","title":"<code>__ne__(other) -&gt; bool</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __ne__(self, other) -&gt; bool:\n    if isinstance(other, RollOutcome):\n        return bool(__ne__(self.value, other.value))\n    else:\n        return super().__ne__(other)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__neg__","title":"<code>__neg__() -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __neg__(self) -&gt; RollOutcome:\n    return self.umap(__neg__)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__or__","title":"<code>__or__(other: Union['RollOutcome', SupportsInt]) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\n# TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\ndef __or__(self, other: Union[\"RollOutcome\", SupportsInt]) -&gt; RollOutcome:\n    try:\n        if isinstance(other, SupportsInt):\n            other = as_int(other)\n\n        return self.map(__or__, other)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__pos__","title":"<code>__pos__() -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __pos__(self) -&gt; RollOutcome:\n    return self.umap(__pos__)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__pow__","title":"<code>__pow__(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __pow__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    try:\n        return self.map(__pow__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__radd__","title":"<code>__radd__(other: RealLike) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __radd__(self, other: RealLike) -&gt; RollOutcome:\n    try:\n        return self.rmap(other, __add__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__rand__","title":"<code>__rand__(other: SupportsInt) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rand__(self, other: SupportsInt) -&gt; RollOutcome:\n    try:\n        return self.rmap(as_int(other), __and__)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>    @beartype\n    def __repr__(self) -&gt; str:\n        return f\"\"\"{type(self).__name__}(\n  value={repr(self.value)},\n  sources=({_seq_repr(self.sources)}),\n)\"\"\"\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__rfloordiv__","title":"<code>__rfloordiv__(other: RealLike) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rfloordiv__(self, other: RealLike) -&gt; RollOutcome:\n    try:\n        return self.rmap(other, __floordiv__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__rmod__","title":"<code>__rmod__(other: RealLike) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rmod__(self, other: RealLike) -&gt; RollOutcome:\n    try:\n        return self.rmap(other, __mod__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__rmul__","title":"<code>__rmul__(other: RealLike) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rmul__(self, other: RealLike) -&gt; RollOutcome:\n    try:\n        return self.rmap(other, __mul__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__ror__","title":"<code>__ror__(other: SupportsInt) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __ror__(self, other: SupportsInt) -&gt; RollOutcome:\n    try:\n        return self.rmap(as_int(other), __or__)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__rpow__","title":"<code>__rpow__(other: RealLike) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rpow__(self, other: RealLike) -&gt; RollOutcome:\n    try:\n        return self.rmap(other, __pow__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__rsub__","title":"<code>__rsub__(other: RealLike) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rsub__(self, other: RealLike) -&gt; RollOutcome:\n    try:\n        return self.rmap(other, __sub__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__rtruediv__","title":"<code>__rtruediv__(other: RealLike) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rtruediv__(self, other: RealLike) -&gt; RollOutcome:\n    try:\n        return self.rmap(other, __truediv__)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__rxor__","title":"<code>__rxor__(other: SupportsInt) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __rxor__(self, other: SupportsInt) -&gt; RollOutcome:\n    try:\n        return self.rmap(as_int(other), __xor__)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__sub__","title":"<code>__sub__(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __sub__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    try:\n        return self.map(__sub__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__truediv__","title":"<code>__truediv__(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef __truediv__(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    try:\n        return self.map(__truediv__, other)\n    except NotImplementedError:\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.__xor__","title":"<code>__xor__(other: Union['RollOutcome', SupportsInt]) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\n# TODO(posita): See &lt;https://github.com/beartype/beartype/issues/152&gt;\ndef __xor__(self, other: Union[\"RollOutcome\", SupportsInt]) -&gt; RollOutcome:\n    try:\n        if isinstance(other, SupportsInt):\n            other = as_int(other)\n\n        return self.map(__xor__, other)\n    except (NotImplementedError, TypeError):\n        return NotImplemented\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.adopt","title":"<code>adopt(sources: Iterable['RollOutcome'] = (), coalesce_mode: CoalesceMode = CoalesceMode.REPLACE) -&gt; RollOutcome</code>","text":"<p>Creates and returns a new roll outcome identical to this roll outcome, but with sources replacing or appended to this roll outcome\u2019s sources in accordance with coalesce_mode.</p> <pre><code>&gt;&gt;&gt; from dyce.r import CoalesceMode\n&gt;&gt;&gt; orig = RollOutcome(1, sources=(RollOutcome(2),)) ; orig\nRollOutcome(\n  value=1,\n  sources=(\n    RollOutcome(\n      value=2,\n      sources=(),\n    ),\n  ),\n)\n&gt;&gt;&gt; orig.adopt((RollOutcome(3),), coalesce_mode=CoalesceMode.REPLACE)\nRollOutcome(\n  value=1,\n  sources=(\n    RollOutcome(\n      value=3,\n      sources=(),\n    ),\n  ),\n)\n&gt;&gt;&gt; orig.adopt((RollOutcome(3),), coalesce_mode=CoalesceMode.APPEND)\nRollOutcome(\n  value=1,\n  sources=(\n    RollOutcome(\n      value=2,\n      sources=(),\n    ),\n    RollOutcome(\n      value=3,\n      sources=(),\n    ),\n  ),\n)\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef adopt(\n    self,\n    sources: Iterable[\"RollOutcome\"] = (),\n    coalesce_mode: CoalesceMode = CoalesceMode.REPLACE,\n) -&gt; RollOutcome:\nr\"\"\"\n    Creates and returns a new roll outcome identical to this roll outcome, but with\n    *sources* replacing or appended to this roll outcome\u2019s sources in accordance\n    with *coalesce_mode*.\n\n    ``` python\n    &gt;&gt;&gt; from dyce.r import CoalesceMode\n    &gt;&gt;&gt; orig = RollOutcome(1, sources=(RollOutcome(2),)) ; orig\n    RollOutcome(\n      value=1,\n      sources=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n      ),\n    )\n    &gt;&gt;&gt; orig.adopt((RollOutcome(3),), coalesce_mode=CoalesceMode.REPLACE)\n    RollOutcome(\n      value=1,\n      sources=(\n        RollOutcome(\n          value=3,\n          sources=(),\n        ),\n      ),\n    )\n    &gt;&gt;&gt; orig.adopt((RollOutcome(3),), coalesce_mode=CoalesceMode.APPEND)\n    RollOutcome(\n      value=1,\n      sources=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n        RollOutcome(\n          value=3,\n          sources=(),\n        ),\n      ),\n    )\n\n    ```\n    \"\"\"\n    if coalesce_mode is CoalesceMode.REPLACE:\n        adopted_sources = sources\n    elif coalesce_mode is CoalesceMode.APPEND:\n        adopted_sources = chain(self.sources, sources)\n    else:\n        assert False, f\"unrecognized substitution mode {self.coalesce_mode!r}\"\n\n    adopted_roll_outcome = type(self)(self.value, adopted_sources)\n    adopted_roll_outcome._roll = self._roll\n\n    return adopted_roll_outcome\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.eq","title":"<code>eq(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef eq(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    if isinstance(other, RollOutcome):\n        return type(self)(bool(__eq__(self, other)), sources=(self, other))\n    elif self.value is not None:\n        return type(self)(bool(__eq__(self.value, other)), sources=(self,))\n    else:\n        raise ValueError(f\"unable to compare {self} to {other}\")\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.euthanize","title":"<code>euthanize() -&gt; RollOutcome</code>","text":"<p>Shorthand for <code>self.umap(lambda operand: None)</code>.</p> <pre><code>&gt;&gt;&gt; two = RollOutcome(2)\n&gt;&gt;&gt; two.euthanize()\nRollOutcome(\n  value=None,\n  sources=(\n    RollOutcome(\n      value=2,\n      sources=(),\n    ),\n  ),\n)\n</code></pre> <p>See the <code>umap</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef euthanize(self) -&gt; RollOutcome:\nr\"\"\"\n    Shorthand for ``#!python self.umap(lambda operand: None)``.\n\n    ``` python\n    &gt;&gt;&gt; two = RollOutcome(2)\n    &gt;&gt;&gt; two.euthanize()\n    RollOutcome(\n      value=None,\n      sources=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n      ),\n    )\n\n    ```\n\n    See the [``umap`` method][dyce.r.RollOutcome.umap].\n    \"\"\"\n\n    def _euthanize(operand: Optional[RealLike]) -&gt; None:\n        pass\n\n    return self.umap(_euthanize)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.ge","title":"<code>ge(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef ge(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    if isinstance(other, RollOutcome):\n        return type(self)(bool(__ge__(self, other)), sources=(self, other))\n    elif self.value is not None:\n        return type(self)(bool(__ge__(self.value, other)), sources=(self,))\n    else:\n        raise ValueError(f\"unable to compare {self} to {other}\")\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.gt","title":"<code>gt(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef gt(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    if isinstance(other, RollOutcome):\n        return type(self)(bool(__gt__(self, other)), sources=(self, other))\n    elif self.value is not None:\n        return type(self)(bool(__gt__(self.value, other)), sources=(self,))\n    else:\n        raise ValueError(f\"unable to compare {self} to {other}\")\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.is_even","title":"<code>is_even() -&gt; RollOutcome</code>","text":"<p>Shorthand for: <code>self.umap(dyce.types.is_even)</code>.</p> <p>See the <code>umap</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef is_even(self) -&gt; RollOutcome:\nr\"\"\"\n    Shorthand for: ``#!python self.umap(dyce.types.is_even)``.\n\n    See the [``umap`` method][dyce.r.RollOutcome.umap].\n    \"\"\"\n    return self.umap(is_even)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.is_odd","title":"<code>is_odd() -&gt; RollOutcome</code>","text":"<p>Shorthand for: <code>self.umap(dyce.types.is_even)</code>.</p> <p>See the <code>umap</code> method.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef is_odd(self) -&gt; RollOutcome:\nr\"\"\"\n    Shorthand for: ``#!python self.umap(dyce.types.is_even)``.\n\n    See the [``umap`` method][dyce.r.RollOutcome.umap].\n    \"\"\"\n    return self.umap(is_odd)\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.le","title":"<code>le(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef le(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    if isinstance(other, RollOutcome):\n        return type(self)(bool(__le__(self, other)), sources=(self, other))\n    elif self.value is not None:\n        return type(self)(bool(__le__(self.value, other)), sources=(self,))\n    else:\n        raise ValueError(f\"unable to compare {self} to {other}\")\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.lt","title":"<code>lt(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef lt(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    if isinstance(other, RollOutcome):\n        return type(self)(bool(__lt__(self, other)), sources=(self, other))\n    elif self.value is not None:\n        return type(self)(bool(__lt__(self.value, other)), sources=(self,))\n    else:\n        raise ValueError(f\"unable to compare {self} to {other}\")\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.map","title":"<code>map(bin_op: _BinaryOperatorT, right_operand: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"<p>Applies bin_op to the value of this roll outcome as the left operand and right_operand as the right. Shorthands exist for many arithmetic operators and comparators.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; two = RollOutcome(2)\n&gt;&gt;&gt; two.map(operator.__pow__, 10)\nRollOutcome(\n  value=1024,\n  sources=(\n    RollOutcome(\n      value=2,\n      sources=(),\n    ),\n  ),\n)\n&gt;&gt;&gt; two.map(operator.__pow__, 10) == two ** 10\nTrue\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef map(\n    self,\n    bin_op: _BinaryOperatorT,\n    right_operand: _RollOutcomeOperandT,\n) -&gt; RollOutcome:\nr\"\"\"\n    Applies *bin_op* to the value of this roll outcome as the left operand and\n    *right_operand* as the right. Shorthands exist for many arithmetic operators and\n    comparators.\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; two = RollOutcome(2)\n    &gt;&gt;&gt; two.map(operator.__pow__, 10)\n    RollOutcome(\n      value=1024,\n      sources=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n      ),\n    )\n    &gt;&gt;&gt; two.map(operator.__pow__, 10) == two ** 10\n    True\n\n    ```\n    \"\"\"\n    if isinstance(right_operand, RollOutcome):\n        sources: tuple[RollOutcome, ...] = (self, right_operand)\n        right_operand_value: Optional[RealLike] = right_operand.value\n    else:\n        sources = (self,)\n        right_operand_value = right_operand\n\n    if isinstance(right_operand_value, RealLike):\n        return type(self)(bin_op(self.value, right_operand_value), sources)\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.ne","title":"<code>ne(other: _RollOutcomeOperandT) -&gt; RollOutcome</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef ne(self, other: _RollOutcomeOperandT) -&gt; RollOutcome:\n    if isinstance(other, RollOutcome):\n        return type(self)(bool(__ne__(self, other)), sources=(self, other))\n    else:\n        return type(self)(bool(__ne__(self.value, other)), sources=(self,))\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.rmap","title":"<code>rmap(left_operand: RealLike, bin_op: _BinaryOperatorT) -&gt; RollOutcome</code>","text":"<p>Analogous to the <code>map</code> method, but where the caller supplies left_operand.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; two = RollOutcome(2)\n&gt;&gt;&gt; two.rmap(10, operator.__pow__)\nRollOutcome(\n  value=100,\n  sources=(\n    RollOutcome(\n      value=2,\n      sources=(),\n    ),\n  ),\n)\n&gt;&gt;&gt; two.rmap(10, operator.__pow__) == 10 ** two\nTrue\n</code></pre> <p>Note</p> <p>The positions of left_operand and bin_op are different from <code>map</code> method. This is intentional and serves as a reminder of operand ordering.</p> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef rmap(self, left_operand: RealLike, bin_op: _BinaryOperatorT) -&gt; RollOutcome:\nr\"\"\"\n    Analogous to the [``map`` method][dyce.r.RollOutcome.map], but where the caller\n    supplies *left_operand*.\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; two = RollOutcome(2)\n    &gt;&gt;&gt; two.rmap(10, operator.__pow__)\n    RollOutcome(\n      value=100,\n      sources=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n      ),\n    )\n    &gt;&gt;&gt; two.rmap(10, operator.__pow__) == 10 ** two\n    True\n\n    ```\n\n    !!! note\n\n        The positions of *left_operand* and *bin_op* are different from\n        [``map`` method][dyce.r.RollOutcome.map]. This is intentional and serves as\n        a reminder of operand ordering.\n    \"\"\"\n    if isinstance(left_operand, RealLike):\n        return type(self)(bin_op(left_operand, self.value), sources=(self,))\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollOutcome.umap","title":"<code>umap(un_op: _UnaryOperatorT) -&gt; RollOutcome</code>","text":"<p>Applies un_op to the value of this roll outcome. Shorthands exist for many arithmetic operators and comparators.</p> <pre><code>&gt;&gt;&gt; import operator\n&gt;&gt;&gt; two_neg = RollOutcome(-2)\n&gt;&gt;&gt; two_neg.umap(operator.__neg__)\nRollOutcome(\n  value=2,\n  sources=(\n    RollOutcome(\n      value=-2,\n      sources=(),\n    ),\n  ),\n)\n&gt;&gt;&gt; two_neg.umap(operator.__neg__) == -two_neg\nTrue\n</code></pre> Source code in <code>dyce/r.py</code> <pre><code>@beartype\ndef umap(\n    self,\n    un_op: _UnaryOperatorT,\n) -&gt; RollOutcome:\nr\"\"\"\n    Applies *un_op* to the value of this roll outcome. Shorthands exist for many\n    arithmetic operators and comparators.\n\n    ``` python\n    &gt;&gt;&gt; import operator\n    &gt;&gt;&gt; two_neg = RollOutcome(-2)\n    &gt;&gt;&gt; two_neg.umap(operator.__neg__)\n    RollOutcome(\n      value=2,\n      sources=(\n        RollOutcome(\n          value=-2,\n          sources=(),\n        ),\n      ),\n    )\n    &gt;&gt;&gt; two_neg.umap(operator.__neg__) == -two_neg\n    True\n\n    ```\n    \"\"\"\n    return type(self)(un_op(self.value), sources=(self,))\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollWalkerVisitor","title":"<code>RollWalkerVisitor</code>","text":"<p>Experimental</p> <p>This class (and its descendants) should be considered experimental and may change or disappear in future versions.</p> <p>Abstract visitor interface for use with <code>walk</code> called for each <code>Roll</code> object found.</p> Source code in <code>dyce/r.py</code> <pre><code>class RollWalkerVisitor:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This class (and its descendants) should be considered experimental and may\n        change or disappear in future versions.\n\n    Abstract visitor interface for use with [``walk``][dyce.r.walk] called for each\n    [``Roll`` object][dyce.r.Roll] found.\n    \"\"\"\n    __slots__: Any = ()\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @abstractmethod\n    def on_roll(self, roll: Roll, parents: Iterator[Roll]) -&gt; None:\n        ...\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollWalkerVisitor.__slots__","title":"<code>__slots__: Any = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.RollWalkerVisitor.on_roll","title":"<code>on_roll(roll: Roll, parents: Iterator[Roll]) -&gt; None</code>  <code>abstractmethod</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@abstractmethod\ndef on_roll(self, roll: Roll, parents: Iterator[Roll]) -&gt; None:\n    ...\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollerWalkerVisitor","title":"<code>RollerWalkerVisitor</code>","text":"<p>Experimental</p> <p>This class (and its descendants) should be considered experimental and may change or disappear in future versions.</p> <p>Abstract visitor interface for use with <code>walk</code> called for each <code>R</code> object found.</p> Source code in <code>dyce/r.py</code> <pre><code>class RollerWalkerVisitor:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This class (and its descendants) should be considered experimental and may\n        change or disappear in future versions.\n\n    Abstract visitor interface for use with [``walk``][dyce.r.walk] called for each\n    [``R`` object][dyce.r.R] found.\n    \"\"\"\n    __slots__: Any = ()\n\n    # ---- Overrides -------------------------------------------------------------------\n\n    @abstractmethod\n    def on_roller(self, r: R, parents: Iterator[R]) -&gt; None:\n        ...\n</code></pre>"},{"location":"dyce.r/#dyce.r.RollerWalkerVisitor.__slots__","title":"<code>__slots__: Any = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"dyce.r/#dyce.r.RollerWalkerVisitor.on_roller","title":"<code>on_roller(r: R, parents: Iterator[R]) -&gt; None</code>  <code>abstractmethod</code>","text":"Source code in <code>dyce/r.py</code> <pre><code>@abstractmethod\ndef on_roller(self, r: R, parents: Iterator[R]) -&gt; None:\n    ...\n</code></pre>"},{"location":"dyce.r/#dyce.r.walk","title":"<code>walk(root: Union[Roll, R, RollOutcome], visitor: Union[RollWalkerVisitor, RollerWalkerVisitor, RollOutcomeWalkerVisitor]) -&gt; None</code>","text":"<p>Experimental</p> <p>This function should be considered experimental and may change or disappear in future versions.</p> <p>Walks through root, calling visitor for each matching object. No ordering guarantees are made.</p> <p>On the current implementation</p> <p><code>walk</code> performs a breadth-first traversal of root, assembling a secondary index of referencing objects (parents). Visitors are called back grouped first by type, then by order encountered.</p> Source code in <code>dyce/r.py</code> <pre><code>@experimental\n@beartype\ndef walk(\n    root: Union[Roll, R, RollOutcome],\n    visitor: Union[RollWalkerVisitor, RollerWalkerVisitor, RollOutcomeWalkerVisitor],\n) -&gt; None:\nr\"\"\"\n    !!! warning \"Experimental\"\n\n        This function should be considered experimental and may change or disappear in\n        future versions.\n\n    Walks through *root*, calling *visitor* for each matching object. No ordering\n    guarantees are made.\n\n    !!! info \"On the current implementation\"\n\n        ``#!python walk`` performs a breadth-first traversal of *root*, assembling a\n        secondary index of referencing objects (parents). Visitors are called back\n        grouped first by type, then by order encountered.\n    \"\"\"\n    rolls: dict[int, Roll] = {}\n    rollers: dict[int, R] = {}\n    roll_outcomes: dict[int, RollOutcome] = {}\n    roll_parent_ids: defaultdict[int, set[int]] = defaultdict(set)\n    roller_parent_ids: defaultdict[int, set[int]] = defaultdict(set)\n    roll_outcome_parent_ids: defaultdict[int, set[int]] = defaultdict(set)\n    queue = deque((root,))\n    roll: Roll\n    r: R\n    roll_outcome: RollOutcome\n\n    while queue:\n        obj = queue.popleft()\n\n        if isinstance(obj, Roll):\n            roll = obj\n\n            if id(roll) not in rolls:\n                rolls[id(roll)] = roll\n\n                queue.append(roll.r)\n\n                for i, roll_outcome in enumerate(roll):\n                    queue.append(roll_outcome)\n\n                for source_roll in roll.source_rolls:\n                    roll_parent_ids[id(source_roll)].add(id(roll))\n                    queue.append(source_roll)\n        elif isinstance(obj, R):\n            r = obj\n\n            if id(r) not in rollers:\n                rollers[id(r)] = r\n\n                for source_r in r.sources:\n                    roller_parent_ids[id(source_r)].add(id(r))\n                    queue.append(source_r)\n        elif isinstance(obj, RollOutcome):\n            roll_outcome = obj\n\n            if id(roll_outcome) not in roll_outcomes:\n                roll_outcomes[id(roll_outcome)] = roll_outcome\n\n                for source_roll_outcome in roll_outcome.sources:\n                    roll_outcome_parent_ids[id(source_roll_outcome)].add(\n                        id(roll_outcome)\n                    )\n                    queue.append(source_roll_outcome)\n\n    if rolls and isinstance(visitor, RollWalkerVisitor):\n        for roll_id, roll in rolls.items():\n            visitor.on_roll(roll, (rolls[i] for i in roll_parent_ids[roll_id]))\n\n    if rollers and isinstance(visitor, RollerWalkerVisitor):\n        for r_id, r in rollers.items():\n            visitor.on_roller(r, (rollers[i] for i in roller_parent_ids[r_id]))\n\n    if roll_outcomes and isinstance(visitor, RollOutcomeWalkerVisitor):\n        for roll_outcome_id, roll_outcome in roll_outcomes.items():\n            visitor.on_roll_outcome(\n                roll_outcome,\n                (roll_outcomes[i] for i in roll_outcome_parent_ids[roll_outcome_id]),\n            )\n</code></pre>"},{"location":"license/","title":"License and credits","text":""},{"location":"license/#the-mit-license-mit","title":"The MIT License (MIT)","text":"<p>Copyright \u00a9 2015-2023 Matt Bogosian (@posita).</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"license/#contributors","title":"Contributors","text":"<p>The following individuals or entities have contributed to this software:</p> <ul> <li>Matt Bogosian; GitHub \u2013 @posita</li> <li>Ilmari Karonen</li> </ul> <p>By adding your name to this list, you grant a nonexclusive, perpetual license to your contributions to this software under the same terms as its license, above. Further, you warrant that your contributions to this software are exclusively your own creations and no one else has any superior right or claim to them. Finally, you agree to indemnify and hold harmless this software\u2019s owner against any colorable claim of infringement by a third party for this software\u2019s owner\u2019s otherwise lawful use of your contribution, whether or not such use was contemplated by you at the time you made it.</p>"},{"location":"notes/","title":"Release notes","text":""},{"location":"notes/#dyce-release-notes","title":"<code>dyce</code> release notes","text":""},{"location":"notes/#061","title":"0.6.1","text":"<ul> <li>Fixes <code>P.total</code> to return <code>1</code> for empty pools, consistent with the empty product.   (See this explanation).</li> <li>Renames <code>dyce.evaluation._LimitT</code> to <code>dyce.evaluation.LimitT</code>.</li> <li>Fixes issues pertaining to histograms with zero totals after allowing outcomes with zero counts in non-normalized <code>H</code> objects.</li> <li>Fixes issue that would lead to incorrect results when making certain arbitrary selections with heterogeneous pools (e.g., with <code>P.rolls_with_counts</code>).</li> </ul>"},{"location":"notes/#060","title":"0.6.0","text":"<ul> <li>Now requires <code>numerary~=0.4.3</code>.</li> <li>Adds the <code>expandable</code> decorator as well as the <code>foreach</code> and <code>explode</code> convenience functions.</li> <li>Deprecates <code>P.foreach</code>, <code>H.foreach</code>, and <code>H.substitute</code>.</li> <li>Allows outcomes with zero counts in non-normalized <code>H</code> objects.   Outcomes with zero counts are dropped when calling <code>H.lowest_terms</code>.   Adds the <code>H.zero_fill</code> convenience method.</li> <li>Fixes memoization in Risus multi-round combat translation.</li> <li>Migrates from <code>setuptools_scm</code> to <code>versioningit</code> for more flexible version number formatting.</li> <li>Allows deployments to PyPI from CI based on tags.</li> <li>Uses JupyterLite instead of Binder for examples.</li> <li>Refactors <code>P.is_homogeneous</code> property into a similarly-named method and adds the <code>P.total</code> method property.</li> <li>Removes <code>H.order_stat_func_for_n</code> and instead caches order stat functions for <code>n</code> inside <code>H.order_stat_for_n_at_pos</code>.</li> </ul>"},{"location":"notes/#052","title":"0.5.2","text":"<ul> <li>Updates binder links that fix requirements ranges.</li> </ul>"},{"location":"notes/#051","title":"0.5.1","text":"<ul> <li>Fixes broken binder links in docs.</li> <li>Adds the <code>precision_limit</code> argument to <code>H.substitute</code> and <code>H.explode</code>.</li> </ul>"},{"location":"notes/#050","title":"0.5.0","text":"<ul> <li>Breaks <code>dyce.viz</code> out into <code>anydyce</code>.</li> <li>Removes use of <code>numerary.types.\u2026SCU</code> types.</li> <li>Adds the <code>H.foreach</code> and <code>P.foreach</code> class methods.</li> <li>Migrates <code>resolve_dependent_probability</code> to the <code>H.foreach</code> class method.</li> </ul>"},{"location":"notes/#045","title":"0.4.5","text":"<ul> <li>Fixes this bullshit (no, really, I\u2019m serious this time).</li> <li>Adds <code>FilterRoller</code>.</li> <li>Adds <code>SubstitutionRoller</code>.</li> </ul>"},{"location":"notes/#044","title":"0.4.4","text":"<ul> <li>Removes <code>\u2026_gh.png</code> hack now that this dumpster fire is at least partially resolved.</li> <li>Refines Tension Pool example.</li> <li>Adds Ironsworn example.</li> <li>Removes faulty (correctly-derived, but misapplied) math in Risus \u201cEvens Up\u201d example.</li> <li>Adds detail around dependent probabilities.</li> <li>Adds experimental <code>dyce.h.resolve_dependent_probability</code> function.</li> </ul>"},{"location":"notes/#043","title":"0.4.3","text":"<ul> <li>Removes dependencies on deprecated <code>numerary.types.\u2026SCT</code> tuples</li> <li>Adds Angry GM Tension Pool mechanic translation.</li> </ul>"},{"location":"notes/#042","title":"0.4.2","text":"<ul> <li>Removes calls to <code>os.get_terminal_size</code> to retain utility in environments without terminals.   Fixes #5.   Thanks @sudo-simon!!</li> </ul>"},{"location":"notes/#041","title":"0.4.1","text":"<ul> <li>Splits out protocol checking into its own fancy library: <code>numerary</code>!</li> <li>Is now available on PyPI as <code>dyce</code>_, thanks to the generosity of David Eyk!</li> <li>Introduces experimental generic <code>walk</code> function and supporting visitor data structures.</li> <li>Uses <code>pygraphviz</code> to automate class diagram generation.   (See the note on special considerations for regenerating class diagrams in the hacking quick start.)</li> <li>Introduces experimental use of <code>numpy</code> for RNG, if present.</li> <li>Migrates to using <code>pyproject.toml</code> and <code>setup.cfg</code>.</li> <li>Adds missing <code>py.typed</code> to ensure clients get type checking.   (Whoops.)</li> </ul>"},{"location":"notes/#040","title":"0.4.0","text":""},{"location":"notes/#breaking-changes","title":"Breaking changes","text":"<p>Warning</p> <p>The following changes are not backward compatible. Please review before upgrading.</p> <ul> <li>Renames <code>HAbleT</code> and <code>HAbleOpsMixin</code> to <code>HableT</code> and  <code>HableOpsMixin</code>.     Uses alternate spellings.</li> <li>Removes deprecated non-flattening unary operation methods <code>P.__neg__</code> and <code>P.__pos__</code>.     Uses, e.g., <code>P.umap(operator.__neg__)</code> or <code>P(-h for h in p)</code> instead.</li> <li>Removes deprecated synonym methods <code>H.even</code> and <code>H.odd</code>.     Uses <code>H.is_even</code> and <code>H.is_odd</code> instead.</li> <li>Removes deprecated synonym package <code>dyce.plt</code>.     Uses <code>dyce.viz</code> instead.</li> <li> <p>Removes special case handling of <code>H({})</code> for addition and subtraction.     Check for code that relied on, e.g., <code>h + H({})</code> resolving to <code>h</code>.     It is probably not correct.     If the behavior is desired, consider eliminating empty histograms before performing calculations.     E.G., <code>h1 + h2 if h2 else h1</code>.</p> <p>See also the <code>sum_h</code> function, which ensures the result is always a histogram:</p> <pre><code>&gt;&gt;&gt; from dyce.h import sum_h\n&gt;&gt;&gt; sum(())\n0\n&gt;&gt;&gt; sum_h(())\nH({})\n</code></pre> <p>Note, however, that sums including empty histograms will be always result in empty histograms:</p> <pre><code>&gt;&gt;&gt; from dyce import H\n&gt;&gt;&gt; hs = (H(6), H(6), H(6), H({}))\n&gt;&gt;&gt; sum_h(hs)\nH({})\n</code></pre> <p>If a different result was desired, adapting our advice from above would yield something like:</p> <pre><code>&gt;&gt;&gt; sum_h(h for h in hs if h)\nH({3: 1, 4: 3, 5: 6, 6: 10, ..., 16: 6, 17: 3, 18: 1})\n</code></pre> </li> </ul>"},{"location":"notes/#other-changes","title":"Other changes","text":"<ul> <li>Documentation overhaul including augmented examples and reorganized images and JavaScript.</li> <li>Fixes <code>H({}).format()</code> bug.</li> <li>Adds <code>beartype</code> runtime type checking.</li> <li>Maintains support for Python 3.7 (for now).</li> </ul>"},{"location":"notes/#032","title":"0.3.2","text":"<ul> <li>Emergency release to cover up address this embarrassment typo. \ud83d\ude2c\ud83d\ude05</li> </ul>"},{"location":"notes/#031","title":"0.3.1","text":"<ul> <li>Adds these release notes.</li> <li>Boosts <code>isinstance</code> performance with <code>dyce</code>\u2019s proprietary numeric <code>Protocol</code>s.</li> <li>Reinstates support for Python 3.7 (for now).</li> <li>Adds <code>H.is_even</code> and <code>H.is_odd</code>.</li> <li>Deprecates synonym methods <code>H.even</code> and <code>H.odd</code>.</li> <li>Introduces experimental <code>H.total</code> property.</li> <li>Removes incorrectly non-flattening unary operation methods <code>P.__abs__</code> and <code>P.__invert__</code>.</li> <li>Deprecates non-flattening unary operation methods <code>P.__neg__</code> and <code>P.__pos__</code>.</li> <li>Renames experimental <code>P.homogeneous</code> property to <code>P.is_homogeneous</code>.</li> <li>Introduces experimental <code>R</code> and <code>Roll</code> primitives.</li> <li>Removes <code>coerce</code> parameter from <code>H.map</code>, <code>H.rmap</code>, and <code>H.umap</code>.</li> <li>Renames <code>dyce.plt</code> to <code>dyce.viz</code>.</li> <li>Deprecates synonym package <code>dyce.plt</code>.</li> </ul>"},{"location":"notes/#030","title":"0.3.0","text":"<p><code>dyce</code> goes beta! Non-experimental features should be considered stable.</p>"},{"location":"rollin/","title":"Rollin\u2019 with rollers and rolls","text":"<p>Experimental</p> <p>This functionality should be considered experimental. Be warned that future release may introduce incompatibilities or remove it altogether. Feedback, suggestions, and contributions are welcome and appreciated.</p> <p><code>dyce</code> provides additional primitives for generating and inspecting rolls of weighted random outcomes without requiring the overhead of enumeration.</p> <pre><code>&gt;&gt;&gt; from dyce import R\n</code></pre> <p><code>R</code> objects represent rollers. Rollers produce <code>Roll</code> objects. <code>Roll</code> objects are sequences of <code>RollOutcome</code> objects, which represent weighted random values.</p> <p>Each object can be a node in a tree-like structure. Rollers, for example, can represent scalars, histograms, pools, operators, etc., and can be assembled into trees representing more complex calculations. Rolls can derive from other rolls, forming trees that are generally analogous to the roller trees that generated them. Similarly, roll outcomes can derive from other roll outcomes.</p> <p>The simplest roller we can create represents a single value. Each roll it generates has that value as its sole outcome. Let\u2019s see what that looks like (now with tasty entity relationship diagrams).</p> <p> </p> <pre><code>&gt;&gt;&gt; from dyce.r import ValueRoller\n&gt;&gt;&gt; r_1 = ValueRoller(1)\n&gt;&gt;&gt; roll = r_1.roll()\n&gt;&gt;&gt; roll.total()\n1\n&gt;&gt;&gt; tuple(roll.outcomes())\n(1,)\n&gt;&gt;&gt; roll\nRoll(\n  r=ValueRoller(value=1, annotation=''),\n  roll_outcomes=(\n    RollOutcome(\n      value=1,\n      sources=(),\n    ),\n  ),\n  source_rolls=(),\n)\n</code></pre> <p>Hopefully, that\u2019s relatively straightforward. Let\u2019s look at some more substantial examples.</p>"},{"location":"rollin/#emulating-a-hundred-sided-die-using-two-ten-sided-dice","title":"Emulating a hundred-sided die using two ten-sided dice","text":"<p>In many games it is common to emulate a hundred-sided die using a \u201cones\u201d ten-sided die (faces numbered \\([{ {0}, {1}, \\ldots , {9} }]\\)) and a \u201ctens\u201d ten-sided die (faces numbered \\([{ {00}, {10}, \\ldots , {90} }]\\)). Let\u2019s try to model that as a roller and use it to generate a roll.</p> <p>We start by creating two histograms1 representing our two ten-sided dice (<code>d00</code> for our \u201ctens\u201d die and <code>d10</code> for our \u201cones\u201c die).</p> <pre><code>&gt;&gt;&gt; from dyce import H\n&gt;&gt;&gt; d10 = H(10) - 1\n&gt;&gt;&gt; d00 = 10 * d10\n</code></pre> <p>Next, we create a roller using the <code>R.from_values</code> class method.</p> <pre><code>&gt;&gt;&gt; r_d100 = R.from_values(d00, d10) ; r_d100\nPoolRoller(\n  sources=(\n    ValueRoller(value=H({0: 1, 10: 1, 20: 1, 30: 1, 40: 1, 50: 1, 60: 1, 70: 1, 80: 1, 90: 1}), annotation=''),\n    ValueRoller(value=H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}), annotation=''),\n  ),\n  annotation='',\n)\n</code></pre> <p>Well, wouldya look at that? That durned class method created a whole roller tree, which is actually three rollers.</p> <ol> <li>One <code>ValueRoller</code> for the <code>d00</code> histogram;</li> <li>Another for the <code>d10</code> histogram; and</li> <li>A <code>PoolRoller</code> for aggregating them both.</li> </ol> <p>Tip</p> <p>We could have also composed an identical tree using roller implementations from <code>dyce.r</code> instead of the <code>R.from_values</code> convenience method.</p> <pre><code>&gt;&gt;&gt; from dyce.r import PoolRoller, ValueRoller\n&gt;&gt;&gt; r_d100 == PoolRoller(sources=(ValueRoller(d00), ValueRoller(d10)))\nTrue\n</code></pre> <p>Let\u2019s use our new roller to create a roll and retrieve its total.</p> <pre><code>&gt;&gt;&gt; roll = r_d100.roll()\n&gt;&gt;&gt; roll.total()\n69\n</code></pre> <p>No surprises there. Let\u2019s dig a little deeper and ask for the roll\u2019s outcome values.</p> <pre><code>&gt;&gt;&gt; tuple(roll.outcomes())\n(60, 9)\n</code></pre> <p>As we mentioned before, the top level of our roller tree is a <code>PoolRoller</code>, which aggregates (or \u201cpools\u201d) rolls from its sources. For our roll, the aggregated outcomes are <code>60</code> are <code>9</code>.</p> <p>What does our pooled roll look like?</p> <pre><code>&gt;&gt;&gt; roll\nRoll(\n  r=PoolRoller(\n    sources=(\n      ValueRoller(value=H({0: 1, 10: 1, 20: 1, 30: 1, 40: 1, 50: 1, 60: 1, 70: 1, 80: 1, 90: 1}), annotation=''),\n      ValueRoller(value=H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}), annotation=''),\n    ),\n    annotation='',\n  ),\n  roll_outcomes=(\n    RollOutcome(\n      value=60,\n      sources=(),\n    ),\n    RollOutcome(\n      value=9,\n      sources=(),\n    ),\n  ),\n  source_rolls=(\n    Roll(\n      r=ValueRoller(value=H({0: 1, 10: 1, 20: 1, 30: 1, 40: 1, 50: 1, 60: 1, 70: 1, 80: 1, 90: 1}), annotation=''),\n      roll_outcomes=(\n        RollOutcome(\n          value=60,\n          sources=(),\n        ),\n      ),\n      source_rolls=(),\n    ),\n    Roll(\n      r=ValueRoller(value=H({0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1}), annotation=''),\n      roll_outcomes=(\n        RollOutcome(\n          value=9,\n          sources=(),\n        ),\n      ),\n      source_rolls=(),\n    ),\n  ),\n)\n</code></pre> <p> </p> <p>Let\u2019s break that down so it doesn\u2019t feel like trying to drink from a fire hose.</p> <p>Calling the <code>R.roll</code> method on our <code>PoolRoller</code> resulted in a <code>Roll</code> object. Actually, it resulted in a roll tree (analogous to our roller tree). Each <code>Roll</code> object in that tree has:</p> <ul> <li>A reference to the <code>R</code> object in the roller tree that generated it, retrieved via its <code>r</code> property;</li> <li>Zero or more <code>RollOutcome</code> objects, retrieved by accessing the roll as a sequence (i.e., via <code>__getitem__</code>, <code>__len__</code>); and</li> <li>Zero or more source rolls, retrieved via its <code>source_rolls</code> property.</li> </ul> <p>The <code>RollOutcome</code> objects also form trees (in our case, simple ones). Each one has:</p> <ul> <li>A single value, retrieved via its <code>value</code> property;</li> <li>Zero or more source outcomes from which the value was derived, retrieved via its <code>sources</code> property; and</li> <li>A reference back to the roll that generated it, retrieved via its <code>source_roll</code> property (omitted from the diagram for the sake of readability).</li> </ul> <p>Tip</p> <p>You might be wondering to yourself, \u201cSelf, one wonders, can one have a pool of pools?\u201d Such questions command the response, \u201cWhy the heck not? Try it!\u201d</p> <pre><code>&gt;&gt;&gt; two_r_d100s = PoolRoller(sources=(r_d100, r_d100))\n&gt;&gt;&gt; roll_two = two_r_d100s.roll()\n&gt;&gt;&gt; roll_two.total()\n63\n&gt;&gt;&gt; tuple(roll_two.outcomes())\n(40, 2, 20, 1)\n</code></pre> <p>So the answer is a resounding, \u201cOf course. What devious entity would prohibit such a thing? Please identify that creature so we may flog it until it achieves enlightenment,\u201d \u201cYes.\u201d</p>"},{"location":"rollin/#composing-rollers-with-arithmetic","title":"Composing rollers with arithmetic","text":"<p>Rollers support arithmetic operators.</p> <pre><code>&gt;&gt;&gt; d12 = H(12)\n&gt;&gt;&gt; r_d12_add_4 = ValueRoller(d12) + 4 ; r_d12_add_4\nBinarySumOpRoller(\n  bin_op=&lt;built-in function add&gt;,\n  left_source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1}), annotation=''),\n  right_source=ValueRoller(value=4, annotation=''),\n  annotation='',\n)\n&gt;&gt;&gt; r_d12_add_4.roll()\nRoll(\n  r=BinarySumOpRoller(...),\n  roll_outcomes=(\n    RollOutcome(\n      value=11,\n      sources=(\n        RollOutcome(\n          value=7,\n          sources=(),\n        ),\n        RollOutcome(\n          value=4,\n          sources=(),\n        ),\n      ),\n    ),\n  ),\n  source_rolls=(\n    Roll(\n      r=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1}), annotation=''),\n      roll_outcomes=(\n        RollOutcome(\n          value=7,\n          sources=(),\n        ),\n      ),\n      source_rolls=(),\n    ),\n    Roll(\n      r=ValueRoller(value=4, annotation=''),\n      roll_outcomes=(\n        RollOutcome(\n          value=4,\n          sources=(),\n        ),\n      ),\n      source_rolls=(),\n    ),\n  ),\n)\n</code></pre> <p> </p>"},{"location":"rollin/#dropping-dice-from-prior-rolls-keeping-the-best-three-of-3d6-and-1d8","title":"Dropping dice from prior rolls \u2013 keeping the best three of <code>3d6</code> and <code>1d8</code>","text":"<p>The trifecta of roller trees, roll trees, and outcome trees might appear complicated or redundant. Everything serves a purpose.2</p> <p>Consider excluding (or \u201cdropping\u201d) dice from a roll. How would we account for that? Let\u2019s see how to generate rolls that keep the best three outcomes from rolling three six-sided dice and one eight-sided die.</p> <p>We start by using the <code>R.from_value</code> class method to create <code>ValueRoller</code>s for histograms representing our six- and eight-sided dice.</p> <pre><code>&gt;&gt;&gt; d6 = H(6)\n&gt;&gt;&gt; d8 = H(8)\n&gt;&gt;&gt; r_d6 = R.from_value(d6) ; r_d6\nValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation='')\n&gt;&gt;&gt; r_d8 = R.from_value(d8) ; r_d8\nValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}), annotation='')\n</code></pre> <p>For homogeneous pools, we can use the matrix multiplication operator.</p> <pre><code>&gt;&gt;&gt; r_3d6 = 3@r_d6 ; r_3d6\nRepeatRoller(\n  n=3,\n  source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n  annotation='',\n)\n</code></pre> <p>Finally, we\u2019ll create a <code>SelectionRoller</code> by calling the <code>R.select_from_sources</code> method on our other rollers.</p> <pre><code>&gt;&gt;&gt; r_best_3_of_3d6_d8 = R.select_from_sources((slice(1, None),), r_3d6, r_d8) ; r_best_3_of_3d6_d8\nSelectionRoller(\n  which=(slice(1, None, None),),\n  sources=(\n    RepeatRoller(\n      n=3,\n      source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n      annotation='',\n    ),\n    ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}), annotation=''),\n  ),\n  annotation='',\n)\n</code></pre> <p>Oh boy! Aren\u2019t you super excited to try this thing out?</p> <pre><code>&gt;&gt;&gt; roll = r_best_3_of_3d6_d8.roll()\n&gt;&gt;&gt; tuple(roll.outcomes())\n(1, 5, 6)\n</code></pre> <p>There are indeed three values, despite starting with four dice. Given that the lowest value we see is a <code>1</code>, we might assume that the eliminated value is also a <code>1</code>. But, we all know what happens when one assumes.</p> <p> </p> <p>Recall that in roll trees, a roll may have references to other rolls (its \u201csource rolls\u201d) from which it derives. We should be able to get information about the dropped die by traversing that tree. Let\u2019s see if we can validate our assumption by looking at the outcomes from our roll\u2019s direct source.</p> <pre><code>&gt;&gt;&gt; from itertools import chain\n&gt;&gt;&gt; tuple(chain.from_iterable(source_roll.outcomes() for source_roll in roll.source_rolls))\n(6, 1, 1, 5)\n</code></pre> <p>Yup! We were right! There\u2019s the other <code>1</code>, plain as day. Our work here is do\u2014</p> <p>What? You want to know which die we eliminated? We can see that, too!</p> <pre><code>&gt;&gt;&gt; roll\nRoll(\n  r=SelectionRoller(\n    which=(slice(1, None, None),),\n    sources=(\n      RepeatRoller(\n        n=3,\n        source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n        annotation='',\n      ),\n      ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}), annotation=''),\n    ),\n    annotation='',\n  ),\n  roll_outcomes=(\n    ...\n</code></pre> <p>*snip* \u2702\ufe0f</p> <pre><code>  ),\n)\n</code></pre> <p>Oof. \u261d\ufe0f That was \u2026 a lot. Let\u2019s visualize!</p> <p> </p> <p>Holy entangled relationship diagrams, Batman! One thing you may notice about our top-level roll is that it has four outcomes. One of those kids is not like the others. Specifically, it has a <code>value</code> of <code>None</code>. That\u2019s our dropped outcome!</p> <pre><code>&gt;&gt;&gt; len(roll) == 4\nTrue\n&gt;&gt;&gt; roll[-1].value is None\nTrue\n&gt;&gt;&gt; tuple(roll_outcome.value for roll_outcome in roll)\n(1, 5, 6, None)\n</code></pre> <p>Info</p> <p>A roll outcome with a <code>value</code> of <code>None</code> is akin to a \u201ctombstone\u201d. It conveys one whose sources were present in immediately prior rolls but excluded from the current roll. Such roll outcomes must have at least one source.</p> <pre><code>&gt;&gt;&gt; from dyce.r import RollOutcome\n&gt;&gt;&gt; RollOutcome(value=None)\nTraceback (most recent call last):\n  ...\nValueError: value can only be None if sources is non-empty\n</code></pre> <p>The <code>RollOutcome.euthanize</code> method provides a convenient shorthand.</p> <pre><code>&gt;&gt;&gt; RollOutcome(42).euthanize()\nRollOutcome(\n  value=None,\n  sources=(\n    RollOutcome(\n      value=42,\n      sources=(),\n    ),\n  ),\n)\n</code></pre> <p>However, because such a roll signals its absence from the current roll, its value is not included by the <code>Roll.outcomes</code> method.</p> <p>We can programmatically verify that the excluded outcome originated from one of the six-sided dice.</p> <pre><code>&gt;&gt;&gt; excluded = roll[-1]\n&gt;&gt;&gt; excluded.value is None\nTrue\n&gt;&gt;&gt; excluded.sources[0].value\n1\n&gt;&gt;&gt; excluded.sources[0].r is r_d6\nTrue\n</code></pre> <p>We can also verify that the <code>5</code> came from the eight-sided die.</p> <pre><code>&gt;&gt;&gt; five = roll[1]\n&gt;&gt;&gt; five.value\n5\n&gt;&gt;&gt; five.r is r_d8\nTrue\n</code></pre> <p>Alternatively, could have also used our old friend the <code>P</code> object to eliminate the <code>RepeatRoller</code> for a similar, but structurally simpler result.</p> <pre><code>&gt;&gt;&gt; from dyce import P\n&gt;&gt;&gt; R.select_from_values((slice(1, None),), 3@P(d6), d8).roll()\nRoll(\n  r=SelectionRoller(\n    which=(slice(1, None, None),),\n    sources=(\n      ValueRoller(value=3@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1})), annotation=''),\n      ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1}), annotation=''),\n    ),\n    annotation='',\n  ),\n  roll_outcomes=(\n    ...\n</code></pre> <p>*snip* \u2702\ufe0f</p> <pre><code>  ),\n)\n</code></pre> <p> </p> <p>In this case, our results are still mostly traceable, since our pool is homogeneous. However, results from <code>P.roll</code> are sorted, meaning they lose association with their source histograms. This risks ambiguity. Consider:</p> <pre><code>&gt;&gt;&gt; P(6, 8).roll()\n(4, 6)\n</code></pre> <p>Is the <code>4</code> from the <code>d6</code> or <code>d8</code>? \ud83e\udd14\ud83d\udcad No one knows.</p> <pre><code>&gt;&gt;&gt; R.from_value(P(6, 8))  # doctest: +SKIP\n\u2026: UserWarning: using a heterogeneous pool (P(6, 8)) is not recommended where traceability is important\n  ...\nValueRoller(value=P(6, 8), annotation='')\n</code></pre>"},{"location":"rollin/#filtering-and-substitution","title":"Filtering and substitution","text":"<p><code>dyce</code> provides two additional rollers for outcome manipulation.</p> <p><code>FilterRoller</code>s <code>euthanize</code> outcomes that don\u2019t meet provided criteria.</p> <pre><code>&gt;&gt;&gt; r_filter = R.filter_from_values_iterable(\n...   lambda outcome: bool(outcome.is_odd().value),\n...   range(6),\n... ) ; r_filter\nFilterRoller(\n  predicate=&lt;function &lt;lambda&gt; at ...&gt;,\n  sources=(\n    ValueRoller(value=0, annotation=''),\n    ValueRoller(value=1, annotation=''),\n    ValueRoller(value=2, annotation=''),\n    ValueRoller(value=3, annotation=''),\n    ValueRoller(value=4, annotation=''),\n    ValueRoller(value=5, annotation=''),\n  ),\n  annotation='',\n)\n&gt;&gt;&gt; roll = r_filter.roll()\n&gt;&gt;&gt; tuple(roll.outcomes())\n(1, 3, 5)\n&gt;&gt;&gt; roll\nRoll(\n  r=...,\n  roll_outcomes=(\n    RollOutcome(\n      value=None,\n      sources=(\n        RollOutcome(\n          value=0,\n          sources=(),\n        ),\n      ),\n    ),\n    RollOutcome(\n      value=1,\n      sources=(),\n    ),\n    RollOutcome(\n      value=None,\n      sources=(\n        RollOutcome(\n          value=2,\n          sources=(),\n        ),\n      ),\n    ),\n    RollOutcome(\n      value=3,\n      sources=(),\n    ),\n    RollOutcome(\n      value=None,\n      sources=(\n        RollOutcome(\n          value=4,\n          sources=(),\n        ),\n      ),\n    ),\n    RollOutcome(\n      value=5,\n      sources=(),\n    ),\n  ),\n  source_rolls=(...),\n)\n</code></pre> <p> </p> <p><code>SubstitutionRoller</code>s replace or append outcomes based on existing ones.</p> <pre><code>&gt;&gt;&gt; from dyce.r import CoalesceMode, SubstitutionRoller\n&gt;&gt;&gt; r_d6 = R.from_value(H(6))\n\n&gt;&gt;&gt; r_replace = SubstitutionRoller(\n...   lambda outcome: r_d6.roll() if outcome.value == 1 else outcome,\n...   r_d6,\n...   max_depth=2,\n... )\n&gt;&gt;&gt; r_replace.roll()\nRoll(\n  r=SubstitutionRoller(\n    expansion_op=&lt;function &lt;lambda&gt; at ...&gt;,\n    source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n    coalesce_mode=&lt;CoalesceMode.REPLACE: 1&gt;,\n    max_depth=2,\n    annotation='',\n  ),\n  roll_outcomes=(\n    RollOutcome(\n      value=None,\n      sources=(\n        RollOutcome(\n          value=1,\n          sources=(),\n        ),\n      ),\n    ),\n    RollOutcome(\n      value=None,\n      sources=(\n        RollOutcome(\n          value=1,\n          sources=(\n            RollOutcome(\n              value=1,\n              sources=(),\n            ),\n          ),\n        ),\n      ),\n    ),\n    RollOutcome(\n      value=2,\n      sources=(\n        RollOutcome(\n          value=1,\n          sources=(\n            RollOutcome(\n              value=1,\n              sources=(),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n  source_rolls=(...),\n)\n</code></pre> <p> </p> <pre><code>&gt;&gt;&gt; r_append = SubstitutionRoller(\n...   lambda outcome: r_d6.roll() if outcome.value == 1 else outcome,\n...   r_d6,\n...   coalesce_mode=CoalesceMode.APPEND,\n...   max_depth=2,\n... )\n&gt;&gt;&gt; r_append.roll()\nRoll(\n  r=SubstitutionRoller(\n    expansion_op=&lt;function &lt;lambda&gt; at ...&gt;,\n    source=ValueRoller(value=H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1}), annotation=''),\n    coalesce_mode=&lt;CoalesceMode.APPEND: 2&gt;,\n    max_depth=2,\n    annotation='',\n  ),\n  roll_outcomes=(\n    RollOutcome(\n      value=1,\n      sources=(),\n    ),\n    RollOutcome(\n      value=1,\n      sources=(\n        RollOutcome(\n          value=1,\n          sources=(),\n        ),\n      ),\n    ),\n    RollOutcome(\n      value=2,\n      sources=(\n        RollOutcome(\n          value=1,\n          sources=(\n            RollOutcome(\n              value=1,\n              sources=(),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n  source_rolls=(...),\n)\n</code></pre> <p> </p>"},{"location":"rollin/#performance","title":"Performance","text":"<p>How much overhead do all these data structures contribute? It obviously depends on the complexity of the structure. Consider a simple example <code>d20 + d12 + 4</code>. Let\u2019s do that 5,000 times, sort the results, and take every other one starting with the highest. We might use a pool, if we didn\u2019t care about traceability. Let\u2019s compare that to our roller.</p> <pre><code>%timeit (5000@P(H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1, 19: 1, 20: 1}) + H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1}) + 4)).roll()[::-2]\n12.7 ms \u00b1 68.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n\n%timeit (5000@(R.select_from_values((slice(None, None, -2),), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1, 19: 1, 20: 1}), H({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1}), 4))).roll()\n118 ms \u00b1 455 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</code></pre> Source: <code>perf_pools_vs_rollers.ipy</code> <pre><code>from dyce import H, P, R\n\nd20, d12 = H(20), H(12)\n\nprint(f\"%timeit (5000@P({d20} + {d12} + 4)).roll()[::-2]\")\np = 5000@P(d20 + d12 + 4)\n%timeit p.roll()[::-2]\nprint()\n\nprint(f\"%timeit (5000@(R.select_from_values((slice(None, None, -2),), {d20}, {d12}, 4))).roll()\")\nr = 5000@(R.select_from_values((slice(None, None, -2),), d20, d12, 4))\n%timeit r.roll()\nprint()\n</code></pre> <p>In this particular case, our roller takes over ten times longer than our histogram pool. It is unsurprising that a simple roller is slower than a simple pool, at least in part because the math is deferred until <code>R.roll</code> time. In more sophisticated cases, rollers may be more competitive with (or even surpass) their histogram or pool analogies, especially when initialization time is taken into account.</p> <p>All that being said, for periodic rolls simulating handfuls (not thousands) of operations or dice, such performance disparities probably won\u2019t matter that much. Just use the primitives whose semantics work best for you. If ever performance becomes an issue, let me know, and we can collaborate on how to improve it.</p>"},{"location":"rollin/#further-exploration","title":"Further exploration","text":"<p>Consider reviewing the roller API.</p> <ol> <li> <p>If you\u2019re not already familiar with histograms, consider skimming the counting tutorial.\u00a0\u21a9</p> </li> <li> <p>We may still be discovering what those purposes are. We have the utmost faith they exist, even if they have yet to reveal themselves. If you discover one, consider contributing an example.\u00a0\u21a9</p> </li> </ol>"},{"location":"translations/","title":"Applications and translations","text":"<p>The following examples and translations are intended to showcase <code>dyce</code>\u2019s flexibility. If you have exposure to another tool, they may also help with transition.</p>"},{"location":"translations/#checking-angrys-math-on-the-tension-pool","title":"Checking Angry\u2019s math on the Tension Pool","text":"<p>In the Angry GM\u2019s publication of the PDF version of his Tension Pool mechanic, he includes some probabilities. Can <code>dyce</code> check his work? You bet!</p> <p>Let\u2019s reproduce his tables (with slightly different names to provide context).</p> d6s in pool Angry\u2019s probability of at least one <code>1</code> showing 1 16.7% 2 30.6% 3 42.1% 4 51.8% 5 59.8% 6 66.5% <p>How do we do compute these results using <code>dyce</code>?</p> <pre><code>&gt;&gt;&gt; from dyce import H\n&gt;&gt;&gt; one_in_d6 = H(6).eq(1)\n&gt;&gt;&gt; for n in range(1, 7):\n...   ones_in_nd6 = n@one_in_d6\n...   at_least_one_one_in_nd6 = ones_in_nd6.ge(1)\n...   print(f\"{n}: {at_least_one_one_in_nd6[1] / at_least_one_one_in_nd6.total:6.2%}\")\n1: 16.67%\n2: 30.56%\n3: 42.13%\n4: 51.77%\n5: 59.81%\n6: 66.51%\n</code></pre> <p>So far so good. Let\u2019s keep going.</p> 1d8 + 1d12 Rarity or Severity 2-4 Very Rare or Extreme 5-6 Rare or Major 7-8 Uncommon or Moderate 9-13 Common or Minor 14-15 Uncommon or Moderate 16-17 Rare or Major 18-20 Very Rare or Extreme <p>We need to map semantic outcomes to numbers (and back again). How can we represent those in <code>dyce</code>? One way is <code>IntEnum</code>s. <code>IntEnum</code>s have a property that allows them to substitute directly for <code>int</code>s, which, with a little nudging, is very convenient.</p> <pre><code>&gt;&gt;&gt; from enum import IntEnum\n\n&gt;&gt;&gt; class Complication(IntEnum):\n...   NONE = 0  # this will come in handy later\n...   COMMON = 1\n...   UNCOMMON = 2\n...   RARE = 3\n...   VERY_RARE = 4\n\n&gt;&gt;&gt; OUTCOME_TO_RARITY_MAP = {\n...   2: Complication.VERY_RARE,\n...   3: Complication.VERY_RARE,\n...   4: Complication.VERY_RARE,\n...   5: Complication.RARE,\n...   6: Complication.RARE,\n...   7: Complication.UNCOMMON,\n...   8: Complication.UNCOMMON,\n...   9: Complication.COMMON,\n...   10: Complication.COMMON,\n...   11: Complication.COMMON,\n...   12: Complication.COMMON,\n...   13: Complication.COMMON,\n...   14: Complication.UNCOMMON,\n...   15: Complication.UNCOMMON,\n...   16: Complication.RARE,\n...   17: Complication.RARE,\n...   18: Complication.VERY_RARE,\n...   19: Complication.VERY_RARE,\n...   20: Complication.VERY_RARE,\n... }\n</code></pre> <p>Now let\u2019s use our map to validate the probabilities of a particular outcome using that d8 and d12.</p> Rarity or impact Angry\u2019s probability of a Complication arising Common or Minor 41.7% Uncommon or Moderate 27.1% Rare or Major 18.8% Very Rare or Extreme 12.5% <pre><code>&gt;&gt;&gt; from dyce import H\n&gt;&gt;&gt; from dyce.evaluation import foreach\n&gt;&gt;&gt; prob_of_complication = foreach(\n...   lambda h_result: OUTCOME_TO_RARITY_MAP[h_result.outcome],\n...   h_result=H(8) + H(12),\n... )\n&gt;&gt;&gt; {outcome: f\"{float(prob):6.2%}\" for outcome, prob in prob_of_complication.distribution()}\n{&lt;Complication.COMMON: 1&gt;: '41.67%',\n &lt;Complication.UNCOMMON: 2&gt;: '27.08%',\n &lt;Complication.RARE: 3&gt;: '18.75%',\n &lt;Complication.VERY_RARE: 4&gt;: '12.50%'}\n</code></pre> <p>Lookin\u2019 good! Now let\u2019s put everything together.</p> d6s in pool None Common Uncommon Rare Very Rare 1 83.3% 7.0% 4.5% 3.1% 2.1% 2 69.4% 12.7% 8.3% 5.7% 3.8% 3 57.9% 17.6% 11.4% 7.9% 5.3% 4 48.2% 21.6% 14.0% 9.7% 6.5% 5 40.2% 24.9% 16.2% 11.2% 7.5% 6 33.5% 27.7% 18.0% 12.5% 8.3% <pre><code>&gt;&gt;&gt; from typing import cast\n&gt;&gt;&gt; for n in range(1, 7):\n...   ones_in_nd6 = n@one_in_d6\n...   at_least_one_one_in_nd6 = ones_in_nd6.ge(1)\n...   prob_complication_in_nd6 = at_least_one_one_in_nd6 * prob_of_complication\n...   complications_for_nd6 = {\n...     Complication(cast(int, outcome)).name: f\"{float(prob):6.2%}\"\n...     for outcome, prob in (prob_complication_in_nd6).distribution()\n...   }\n...   print(\"{} -&gt; {}\".format(n, complications_for_nd6))\n1 -&gt; {'NONE': '83.33%', 'COMMON': ' 6.94%', 'UNCOMMON': ' 4.51%', 'RARE': ' 3.12%', 'VERY_RARE': ' 2.08%'}\n2 -&gt; {'NONE': '69.44%', 'COMMON': '12.73%', 'UNCOMMON': ' 8.28%', 'RARE': ' 5.73%', 'VERY_RARE': ' 3.82%'}\n3 -&gt; {'NONE': '57.87%', 'COMMON': '17.55%', 'UNCOMMON': '11.41%', 'RARE': ' 7.90%', 'VERY_RARE': ' 5.27%'}\n4 -&gt; {'NONE': '48.23%', 'COMMON': '21.57%', 'UNCOMMON': '14.02%', 'RARE': ' 9.71%', 'VERY_RARE': ' 6.47%'}\n5 -&gt; {'NONE': '40.19%', 'COMMON': '24.92%', 'UNCOMMON': '16.20%', 'RARE': '11.21%', 'VERY_RARE': ' 7.48%'}\n6 -&gt; {'NONE': '33.49%', 'COMMON': '27.71%', 'UNCOMMON': '18.01%', 'RARE': '12.47%', 'VERY_RARE': ' 8.31%'}\n</code></pre> <p>Well butter my butt, and call me a biscuit! That Angry guy sure knows his math!</p>"},{"location":"translations/#modeling-ironsworns-core-mechanic","title":"Modeling Ironsworn\u2019s core mechanic","text":"<p>Shawn Tomlin\u2019s Ironsworn melds a number of different influences in a fresh way. Its core mechanic involves rolling an action die (a d6), adding a modifier, and comparing the resulting value to two challenge dice (d10s). If the modified value from the action die is strictly greater than both challenge dice, the result is a strong success. If it is strictly greater than only one challenge die, the result is a weak success. If it is equal to or less than both challenge dice, it\u2019s a failure.</p> <p>A verbose way to model this is to enumerate the product of the three dice and then perform logical comparisons. However, if we recognize that our problem involves a dependent probability, we can craft a solution in terms of <code>foreach</code>. We can also deploy a counting trick with the two d10s.</p> <pre><code>&gt;&gt;&gt; from dyce import H, as_int\n&gt;&gt;&gt; from dyce.evaluation import foreach\n&gt;&gt;&gt; from numerary.types import RealLike\n&gt;&gt;&gt; from enum import IntEnum, auto\n&gt;&gt;&gt; from typing import cast\n&gt;&gt;&gt; d6 = H(6)\n&gt;&gt;&gt; d10 = H(10)\n&gt;&gt;&gt; mods = list(range(0, 5))\n\n&gt;&gt;&gt; class IronResult(IntEnum):\n...   FAILURE = 0\n...   WEAK_SUCCESS = auto()\n...   STRONG_SUCCESS = auto()\n\n&gt;&gt;&gt; iron_distributions_by_mod = {\n...   mod: foreach(lambda action: 2@(d10.lt(action.outcome)), action=d6 + mod).zero_fill(IronResult)\n...   for mod in mods\n... }\n&gt;&gt;&gt; for mod, iron_distribution in iron_distributions_by_mod.items():\n...   print(\"{:+} -&gt; {}\".format(mod, {\n...     IronResult(cast(int, outcome)).name: f\"{float(prob):6.2%}\"\n...     for outcome, prob in iron_distribution.distribution()\n...   }))\n+0 -&gt; {'FAILURE': '59.17%', 'WEAK_SUCCESS': '31.67%', 'STRONG_SUCCESS': ' 9.17%'}\n+1 -&gt; {'FAILURE': '45.17%', 'WEAK_SUCCESS': '39.67%', 'STRONG_SUCCESS': '15.17%'}\n+2 -&gt; {'FAILURE': '33.17%', 'WEAK_SUCCESS': '43.67%', 'STRONG_SUCCESS': '23.17%'}\n+3 -&gt; {'FAILURE': '23.17%', 'WEAK_SUCCESS': '43.67%', 'STRONG_SUCCESS': '33.17%'}\n+4 -&gt; {'FAILURE': '15.17%', 'WEAK_SUCCESS': '39.67%', 'STRONG_SUCCESS': '45.17%'}\n</code></pre> <p>What\u2019s with that <code>2@(d10.lt(action))</code>?</p> <p>Let\u2019s break it down. <code>H(10).lt(value)</code> will tell us how often a single d10 is less than <code>value</code>.</p> <pre><code>&gt;&gt;&gt; H(10).lt(5)  # how often a d10 is strictly less than 5\nH({False: 6, True: 4})\n</code></pre> <p>By summing those results (and taking advantage of the fact that, in Python, <code>bool</code>s act like <code>int</code>s when it comes to arithmetic operators), we can count how often that happens with more than one interchangeable d10.</p> <pre><code>&gt;&gt;&gt; h = H(10).lt(5) + H(10).lt(5) ; h\nH({0: 36, 1: 48, 2: 16})\n&gt;&gt;&gt; h.total\n100\n</code></pre> <p>How do we interpret those results? 36 times out of a hundred, neither d10 will be strictly less than five. 48 times out of a hundred, exactly one of the d10s will be strictly less than five. 16 times out of a hundred, both d10s will be strictly less than five.</p> <p><code>H</code>\u2019s <code>@</code> operator provides a shorthand.</p> <pre><code>&gt;&gt;&gt; # The parentheses are technically redundant, but clarify the intention\n&gt;&gt;&gt; 2@(H(10).lt(5)) == H(10).lt(5) + H(10).lt(5)\nTrue\n</code></pre> <p>Why doesn\u2019t <code>2@(H(6).gt(H(10))</code> work?</p> <p><code>H(6).gt(H(10))</code> will compute how often a six-sided die is strictly greater than a ten-sided die. <code>2@(H(6).gt(H(10)))</code> will show the frequencies that a first six-sided die is strictly greater than a first ten-sided die and a second six-sided die is strictly greater than a second ten-sided die. This isn\u2019t quite what we want, since the mechanic calls for rolling a single six-sided die and comparing that result to each of two ten-sided dice.</p> <p>Now for a twist. In cooperative or solo play, a failure or success is particularly spectacular when the d10s come up doubles. The key to mapping that to <code>dyce</code> internals is recognizing that we have a dependent probability that involves three independent variables: the (modded) d6, a first d10, and a second d10.</p> <p><code>foreach</code> is especially useful where there are multiple independent terms.</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import HResult\n\n&gt;&gt;&gt; class IronSoloResult(IntEnum):\n...   FAILURE = 0\n...   WEAK_SUCCESS = auto()\n...   STRONG_SUCCESS = auto()\n...   SPECTACULAR_SUCCESS = auto()\n...   SPECTACULAR_FAILURE = -1\n\n&gt;&gt;&gt; def iron_solo_dependent_term(action: HResult, first_challenge: HResult, second_challenge: HResult, mod=0):\n...   modded_action = action.outcome + mod\n...   beats_first_challenge = modded_action &gt; first_challenge.outcome\n...   beats_second_challenge = modded_action &gt; second_challenge.outcome\n...   doubles = first_challenge.outcome == second_challenge.outcome\n...   if beats_first_challenge and beats_second_challenge:\n...     return IronSoloResult.SPECTACULAR_SUCCESS if doubles else IronSoloResult.STRONG_SUCCESS\n...   elif beats_first_challenge or beats_second_challenge:\n...     return IronSoloResult.WEAK_SUCCESS\n...   else:\n...     return IronSoloResult.SPECTACULAR_FAILURE if doubles else IronSoloResult.FAILURE\n\n&gt;&gt;&gt; foreach(iron_solo_dependent_term, action=d6, first_challenge=d10, second_challenge=d10)\nH({&lt;IronSoloResult.SPECTACULAR_FAILURE: -1&gt;: 9,\n &lt;IronSoloResult.FAILURE: 0&gt;: 62,\n &lt;IronSoloResult.WEAK_SUCCESS: 1&gt;: 38,\n &lt;IronSoloResult.STRONG_SUCCESS: 2&gt;: 8,\n &lt;IronSoloResult.SPECTACULAR_SUCCESS: 3&gt;: 3})\n</code></pre> <p>By defining our dependent term function to include <code>mod</code> as a parameter with a default argument, we can use <code>partial</code> to manipulate it, which is helpful for visualization.</p> SPECTACULAR_FAILURE FAILURE WEAK_SUCCESS STRONG_SUCCESS SPECTACULAR_SUCCESS Modifier 0 7.50% 51.67% 31.67% 6.67% 2.50% 1 6.50% 38.67% 39.67% 11.67% 3.50% 2 5.50% 27.67% 43.67% 18.67% 4.50% 3 4.50% 18.67% 43.67% 27.67% 5.50% 4 3.50% 11.67% 39.67% 38.67% 6.50% <p> </p>  Source: <code>plot_ironsworn.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom enum import IntEnum, auto\nfrom functools import partial\n\nfrom dyce import H, P\nfrom dyce.evaluation import HResult, PResult, foreach\n\n\nclass IronSoloResult(IntEnum):\n    SPECTACULAR_FAILURE = -1\n    FAILURE = auto()\n    WEAK_SUCCESS = auto()\n    STRONG_SUCCESS = auto()\n    SPECTACULAR_SUCCESS = auto()\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n    import matplotlib.ticker\n    import pandas\n\n    d6 = H(6)\n    d10 = H(10)\n\n    def iron_solo_dependent_term(\n        action: HResult,\n        challenges: PResult,\n        mod=0,\n    ):\n        modded_action = action.outcome + mod\n        first_challenge_outcome, second_challenge_outcome = challenges.roll\n        beats_first_challenge = modded_action &gt; first_challenge_outcome\n        beats_second_challenge = modded_action &gt; second_challenge_outcome\n        doubles = first_challenge_outcome == second_challenge_outcome\n        if beats_first_challenge and beats_second_challenge:\n            return (\n                IronSoloResult.SPECTACULAR_SUCCESS\n                if doubles\n                else IronSoloResult.STRONG_SUCCESS\n            )\n        elif beats_first_challenge or beats_second_challenge:\n            return IronSoloResult.WEAK_SUCCESS\n        else:\n            return (\n                IronSoloResult.SPECTACULAR_FAILURE\n                if doubles\n                else IronSoloResult.FAILURE\n            )\n\n    mods = list(range(0, 5))\n    # TODO(posita): See &lt;https://github.com/pandas-dev/pandas/issues/54386&gt;\n    df = pandas.DataFrame(columns=[v.name for v in IronSoloResult])\n\n    for mod in mods:\n        h_for_mod = foreach(\n            partial(iron_solo_dependent_term, mod=mod),\n            action=d6,\n            challenges=2 @ P(d10),\n        )\n        # TODO(posita): See &lt;https://github.com/pandas-dev/pandas/issues/54386&gt;\n        results_for_mod = {\n            outcome.name: count  # type: ignore\n            for outcome, count in h_for_mod.zero_fill(IronSoloResult).distribution(\n                rational_t=lambda n, d: n / d\n            )\n        }\n        row = pandas.DataFrame(\n            # TODO(posita): See &lt;https://github.com/pandas-dev/pandas/issues/54386&gt;\n            results_for_mod,\n            columns=[v.name for v in IronSoloResult],\n            index=[mod],\n        )\n        df = pandas.concat((df, row))\n\n    df.index.name = \"Modifier\"\n    # TODO(posita): See &lt;https://github.com/pandas-dev/pandas/issues/54386&gt;\n    # # DataFrames use enum's values for displaying column names, so we convert them to\n    # # names\n    # df = df.rename(columns={v: v.name for v in IronSoloResult})\n    print(df.style.format(\"{:.2%}\").to_html())\n\n    ax = df.plot(kind=\"barh\", stacked=True)\n    text_color = \"white\" if style == \"dark\" else \"black\"\n    ax.tick_params(axis=\"x\", colors=text_color)\n    ax.tick_params(axis=\"y\", colors=text_color)\n    ylabel = ax.get_ylabel()\n    ax.set_ylabel(ylabel, color=text_color)\n\n    ax.xaxis.set_major_formatter(matplotlib.ticker.PercentFormatter(xmax=1))\n    ax.legend()\n    ax.set_title(\"Ironsworn distributions\", color=text_color)\n</code></pre>"},{"location":"translations/#advanced-topic-modeling-risis","title":"Advanced topic \u2013 modeling Risis","text":"<p>Risus and its many community-developed alternative rules not only make for entertaining reading, but are fertile ground for stressing ergonomics and capabilities of any discrete outcome modeling tool. We can easily model the first round of its opposed combat system for various starting configurations.</p> <pre><code>&gt;&gt;&gt; for them in range(3, 6):\n...   print(\"---\")\n...   for us in range(them, them + 3):\n...     first_round = (us@H(6)).vs(them@H(6))  # -1 is a loss, 0 is a tie, 1 is a win\n...     risus_results = first_round.format(width=0)\n...     print(f\"{us}d6 vs. {them}d6: {risus_results}\")\n---\n3d6 vs. 3d6: {..., -1: 45.36%, 0:  9.28%, 1: 45.36%}\n4d6 vs. 3d6: {..., -1: 19.17%, 0:  6.55%, 1: 74.28%}\n5d6 vs. 3d6: {..., -1:  6.07%, 0:  2.99%, 1: 90.93%}\n---\n4d6 vs. 4d6: {..., -1: 45.95%, 0:  8.09%, 1: 45.95%}\n5d6 vs. 4d6: {..., -1: 22.04%, 0:  6.15%, 1: 71.81%}\n6d6 vs. 4d6: {..., -1:  8.34%, 0:  3.26%, 1: 88.40%}\n---\n5d6 vs. 5d6: {..., -1: 46.37%, 0:  7.27%, 1: 46.37%}\n6d6 vs. 5d6: {..., -1: 24.24%, 0:  5.79%, 1: 69.96%}\n7d6 vs. 5d6: {..., -1: 10.36%, 0:  3.40%, 1: 86.24%}\n</code></pre> <p>This highlights the mechanic\u2019s notorious \u201cdeath spiral\u201d, which we can visualize as a heat map.</p> <p> </p>    Source: <code>plot_risus_first_round.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom dyce import H\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n\n    col_names = [\"Loss\", \"Tie\", \"Win\"]\n    col_ticks = list(range(len(col_names)))\n    num_scenarios = 3\n    text_color = \"white\" if style == \"dark\" else \"black\"\n\n    for i, them in enumerate(range(3, 3 + num_scenarios)):\n        ax = matplotlib.pyplot.subplot(1, num_scenarios, i + 1)\n        row_names: list[str] = []\n        rows: list[tuple[float, ...]] = []\n        num_rows = 3\n\n        for us in range(them, them + num_rows):\n            row_names.append(f\"{us}d6 \u2026\")\n            results = (us @ H(6)).vs(them @ H(6))\n            rows.append(results.distribution_xy()[-1])\n\n        ax.imshow(rows)\n        ax.set_title(f\"\u2026 vs. {them}d6\", color=text_color)\n        ax.set_xticks(col_ticks)\n        ax.set_xticklabels(col_names, color=text_color, rotation=90)\n        ax.set_yticks(list(range(len(rows))))\n        ax.set_yticklabels(row_names, color=text_color)\n\n        for y in range(len(row_names)):\n            for x in range(len(col_names)):\n                ax.text(\n                    x,\n                    y,\n                    f\"{rows[y][x]:.0%}\",\n                    ha=\"center\",\n                    va=\"center\",\n                    color=\"w\",\n                )\n</code></pre>"},{"location":"translations/#modeling-entire-multi-round-combats","title":"Modeling entire multi-round combats","text":"<p>With a little elbow finger grease, we can roll up our \u2026 erm \u2026 fingerless gloves and even model various starting configurations through to completion to get a better sense of the impact of any initial disparity (in this case, applying dynamic programming to avoid redundant computations).</p> <pre><code>&gt;&gt;&gt; from dyce import H, P\n&gt;&gt;&gt; from dyce.evaluation import HResult, foreach\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; from enum import IntEnum, auto\n&gt;&gt;&gt; from typing import Callable\n&gt;&gt;&gt; from functools import cache\n\n&gt;&gt;&gt; class Risus(IntEnum):\n...   LOSS = -1\n...   DRAW = auto()\n...   WIN = auto()\n\n&gt;&gt;&gt; def risus_combat_driver(\n...     us: int,  # number of dice we still have\n...     them: int,  # number of dice they still have\n...     us_vs_them_func: Callable[[int, int], H],\n... ) -&gt; H:\n...   if us &lt; 0 or them &lt; 0:\n...     raise ValueError(f\"cannot have negative numbers (us: {us}, them: {them})\")\n...   if us == 0 and them == 0:\n...     return H({0: 1})  # should not happen unless combat(0, 0) is called from the start\n...\n...   @cache\n...   def _resolve(us: int, them: int) -&gt; H:\n...     if us == 0: return H({-1: 1})  # we are out of dice, they win\n...     if them == 0: return H({1: 1})  # they are out of dice, we win\n...     this_round = us_vs_them_func(us, them)\n...\n...     def _next_round(this_round: HResult) -&gt; H:\n...       if this_round.outcome == Risus.LOSS: return _resolve(us - 1, them)  # we lost this round, and one die\n...       elif this_round.outcome == Risus.WIN: return _resolve(us, them - 1)  # they lost this round, and one die\n...       elif this_round.outcome == Risus.DRAW: return H({})  # ignore (immediately re-roll) all ties\n...       else: assert False, f\"unrecognized this_round.outcome {this_round.outcome}\"\n...\n...     return foreach(_next_round, this_round=this_round, limit=-1)\n...   return _resolve(us, them)\n\n&gt;&gt;&gt; for t in range(3, 6):\n...   print(\"---\")\n...   for u in range(t, t + 3):\n...     risus_results = risus_combat_driver(\n...       u, t,\n...       lambda u, t: (u@H(6)).vs(t@H(6))\n...     ).format(width=0)\n...     print(f\"{u}d6 vs. {t}d6: {risus_results}\")\n---\n3d6 vs. 3d6: {..., -1: 50.00%, 1: 50.00%}\n4d6 vs. 3d6: {..., -1: 10.50%, 1: 89.50%}\n5d6 vs. 3d6: {..., -1:  0.66%, 1: 99.34%}\n---\n4d6 vs. 4d6: {..., -1: 50.00%, 1: 50.00%}\n5d6 vs. 4d6: {..., -1: 12.25%, 1: 87.75%}\n6d6 vs. 4d6: {..., -1:  1.07%, 1: 98.93%}\n---\n5d6 vs. 5d6: {..., -1: 50.00%, 1: 50.00%}\n6d6 vs. 5d6: {..., -1: 13.66%, 1: 86.34%}\n7d6 vs. 5d6: {..., -1:  1.49%, 1: 98.51%}\n</code></pre> <p>There\u2019s lot going on there. Let\u2019s dissect it.</p> <pre><code>@cache\ndef risus_combat_driver(\n    us: int,  # number of dice we still have\n    them: int,  # number of dice they still have\n    us_vs_them_func: Callable[[int, int], H],\n) -&gt; H:\n  ...\n</code></pre> <p>Our \u201cdriver\u201d takes three arguments:</p> <ol> <li>How many dice we have left (<code>us</code>);</li> <li>How many dice the opposition has left (<code>them</code>); and</li> <li> <p>A resolution function (<code>us_vs_them_func</code>) that takes counts of each party\u2019s remaining dice and returns a histogram encoding the probability of winning or losing a single round akin to the <code>H.vs</code> method:</p> <ul> <li>An outcome of <code>-1</code> signals the opposition\u2019s victory</li> <li>An outcome of <code>1</code> signals our victory.</li> <li>An outcome of <code>0</code> signals a tie.</li> </ul> </li> </ol> <p>The <code>@cache</code> decorator does simple memoization for us because there are redundancies. For example, we might compute a case where we lose a die, then our opposition loses a die. We arrive at a similar case where our opposition loses a die, then we lose a die. Both cases would be identical from that point on. In this context, <code>@cache</code> helps us avoid recomputing redundant sub-trees.</p> <pre><code>  if us &lt; 0 or them &lt; 0:\n    raise ValueError(f\"cannot have negative numbers (us: {us}, them: {them})\")\n  if us == 0 and them == 0:\n    return H({0: 1})  # should not happen unless combat(0, 0) is called from the start\n</code></pre> <p>We make some preliminary checks that guard access to our recursive implementation so that it can be a little cleaner.</p> <pre><code>  def _resolve(us: int, them: int) -&gt; H:\n    ...\n</code></pre> <pre><code>  return _resolve(us, them)\n</code></pre> <p>Skipping over its implementation for now, we define a our memoized recursive implementation (<code>_resolve</code>) and then call it with our initial arguments.</p> <pre><code>  def _resolve(us: int, them: int) -&gt; H:\n    if us == 0: return H({-1: 1})  # we are out of dice, they win\n    if them == 0: return H({1: 1})  # they are out of dice, we win\n</code></pre> <p>Getting back to that implementation, these are our base cases. We check whether either party has run out of dice, in which case the combat is over. If we have none of those cases, we get to work.</p> <p>Note</p> <p>In this function, we do not check for the case where both parties are at zero. Because only one party can lose a die during each round, the only way both parties can be at zero simultaneously is if they both started at zero. Since we guard against that case in the enclosing function, we don\u2019t have to worry about it here. Either <code>us</code> is zero, <code>them</code> is zero, or neither is zero.</p> <pre><code>    this_round = us_vs_them_func(us, them)\n</code></pre> <p>Then, we compute the outcomes for this round using the provided resolution function.</p> <pre><code>    def _next_round(this_round: HResult) -&gt; H:\n      ...\n</code></pre> <pre><code>    return _next_round(this_round=this_round)\n</code></pre> <p>Keeping in mind that we\u2019re inside our recursive implementation, we define a dependent term. This allows us to take our computation for this round, and \u201cfold in\u201d subsequent rounds.</p> <pre><code>    def _next_round(this_round) -&gt; H:\n      if this_round.outcome &lt; 0: return _resolve(us - 1, them)  # we lost this round, and one die\n      elif this_round.outcome &gt; 0: return _resolve(us, them - 1)  # they lost this round, and one die\n      else: return H({})  # ignore (immediately re-roll) all ties\n</code></pre> <p>Our dependent term is pretty straightforward. Where we are asked to resolve a round we lost, we lose a die and recurse. Where we are asked to resolve a round we won, our opposition loses a die and we recurse. We ignore ties (simulating that we re-roll them in place until they are no longer ties).</p> <pre><code>    ... risus_combat_driver(\n      u, t,\n      lambda u, t: (u@H(6)).vs(t@H(6))\n    ) ...\n</code></pre> <p>At this point, we can define a simple <code>lambda</code> that wraps <code>H.vs</code> and submit it to our driver to enumerate resolution outcomes from various starting positions.</p> <p>Note</p> <p>This is a complicated example that involves some fairly sophisticated programming techniques (recursion, memoization, nested functions, etc.). The point is not to suggest that such techniques are required to be productive. However, it is useful to show that <code>dyce</code> is flexible enough to model these types of outcomes in a couple dozen lines of code. It is high-level enough to lean on for nuanced number crunching without a lot of detailed knowledge, while still being low-level enough that authors knowledgeable of advanced programming techniques are not precluded from using them.</p>"},{"location":"translations/#modeling-different-combat-resolution-methods","title":"Modeling different combat resolution methods","text":"<p>Using our <code>risus_combat_driver</code> from above, we can craft a alternative resolution function to model the less death-spirally \u201cBest of Set\u201d alternative mechanic from The Risus Companion with the optional \u201cGoliath Rule\u201d for resolving ties.</p> <pre><code>&gt;&gt;&gt; def deadly_combat_vs(us: int, them: int) -&gt; H:\n...   best_us = (us@P(6)).h(-1)\n...   best_them = (them@P(6)).h(-1)\n...   h = best_us.vs(best_them)\n...   # Goliath Rule: tie goes to the party with fewer dice in this round\n...   h = foreach(\n...     lambda h_result: (us &lt; them) - (us &gt; them) if h_result.outcome == 0 else h_result.outcome,\n...     h_result=h,\n...   )\n...   return h\n\n&gt;&gt;&gt; for t in range(3, 6):\n...   print(\"---\")\n...   for u in range(t, t + 3):\n...     risus_results = risus_combat_driver(u, t, deadly_combat_vs).format(width=0)\n...     print(f\"{u}d6 vs. {t}d6: {risus_results}\")\n---\n3d6 vs. 3d6: {..., -1: 50.00%, 1: 50.00%}\n4d6 vs. 3d6: {..., -1: 36.00%, 1: 64.00%}\n5d6 vs. 3d6: {..., -1: 23.23%, 1: 76.77%}\n---\n4d6 vs. 4d6: {..., -1: 50.00%, 1: 50.00%}\n5d6 vs. 4d6: {..., -1: 40.67%, 1: 59.33%}\n6d6 vs. 4d6: {..., -1: 30.59%, 1: 69.41%}\n---\n5d6 vs. 5d6: {..., -1: 50.00%, 1: 50.00%}\n6d6 vs. 5d6: {..., -1: 44.13%, 1: 55.87%}\n7d6 vs. 5d6: {..., -1: 36.89%, 1: 63.11%}\n</code></pre> <p>The \u201cEvens Up\u201d alternative dice mechanic presents some challenges.</p> <p>First, <code>dyce</code>\u2019s substitution mechanism only resolves outcomes through a fixed number of iterations, so it can only approximate probabilities for infinite series. Most of the time, the implications are largely theoretical with a sufficient number of iterations. This is no exception.</p> <p>Second, with one narrow exception, <code>dyce</code> only provides a mechanism to directly foreach outcomes, not counts. This means we can\u2019t arbitrarily increase the likelihood of achieving a particular outcome through replacement. With some creativity, we can work around that, too.</p> <p>In the case of \u201cEvens Up\u201d, we need to keep track of whether an even number was rolled, but we also need to keep rolling (and accumulating) as long as sixes are rolled. This behaves a lot like an exploding die with three values (miss, hit, and hit-and-explode). Further, we can observe that every \u201crun\u201d will be zero or more exploding hits terminated by either a miss or a non-exploding hit.</p> <p>If we choose our values carefully, we can encode how many times we\u2019ve encountered relevant events as we explode.</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import explode\n&gt;&gt;&gt; import operator\n&gt;&gt;&gt; MISS = 0\n&gt;&gt;&gt; HIT = 1\n&gt;&gt;&gt; HIT_EXPLODE = 2\n&gt;&gt;&gt; d_evens_up_raw = H((\n...   MISS,  # 1\n...   HIT,  # 2\n...   MISS,  # 3\n...   HIT,  # 4\n...   MISS,  # 5\n...   HIT_EXPLODE,  # 6\n... ))\n\n&gt;&gt;&gt; d_evens_up_exploded = explode(d_evens_up_raw, limit=3) ; d_evens_up_exploded\nH({0: 648, 1: 432, 2: 108, 3: 72, 4: 18, 5: 12, 6: 3, 7: 2, 8: 1})\n</code></pre> <p>For every value that is even, we ended in a miss. For every value that is odd, we ended in a hit that will need to be tallied. Dividing by two and ignoring any remainder will tell us how many exploding hits we had along the way.</p> <pre><code>&gt;&gt;&gt; def decode_hits(h_result: HResult):\n...   return (h_result.outcome + 1) // 2  # equivalent to h_result.outcome // 2 + h_result.outcome % 2\n\n&gt;&gt;&gt; d_evens_up = foreach(decode_hits, h_result=d_evens_up_exploded)\n&gt;&gt;&gt; print(d_evens_up.format())\navg |    0.60\nstd |    0.69\nvar |    0.48\n  0 |  50.00% |#########################\n  1 |  41.67% |####################\n  2 |   6.94% |###\n  3 |   1.16% |\n  4 |   0.23% |\n</code></pre> <p>We can now approximate a complete \u201cEvens Up\u201d combat using our <code>risus_combat_driver</code> from above. We can also deploy a trick using <code>partial</code> to parameterize use of the Goliath Rule.</p> <pre><code>&gt;&gt;&gt; from functools import partial\n\n&gt;&gt;&gt; def evens_up_vs(us: int, them: int, goliath: bool = False) -&gt; H:\n...   h = (us@d_evens_up).vs(them@d_evens_up)\n...   if goliath:\n...     h = foreach(\n...       lambda h_result: (us &lt; them) - (us &gt; them) if h_result.outcome == 0 else h_result.outcome,\n...       h_result=h,\n...     )\n...   return h\n\n&gt;&gt;&gt; for t in range(3, 5):\n...   print(\"-----------   ---- With Goliath Rule -----   --- Without Goliath Rule ---\")\n...   for u in range(t, t + 3):\n...     goliath_results = risus_combat_driver(u, t, partial(evens_up_vs, goliath=True)).format(width=0)\n...     no_goliath_results = risus_combat_driver(u, t, partial(evens_up_vs, goliath=False)).format(width=0)\n...     print(f\"{u}d6 vs. {t}d6:   {goliath_results}   {no_goliath_results}\")\n-----------   ---- With Goliath Rule -----   --- Without Goliath Rule ---\n3d6 vs. 3d6:   {..., -1: 50.00%, 1: 50.00%}   {..., -1: 50.00%, 1: 50.00%}\n4d6 vs. 3d6:   {..., -1: 29.51%, 1: 70.49%}   {..., -1: 19.08%, 1: 80.92%}\n5d6 vs. 3d6:   {..., -1: 12.32%, 1: 87.68%}   {..., -1:  4.57%, 1: 95.43%}\n-----------   ---- With Goliath Rule -----   --- Without Goliath Rule ---\n4d6 vs. 4d6:   {..., -1: 50.00%, 1: 50.00%}   {..., -1: 50.00%, 1: 50.00%}\n5d6 vs. 4d6:   {..., -1: 30.52%, 1: 69.48%}   {..., -1: 21.04%, 1: 78.96%}\n6d6 vs. 4d6:   {..., -1: 13.68%, 1: 86.32%}   {..., -1:  5.88%, 1: 94.12%}\n</code></pre>"},{"location":"translations/#modeling-the-probability-of-4d6-drop-the-lowest-reroll-1s","title":"Modeling \u201cThe Probability of 4d6, Drop the Lowest, Reroll 1s\u201d","text":"<pre><code>&gt;&gt;&gt; from dyce import H, P\n&gt;&gt;&gt; from dyce.evaluation import foreach\n&gt;&gt;&gt; from itertools import chain\n&gt;&gt;&gt; p_4d6 = 4 @ P(6)\n&gt;&gt;&gt; d6_reroll_first_one = foreach(lambda h_result: h if h_result.outcome == 1 else h_result.outcome, h_result=H(6))\n&gt;&gt;&gt; p_4d6_reroll_first_one = 4 @ P(d6_reroll_first_one)\n&gt;&gt;&gt; p_4d6_reroll_all_ones = 4 @ P(H(5) + 1)\n&gt;&gt;&gt; attr_results: dict[str, H] = {\n...     \"3d6\": 3 @ H(6),\n...     \"4d6 - discard lowest\": p_4d6.h(slice(1, None)),\n...     \"4d6 - re-roll first 1, discard lowest\": p_4d6_reroll_first_one.h(slice(1, None)),\n...     \"4d6 - re-roll all 1s (i.e., 4d(1d5 + 1)), discard lowest\": p_4d6_reroll_all_ones.h(slice(1, None)),\n...     \"2d6 + 6\": 2 @ H(6) + 6,\n...     \"4d4 + 2\": 4 @ H(4) + 2,\n... }\n</code></pre> <p>Visualization:</p> <p> </p>    Source: <code>plot_4d6_variants.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom anydyce.viz import plot_line\n\nfrom dyce import H, P\nfrom dyce.evaluation import explode\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n\n    p_4d6 = 4 @ P(6)\n    d6_reroll_first_one = explode(H(6), lambda result: result.outcome == 1)\n    p_4d6_reroll_first_one = 4 @ P(d6_reroll_first_one)\n    p_4d6_reroll_all_ones = 4 @ P(H(5) + 1)\n\n    markers = \"Ds^*xo\"\n    attr_results: dict[str, H] = {\n        \"3d6\": 3 @ H(6),  # marker=\"D\"\n        \"4d6 - discard lowest\": p_4d6.h(slice(1, None)),  # marker=\"s\"\n        \"4d6 - re-roll first 1, discard lowest\": p_4d6_reroll_first_one.h(\n            slice(1, None)\n        ),  # marker=\"^\"\n        \"4d6 - re-roll all 1s (i.e., 4d(1d5 + 1)), discard lowest\": p_4d6_reroll_all_ones.h(\n            slice(1, None)\n        ),  # marker=\"*\"\n        \"2d6 + 6\": 2 @ H(6) + 6,  # marker=\"x\"\n        \"4d4 + 2\": 4 @ H(4) + 2,  # marker=\"o\"\n    }\n\n    ax = matplotlib.pyplot.axes()\n    text_color = \"white\" if style == \"dark\" else \"black\"\n    ax.tick_params(axis=\"x\", colors=text_color)\n    ax.tick_params(axis=\"y\", colors=text_color)\n    plot_line(\n        ax,\n        [(label, res) for label, res in attr_results.items()],\n    )\n\n    for line, marker in zip(ax.lines, markers):\n        line.set_marker(marker)\n\n    ax.legend()\n    ax.set_title(\"Comparing various take-three-of-4d6 methods\", color=text_color)\n</code></pre>"},{"location":"translations/#translating-one-example-from-markbrockettrobsonpython_dice","title":"Translating one example from <code>markbrockettrobson/python_dice</code>","text":"<p>Source:</p> <pre><code># \u2026\nprogram = [\n  \"VAR save_roll = d20\",\n  \"VAR burning_arch_damage = 10d6 + 10\",\n  \"VAR pass_save = ( save_roll &gt;= 10 ) \",\n  \"VAR damage_half_on_save = burning_arch_damage // (pass_save + 1)\",\n  \"damage_half_on_save\"\n]\n# \u2026\n</code></pre> <p>Translation:</p> <pre><code>&gt;&gt;&gt; from dyce import H\n&gt;&gt;&gt; save_roll = H(20)\n&gt;&gt;&gt; burning_arch_damage = 10@H(6) + 10\n&gt;&gt;&gt; pass_save = save_roll.ge(10)\n&gt;&gt;&gt; damage_half_on_save = burning_arch_damage // (pass_save + 1)\n</code></pre> <p>Visualization:</p> <p> </p>    Source: <code>plot_burning_arch.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom anydyce.viz import plot_line\n\nfrom dyce import H\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n\n    save_roll = H(20)\n    burning_arch_damage = 10 @ H(6) + 10\n    pass_save = save_roll.ge(10)\n    damage_half_on_save = burning_arch_damage // (pass_save + 1)\n\n    ax = matplotlib.pyplot.axes()\n    text_color = \"white\" if style == \"dark\" else \"black\"\n    ax.tick_params(axis=\"x\", colors=text_color)\n    ax.tick_params(axis=\"y\", colors=text_color)\n    plot_line(ax, [(\"\", damage_half_on_save)])\n    ax.set_title(\"Attack with saving throw for half damage\", color=text_color)\n</code></pre> <p>An alternative using <code>foreach</code>:</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import foreach\n&gt;&gt;&gt; import operator\n&gt;&gt;&gt; foreach(\n...   lambda h_result: (\n...     burning_arch_damage // 2\n...     if operator.__ge__(h_result.outcome, 10)\n...     else burning_arch_damage\n...   ),\n...   h_result=save_roll,\n... ) == damage_half_on_save\nTrue\n</code></pre>"},{"location":"translations/#more-translations-from-markbrockettrobsonpython_dice","title":"More translations from <code>markbrockettrobson/python_dice</code>","text":"<pre><code>&gt;&gt;&gt; # VAR name = 1 + 2d3 - 3 * 4d2 // 5\n&gt;&gt;&gt; name = 1 + (2@H(3)) - 3 * (4@H(2)) // 5\n&gt;&gt;&gt; print(name.format(width=0))\n{avg: 1.75, -1:  3.47%, 0: 13.89%, 1: 25.00%, 2: 29.17%, 3: 19.44%, 4:  8.33%, 5:  0.69%}\n</code></pre> <pre><code>&gt;&gt;&gt; # VAR out = 3 * ( 1 + 1d4 )\n&gt;&gt;&gt; out = 3 * (1 + 2@H(4))\n&gt;&gt;&gt; print(out.format(width=0))\n{avg: 18.00, 9:  6.25%, 12: 12.50%, 15: 18.75%, 18: 25.00%, 21: 18.75%, 24: 12.50%, 27:  6.25%}\n</code></pre> <pre><code>&gt;&gt;&gt; # VAR g = (1d4 &gt;= 2) AND !(1d20 == 2)\n&gt;&gt;&gt; g = H(4).ge(2) &amp; H(20).ne(2)\n&gt;&gt;&gt; print(g.format(width=0))\n{..., False: 28.75%, True: 71.25%}\n</code></pre> <pre><code>&gt;&gt;&gt; # VAR h = (1d4 &gt;= 2) OR !(1d20 == 2)\n&gt;&gt;&gt; h = H(4).ge(2) | H(20).ne(2)\n&gt;&gt;&gt; print(h.format(width=0))\n{..., False:  1.25%, True: 98.75%}\n</code></pre> <pre><code>&gt;&gt;&gt; # VAR abs = ABS( 1d6 - 1d6 )\n&gt;&gt;&gt; abs_h = abs(H(6) - H(6))\n&gt;&gt;&gt; print(abs_h.format(width=0))\n{avg: 1.94, 0: 16.67%, 1: 27.78%, 2: 22.22%, 3: 16.67%, 4: 11.11%, 5:  5.56%}\n</code></pre> <pre><code>&gt;&gt;&gt; # MAX(4d7, 2d10)\n&gt;&gt;&gt; max_h = P(4@H(7), 2@H(10)).h(-1)\n&gt;&gt;&gt; print(max_h.format(width=0))\n{avg: 16.60, 4:  0.00%, 5:  0.02%, 6:  0.07%, 7:  0.21%, ..., 25:  0.83%, 26:  0.42%, 27:  0.17%, 28:  0.04%}\n</code></pre> <pre><code>&gt;&gt;&gt; # MIN(50, d%)\n&gt;&gt;&gt; min_h = P(H((50,)), P(100)).h(0)\n&gt;&gt;&gt; print(min_h.format(width=0))\n{avg: 37.75, 1:  1.00%, 2:  1.00%, 3:  1.00%, ..., 47:  1.00%, 48:  1.00%, 49:  1.00%, 50: 51.00%}\n</code></pre>"},{"location":"translations/#translations-from-lordsembordndice","title":"Translations from <code>LordSembor/DnDice</code>","text":"<p>Example 1 source:</p> <pre><code>from DnDice import d, gwf\nsingle_attack = 2*d(6) + 5\n# \u2026\ngreat_weapon_fighting = gwf(2*d(6)) + 5\n# \u2026\n# comparison of the probability\nprint(single_attack.expectancies())\nprint(great_weapon_fighting.expectancies())\n# [ 0.03,  0.06, 0.08, 0.11, 0.14, 0.17, 0.14, ...] (single attack)\n# [0.003, 0.006, 0.03, 0.05, 0.10, 0.15, 0.17, ...] (gwf attack)\n# \u2026\n</code></pre> <p>Example 1 translation:</p> <pre><code>&gt;&gt;&gt; from dyce import H\n&gt;&gt;&gt; from dyce.evaluation import HResult, foreach\n&gt;&gt;&gt; single_attack = 2@H(6) + 5\n\n&gt;&gt;&gt; def gwf(dmg):\n...   return dmg.h if dmg.outcome in (1, 2) else dmg.outcome\n\n&gt;&gt;&gt; great_weapon_fighting = 2@(foreach(gwf, dmg=H(6))) + 5  # reroll either die if it is a one or two\n&gt;&gt;&gt; print(single_attack.format(width=0))\n{..., 7:  2.78%, 8:  5.56%, 9:  8.33%, 10: 11.11%, 11: 13.89%, 12: 16.67%, 13: 13.89%, ...}\n&gt;&gt;&gt; print(great_weapon_fighting.format(width=0))\n{..., 7:  0.31%, 8:  0.62%, 9:  2.78%, 10:  4.94%, 11:  9.88%, 12: 14.81%, 13: 17.28%, ...}\n</code></pre> <p>Example 1 visualization:</p> <p> </p>    Source: <code>plot_great_weapon_fighting.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom anydyce.viz import plot_burst, plot_line\n\nfrom dyce import H\nfrom dyce.evaluation import HResult, foreach\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n\n    single_attack = 2 @ H(6) + 5\n\n    def gwf(result: HResult):\n        return result.h if result.outcome in (1, 2) else result.outcome\n\n    great_weapon_fighting = 2 @ foreach(gwf, result=H(6)) + 5\n\n    text_color = \"white\" if style == \"dark\" else \"black\"\n    label_sa = \"Normal attack\"\n    label_gwf = \"\u201cGreat Weapon Fighting\u201d\"\n    ax_plot = matplotlib.pyplot.subplot2grid((1, 2), (0, 0))\n    ax_plot.tick_params(axis=\"x\", colors=text_color)\n    ax_plot.tick_params(axis=\"y\", colors=text_color)\n    plot_line(ax_plot, [(label_sa, single_attack), (label_gwf, great_weapon_fighting)])\n    ax_plot.lines[0].set_color(\"tab:green\")\n    ax_plot.lines[1].set_color(\"tab:blue\")\n    ax_plot.legend()\n    ax_burst = matplotlib.pyplot.subplot2grid((1, 2), (0, 1))\n    plot_burst(\n        ax_burst,\n        h_inner=great_weapon_fighting,\n        h_outer=single_attack,\n        title=f\"{label_sa}\\nvs.\\n{label_gwf}\",\n        inner_cmap=\"RdYlBu_r\",\n        outer_cmap=\"RdYlGn_r\",\n        text_color=text_color,\n    )\n</code></pre> <p>Example 2 source:</p> <pre><code>from DnDice import d, advantage, plot\n\nnormal_hit = 1*d(12) + 5\ncritical_hit = 3*d(12) + 5\n\nresult = d()\nfor value, probability in advantage():\n  if value == 20:\n    result.layer(critical_hit, weight=probability)\n  elif value + 5 &gt;= 14:\n    result.layer(normal_hit, weight=probability)\n  else:\n    result.layer(d(0), weight=probability)\nresult.normalizeExpectancies()\n# \u2026\n</code></pre> <p>Example 2 translation:</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import HResult, foreach\n&gt;&gt;&gt; normal_hit = H(12) + 5\n&gt;&gt;&gt; critical_hit = 3@H(12) + 5\n&gt;&gt;&gt; advantage = (2@P(20)).h(-1)\n\n&gt;&gt;&gt; def crit(attack: HResult):\n...   if attack.outcome == 20: return critical_hit\n...   elif attack.outcome + 5 &gt;= 14: return normal_hit\n...   else: return 0\n\n&gt;&gt;&gt; advantage_weighted = foreach(crit, attack=advantage)\n</code></pre> <p>Example 2 visualization:</p> <p> </p>    Source: <code>plot_advantage.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom anydyce.viz import plot_line\n\nfrom dyce import H, P\nfrom dyce.evaluation import HResult, foreach\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n\n    normal_hit = H(12) + 5\n    critical_hit = 3 @ H(12) + 5\n    advantage = (2 @ P(20)).h(-1)\n\n    def crit(result: HResult):\n        if result.outcome == 20:\n            return critical_hit\n        elif result.outcome + 5 &gt;= 14:\n            return normal_hit\n        else:\n            return 0\n\n    advantage_weighted = foreach(crit, result=advantage)\n\n    ax = matplotlib.pyplot.axes()\n    text_color = \"white\" if style == \"dark\" else \"black\"\n    ax.tick_params(axis=\"x\", colors=text_color)\n    ax.tick_params(axis=\"y\", colors=text_color)\n    plot_line(\n        ax,\n        [\n            (\"Normal hit\", normal_hit),\n            (\"Critical hit\", critical_hit),\n            (\"Advantage-weighted\", advantage_weighted),\n        ],\n    )\n    ax.legend()\n    ax.set_title(\"Advantage-weighted attack with critical hits\", color=text_color)\n</code></pre>"},{"location":"translations/#translation-of-the-accepted-answer-to-roll-and-keep-in-anydice","title":"Translation of the accepted answer to \u201cRoll and Keep in Anydice?\u201d","text":"<p>Source:</p> <pre><code>output [highest 3 of 10d [explode d10]] named \"10k3\"\n</code></pre> <p>Translation:</p> <pre><code>&gt;&gt;&gt; from dyce import H, P\n&gt;&gt;&gt; from dyce.evaluation import explode\n&gt;&gt;&gt; res = (10@P(explode(H(10), limit=3))).h(slice(-3, None))\n</code></pre> <p>Visualization:</p> <p> </p>    Source: <code>plot_d10_explode.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom anydyce.viz import plot_line\n\nfrom dyce import H, P\nfrom dyce.evaluation import explode\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n\n    ax = matplotlib.pyplot.axes()\n    text_color = \"white\" if style == \"dark\" else \"black\"\n    ax.tick_params(axis=\"x\", colors=text_color)\n    ax.tick_params(axis=\"y\", colors=text_color)\n    plot_line(\n        ax,\n        [\n            (\n                f\"{depth} rerolls\",\n                (10 @ P(explode(H(10), limit=depth))).h(slice(-3, None)),\n            )\n            for depth in range(5, -1, -1)\n        ],\n    )\n\n    for line in ax.lines:\n        line.set_marker(\"\")\n\n    ax.legend()\n    ax.set_title(\"Taking the three highest of ten exploding d10s\", color=text_color)\n</code></pre>"},{"location":"translations/#translation-of-the-accepted-answer-to-how-do-i-count-the-number-of-duplicates-in-anydice","title":"Translation of the accepted answer to \u201cHow do I count the number of duplicates in anydice?\u201d","text":"<p>Source:</p> <pre><code>function: dupes in DICE:s {\n  D: 0\n  loop X over {2..#DICE} {\n    if ((X-1)@DICE = X@DICE) { D: D + 1}\n  }\n  result: D\n}\n</code></pre> <p>Translation:</p> <pre><code>&gt;&gt;&gt; from dyce import P\n&gt;&gt;&gt; from dyce.evaluation import PResult, foreach\n\n&gt;&gt;&gt; def dupes(p_result: PResult):\n...     dupes = 0\n...     for i in range(1, len(p_result.roll)):\n...         if p_result.roll[i] == p_result.roll[i - 1]:\n...             dupes += 1\n...     return dupes\n\n&gt;&gt;&gt; res_15d6 = foreach(dupes, p_result=15@P(6))\n&gt;&gt;&gt; res_8d10 = foreach(dupes, p_result=8@P(10))\n</code></pre> <p>Visualization:</p> <p> </p>    Source: <code>plot_dupes.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom anydyce.viz import plot_scatter\n\nfrom dyce import P\nfrom dyce.evaluation import PResult, foreach\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n\n    def dupes(result: PResult):\n        dupes = 0\n        for i in range(1, len(result.roll)):\n            if result.roll[i] == result.roll[i - 1]:\n                dupes += 1\n        return dupes\n\n    res_15d6 = foreach(dupes, result=15 @ P(6))\n    res_8d10 = foreach(dupes, result=8 @ P(10))\n\n    matplotlib.pyplot.rcParams[\"lines.markersize\"] *= 2\n    ax = matplotlib.pyplot.axes()\n    text_color = \"white\" if style == \"dark\" else \"black\"\n    ax.tick_params(axis=\"x\", colors=text_color)\n    ax.tick_params(axis=\"y\", colors=text_color)\n    plot_scatter(ax, [(\"15d6\", res_15d6), (\"8d10\", res_8d10)], alpha=1.0)\n    ax.legend()\n    ax.set_title(\"Chances of rolling $n$ duplicates\", color=text_color)\n</code></pre>"},{"location":"translations/#translation-of-how-do-i-implement-this-specialized-roll-and-keep-mechanic-in-anydice","title":"Translation of \u201cHow do I implement this specialized roll-and-keep mechanic in AnyDice?\u201d","text":"<p>Source:</p> <pre><code>function: N:n of SIZE:n keep K:n extras add {\n    result: [helper NdSIZE SIZE K]\n}\n\nfunction: helper ROLL:s SIZE:n K:n {\n    COUNT: [count SIZE in ROLL]\n    if COUNT &gt; K { result: K*SIZE - K + COUNT }\n    result: {1..K}@ROLL\n}\n</code></pre> <p>Translation:</p> <pre><code>&gt;&gt;&gt; from dyce import H, P\n\n&gt;&gt;&gt; def roll_and_keep(p: P, k: int):\n...   assert p.is_homogeneous()\n...   max_d = max(p[-1]) if p else 0\n...   for roll, count in p.rolls_with_counts():\n...     total = sum(roll[-k:]) + sum(1 for outcome in roll[:-k] if outcome == max_d)\n...     yield total, count\n\n&gt;&gt;&gt; H(roll_and_keep(6@P(6), 3))\nH({3: 1, 4: 6, 5: 21, 6: 78, 7: 207, ..., 17: 5535, 18: 2500, 19: 375, 20: 30, 21: 1})\n</code></pre> <p>Visualization:</p> <p> </p>    Source: <code>plot_roll_and_keep.py</code>   Interactive version:  <pre><code># ======================================================================================\n# Copyright and other protections apply. Please see the accompanying LICENSE file for\n# rights and restrictions governing use of this software. All rights not expressly\n# waived or licensed are reserved. If that file is missing or appears to be modified\n# from its original, then please contact the author before viewing or using this\n# software in any capacity.\n# ======================================================================================\n\nfrom __future__ import annotations\n\nfrom typing import Iterator\n\nfrom anydyce.viz import plot_line\n\nfrom dyce import H, P\n\n\ndef do_it(style: str) -&gt; None:\n    import matplotlib.pyplot\n\n    def roll_and_keep(p: P, k: int):\n        assert p.is_homogeneous()\n        max_d = max(p[-1]) if p else 0\n\n        for roll, count in p.rolls_with_counts():\n            total = sum(roll[-k:]) + sum(1 for outcome in roll[:-k] if outcome == max_d)\n            yield total, count\n\n    d, k = 6, 3\n\n    ax = matplotlib.pyplot.axes()\n    text_color = \"white\" if style == \"dark\" else \"black\"\n    ax.tick_params(axis=\"x\", colors=text_color)\n    ax.tick_params(axis=\"y\", colors=text_color)\n    marker_start = 0\n\n    def _roll_and_keep_hs() -&gt; Iterator[tuple[str, H]]:\n        for n in range(k + 1, k + 9):\n            p = n @ P(d)\n            yield f\"{n}d{d} keep {k} add +1\", H(roll_and_keep(p, k))\n\n    plot_line(ax, tuple(_roll_and_keep_hs()), alpha=0.75)\n\n    for i in range(marker_start, len(ax.lines)):\n        ax.lines[i].set_marker(\".\")\n\n    marker_start = len(ax.lines)\n\n    def _normal() -&gt; Iterator[tuple[str, H]]:\n        for n in range(k + 1, k + 9):\n            p = n @ P(d)\n            yield f\"{n}d{d} keep {k}\", p.h(slice(-k, None))\n\n    plot_line(ax, tuple(_normal()), alpha=0.25)\n\n    for i in range(marker_start, len(ax.lines)):\n        ax.lines[i].set_marker(\"o\")\n\n    ax.legend(loc=\"upper left\")\n    ax.set_title(\"Roll-and-keep mechanic comparison\", color=text_color)\n</code></pre>"},{"location":"translations/#translation-of-the-accepted-answer-to-modelling-opposed-dice-pools-with-a-swap","title":"Translation of the accepted answer to \u201cModelling opposed dice pools with a swap\u201d","text":"<p>Source of basic <code>brawl</code>:</p> <pre><code>function: brawl A:s vs B:s {\n  SA: A &gt;= 1@B\n  SB: B &gt;= 1@A\n  if SA-SB=0 {\n    result:(A &gt; B) - (A &lt; B)\n  }\n  result:SA-SB\n}\noutput [brawl 3d6 vs 3d6] named \"A vs B Damage\"\n</code></pre> <p>Translation:</p> <pre><code>&gt;&gt;&gt; from dyce.evaluation import PResult\n\n&gt;&gt;&gt; def brawl(p_result_a: PResult, p_result_b: PResult):\n...   a_successes = sum(1 for v in p_result_a.roll if v &gt;= p_result_b.roll[-1])\n...   b_successes = sum(1 for v in p_result_b.roll if v &gt;= p_result_a.roll[-1])\n...   return a_successes - b_successes\n</code></pre> <p>Rudimentary visualization using built-in methods:</p> <pre><code>&gt;&gt;&gt; from dyce import P\n&gt;&gt;&gt; from dyce.evaluation import foreach\n&gt;&gt;&gt; res = foreach(brawl, p_result_a=3@P(6), p_result_b=3@P(6))\n&gt;&gt;&gt; print(res.format())\navg |    0.00\nstd |    1.73\nvar |    2.99\n -3 |   7.86% |###\n -2 |  15.52% |#######\n -1 |  16.64% |########\n  0 |  19.96% |#########\n  1 |  16.64% |########\n  2 |  15.52% |#######\n  3 |   7.86% |###\n</code></pre> <p>Source of <code>brawl</code> with an optional dice swap:</p> <pre><code>function: set element I:n in SEQ:s to N:n {\n  NEW: {}\n  loop J over {1 .. #SEQ} {\n    if I = J { NEW: {NEW, N} }\n    else { NEW: {NEW, J@SEQ} }\n  }\n  result: NEW\n}\nfunction: brawl A:s vs B:s with optional swap {\n  if #A@A &gt;= 1@B {\n    result: [brawl A vs B]\n  }\n  AX: [sort [set element #A in A to 1@B]]\n  BX: [sort [set element 1 in B to #A@A]]\n  result: [brawl AX vs BX]\n}\noutput [brawl 3d6 vs 3d6 with optional swap] named \"A vs B Damage\"\n</code></pre> <p>Translation:</p> <pre><code>&gt;&gt;&gt; def brawl_w_optional_swap(p_result_a: PResult, p_result_b: PResult):\n...   roll_a, roll_b = p_result_a.roll, p_result_b.roll\n...   if roll_a[0] &lt; roll_b[-1]:\n...     roll_a, roll_b = roll_a[1:] + roll_b[-1:], roll_a[:1] + roll_b[:-1]\n...     # Sort greatest-to-least after the swap\n...     roll_a = tuple(sorted(roll_a, reverse=True))\n...     roll_b = tuple(sorted(roll_b, reverse=True))\n...   else:\n...     # Reverse to be greatest-to-least\n...     roll_a = roll_a[::-1]\n...     roll_b = roll_b[::-1]\n...   a_successes = sum(1 for v in roll_a if v &gt;= roll_b[0])\n...   b_successes = sum(1 for v in roll_b if v &gt;= roll_a[0])\n...   return a_successes - b_successes or (roll_a &gt; roll_b) - (roll_a &lt; roll_b)\n</code></pre> <p>Rudimentary visualization using built-in methods:</p> <pre><code>&gt;&gt;&gt; res = foreach(brawl_w_optional_swap, p_result_a=3@P(6), p_result_b=3@P(6))\n&gt;&gt;&gt; print(res.format())\navg |    2.36\nstd |    0.88\nvar |    0.77\n -1 |   1.42% |\n  0 |   0.59% |\n  1 |  16.65% |########\n  2 |  23.19% |###########\n  3 |  58.15% |#############################\n\n&gt;&gt;&gt; res = foreach(brawl_w_optional_swap, p_result_a=4@P(6), p_result_b=4@P(6))\n&gt;&gt;&gt; print(res.format())\navg |    2.64\nstd |    1.28\nvar |    1.64\n -2 |   0.06% |\n -1 |   2.94% |#\n  0 |   0.31% |\n  1 |  18.16% |#########\n  2 |  19.97% |#########\n  3 |  25.19% |############\n  4 |  33.37% |################\n</code></pre>"}]}